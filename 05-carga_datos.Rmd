# Tipos de datos II: bases de datos {#datos}

Sabemos un poco de la gram√°tica y ortograf√≠a de nuestro lenguaje, y sabemos las funcionalidades b√°sicas de nuestro Word. Vamos a encontrar la mejor trama para la novela: **hablemos de datos**.

## Matrices

Hasta ahora **hemos visto solo datos en una dimensi√≥n**: una variable, que tiene n valores num√©ricos, n valores l√≥gicos o n valores de tipo texto. **Una sola variable** (de n elementos).

Pero cuando analizamos datos solemos tener varias variables distintas. Cuando tenemos **distintas variables num√©ricas de igual longitud**, un formato de dato muy habitual de trabajar es lo que conocemos como **matrices**: una ¬´tabla¬ª de n√∫meros, con filas y columnas.

Vamos a definir las **edades, tel√©fonos y c√≥digos postales de una serie de individuos**.

```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73) # vector num√©rico de longitud 7
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)
```

Hasta ahora, cada variable la hemos definido por separado, pero ahora vamos a juntarlas: vamos a crear nuestro **primer conjunto de datos** juntado todas ellas en una matriz, un conjunto de n√∫meros organizado en **3 columnas (una por variable)** y **7 filas o registros (una por persona)**. Para ello usaremos la funci√≥n `cbind()`, que nos concatena vectores de igual longitud en formato columna.

```{r}
x <- cbind(edades, tlf, cp) # Construimos la matriz por columnas
x
```

Lo que tenemos es una columna por variable y una fila por registro. Tambi√©n podemos construir la matriz por filas con el comando `rbind()` (aunque lo habitual es tener cada variable en una columna).


```{r}
y <- rbind(edades, tlf, cp) # Construimos la matriz por filas
y
```

Como ves, ahora nuestros datos est√°n **tabulados**, tienen dos dimensiones. ¬øC√≥mo saber las **dimensiones** que tiene una matriz? Prueba a ejecutar la funci√≥n `dim()`.

```{r}
dim(x)
dim(y)
```

F√≠jate que `dim()` devuelve un vector de 2 elementos, por lo que para acceder las filas deberemos ejecutar `dim(x)[1]` (y `dim(x)[2]` para las columnas). Tambi√©n tenemos a nuestra disposici√≥n las funciones `nrow()` y `ncol()`, que nos devuelven directamente el n√∫mero de filas y columnas.

```{r}
dim(x)[1]
dim(x)[2]
nrow(x)
ncol(x)
```

Bien, ya sabemos definir una matriz a partir de variables. Igual que a veces es √∫til generar un vector de elementos repetidos, tambi√©n podemos definir una **matriz de n√∫meros repetidos** (por ejemplo, de ceros), con la funci√≥n `matrix()`, indic√°ndole el n√∫mero de filas y columnas.

```{r}
matrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0's
```

Tambi√©n podemos definir una **matriz a partir de un vector num√©rico**, reorganizando los valores en forma de matriz (con una dimensi√≥n tal que `filas * columnas = longitud del vector`), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba a abajo).

```{r}
z <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)
z
class(z) # Clase de la variable
```

&nbsp;

<details>
  <summary>![](img/logo_info.png){width=4%}  <strong>Consejos y tips</strong></summary>
  
<!-- toc -->

* **Matriz transpuesta**

Dada una matriz `x` podemos darle vuelta (lo que se conoce como **matriz transpuesta**, donde filas pasan a ser columnas y viceversa) con la funci√≥n `t()`.

```{r}
x
t(x) # Matriz transpuesta
```

<!-- tocstop -->
</details>



&nbsp;


<details>
  <summary>üìù<strong>Ejercicio</strong>: define una matriz de ceros de 3 filas y 7 columnas. Tras hacerlo calcula su transpuesta y obt√©n sus dimensiones</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(0, nrow = 3, ncol = 7)

# Transpuesta
t(matriz)

# Dimensiones transpuesta
dim(t(matriz))
ncol(t(matriz))
nrow(t(matriz))
```

<!-- tocstop -->
</details>


## Apply vs bucles

Si has programado en alg√∫n otro lenguaje, estar√°s echando en falta elementos como un `if (blabla) {...} else {...}` (que los usaremos a veces) o bucles `for` y `while`.

**¬øNo existen los bucles en `R`?** S√≠, s√≠ existen. He aqu√≠ un ejemplo.

```{r}
v <- rep(0, 20) # Vector de 20 ceros
for (i in 1:20) { # Bucle en base a un √≠ndice i que va de 1 a 20

  v[i] <- i^2 # En cada iteraci√≥n guardamos el valor de i al cuadrado en el elemento i del vector v
    
}
v
``` 

La raz√≥n por la que no hemos usado a√∫n **bucles**, e intentaremos evitarlos lo m√°ximo posible, es porque son **muy ineficientes** en tiempo de ejecuci√≥n. Vamos a poner un ejemplo. Supongamos que de la matriz `x` queremos calcular la suma de cada fila (es decir, 7 valores) o la suma de cada columna (3 valores). Con bucles ser√≠a as√≠.

```{r}
suma_por_filas <- rep(0, dim(x)[1]) # dim(x)[1] n√∫mero de filas
suma_por_cols <- rep(0, dim(x)[2]) # dim(x)[2] n√∫mero de columnas
for (i in 1:dim(x)[1]) { # Bucle recorriendo filas

  suma_por_filas[i] <- sum(x[i, ], na.rm = TRUE) # Suma de la fila i, eliminando NA
    
}
suma_por_filas

for (j in 1:dim(x)[2]) { # Bucle recorriendo filas

  suma_por_cols[j] <- sum(x[, j], na.rm = TRUE) # Suma de la columna j, eliminando NA
    
}
suma_por_cols
``` 

En el c√≥digo anterior puedes ver como para **acceder a la fila i-√©sima de la matriz** se usa el operador `[i, ]` (dejando libre el √≠ndice de la columna), mientras que para **acceder a la columna j-√©sima de la matriz** se usa el operador `[, j]`. Para **acceder al elemento `(i, j)`** se usa el operador `[i, j]`. Tambi√©n habr√°s observado que, si escribes los bucles en tu script, tienen una flecha a la izquierda para ser minimizados.

La pregunta es: **¬øno hay una forma m√°s eficiente de hacerlo?**

La respuesta: s√≠. La **funci√≥n `apply()` nos permite ejecutar una funci√≥n por filas o por columnas**.

```{r}
# Suma por filas (MARGIN = 1) quitando NA
suma_por_filas <- apply(x, MARGIN = 1, FUN = "sum", na.rm = TRUE)
suma_por_filas 

# Una funci√≥n cualquiera por filas
operacion_por_filas <- apply(x, MARGIN = 1, FUN = function(x) { sum(sqrt(2) - 2) })
operacion_por_filas

# Suma por columnas (MARGIN = 2) quitando NA
suma_por_cols <- apply(x, MARGIN = 2, FUN = "sum", na.rm = TRUE)
suma_por_cols
```

Como puedes observar, necesitas tres argmentos y otros opcionales: la matriz, el √≠ndice por el que operar (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la funci√≥n a aplicar, am√©n de otros argumentos extras que pudiera necesitar la funci√≥n.

Veamos qu√© es m√°s eficiente con el ya conocido paquete `{microbenchmark}`.

```{r}
microbenchmark::microbenchmark(for (i in 1:dim(x)[1]) {
  suma_por_filas[i] <- sum(x[i, ], na.rm = TRUE)}, apply(x, MARGIN = 1, FUN = "sum", na.rm = TRUE), times = 1e2) # Comparamos tiempos de ejecuci√≥n de ambas formas, y lo repetimos 100 veces para sacar tiempos medios
```

**¬°El bucle nos tarda 50 veces m√°s que el `apply`!** Di no a los bucles: casi siempre hay una forma mejor de hacerlo.

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio</strong>: calcula la suma de cada fila de la matriz `matriz <- matrix(1:12, nrow = 4)` usando un bucle. Haz lo mismo evitando usar bucles.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Con bucle (recorremos sus filas)
suma <- rep(0, nrow(matriz)) # Definimos un vector de 0's con tantos elementos como filas, donde iremos metiendo los valores de la suma
for (i in 1:nrow(matriz)) {
  
  suma[i] <- sum(matriz[i, ]) # Sumamos la fila i
}
suma

# Sin bucle (MARGIN = 1 ya que es una operaci√≥n por filas)
suma <- apply(matriz, MARGIN = 1, FUN = "sum")
suma
```

<!-- tocstop -->
</details>


&nbsp;


## Tablas: data.frames


Adem√°s del nombre de las columnas que ha heredado la matriz `x` de la concatenaci√≥n de las columnas que hemos realizado, podemos poner **nombre a los registros**, por ejemplo, el nombre de las personas a las que pertenece cada dato, definiendo una nueva variable con los nombres y concaten√°ndola.


```{r}
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
cbind(nombres, x)
```

**¬øHas visto lo que ha sucedido?**

Como **una matriz solo puede tener un tipo de dato**, al a√±adir una variable de tipo texto, ha convertido los n√∫meros tambi√©n a texto poni√©ndole comillas: hemos roto la integridad de nuestro dato. Una forma de a√±adir **nombre a los registros, sin incluirlo como variable**, es usando la funci√≥n `row.names()`.

```{r}
row.names(x) <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
x
```

*¬øQu√© sucede si realmente queremos a√±adir variables cuyos tipos sean distintos (¬°ojo, pero con la misma longitud!)?*

Vamos a crear nuevas variables de texto `nombres` y `apellidos`, un valor l√≥gico `casado` y una fecha `fecha_creacion` (fecha de entrada en el sistema) para cada persona.

```{r}
# Nombres
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos <- c("P√©rez", "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")

# Estado civil (no lo sabemos de una persona)
casado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Fecha de creaci√≥n (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion <- as.Date(c("2021-03-04", "2020-10-12", "1990-04-05",
                            "2019-09-10", "2017-03-21", "2020-07-07",
                            "2000-01-28"))
```


Seguimos teniendo 7 registros, uno por persona pero ahora tenemos un popurr√≠ de variables, de la **misma longitud pero de tipos distintos**: `(edades, tlf, cp)` son variables num√©ricas, `(nombres, apellidos)` son variables de texto, `casado` es una variable l√≥gica y `fecha_creacion` de tipo fecha. **¬øQu√© suceder√° si yo intento mezclar todo en una matriz?**


```{r}
# Juntamos todo en una matriz (juntamos por columnas)
x <- cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
x
```

Efectivamente: como en una matriz solo puede haber datos de un tipo, los n√∫meros los convierte a texto, las variables l√≥gicas las converte a texto (`TRUE` es un valor l√≥gico, `"TRUE"` es un texto, como `"Pepito"`, sin significado l√≥gico - booleano - de verdadero/falso) y las fechas las ha convertido a texto (aunque las veas igual, ya no son de tipo de fecha, son texto y no podemos operar con ellas).

```{r error = TRUE}
# D√≠as entre la primera y el segundo elemento de fecha de creaci√≥n
fecha_creacion[1] - fecha_creacion[2]

# D√≠as entre primera y segunda fecha de creaci√≥n pero tom√°ndolo de nuestra matriz (columna 7, fila 1 y 2)
x[1, 7] - x[2, 7]
```

He aqu√≠ LA pregunta: **¬øc√≥mo juntar variables de distinto tipo, sin cambiar su naturaleza, como cuando juntamos datos en una tabla de excel?**

El formato de tabla de datos en `R` que vamos a empezar a usar se llama **data.frame**: una **colecci√≥n de variables de igual longitud pero cada una de un tipo distinto**. Para crear un objeto de este tipo basta con usar la funci√≥n `data.frame()`, pas√°ndole como argumentos (separados por comas) las variables que queremos reunir, indicando en texto `"..."` el nombre de las columnas.

```{r}
# Creamos nuestro primer data.frame
tabla <- data.frame("Nombre" = nombres, "Apellido" = apellidos,
                    "Edad" = edades, "Tel√©fono" = tlf,
                    "C√≥digo Postal" = cp, "Casado" = casado,
                    "Fecha_de_creaci√≥n" = fecha_creacion)
tabla
```

**¬°TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**

&nbsp;


<details>
  <summary>![](img/logo_info.png){width=4%}  <strong>Consejos y tips</strong></summary>
  
<!-- toc -->

* **Acceso a librer√≠a**

A veces puede que no queramos cargar todo un paquete sino solo una funci√≥n del mismo, para lo que es suficiente `nombre_paquete::nombre_funcion`.

&nbsp;  

&nbsp; 

* **Nombre de variables**

La funci√≥n `names()` no solo sirve para consultar los nombres de las variables de un `data.frame` sino tambi√©n para cambiarlos a nuestro gusto.

```{r}
# Consultamos nombres
names(tabla)

# Cambiamos nombres
names(tabla) <- c("nombre_persona", "apellido_persona", "edad", "tlf",
                  "cp", "casado", "f_creacion")
tabla
```

<!-- tocstop -->
</details>




### Data.frames: selecci√≥n manual de columnas y filas

Si tenemos un `data.frame` ya creado y queremos **a√±adir una columna** es tan simple como usar la funci√≥n  `data.frame()` que ya hemos visto para concatenar la columna. Si queremos acceder a una columna, fila o elemento en concreto, **los `data.frame` tienes las mismas ventajas que una matriz**, as√≠ basta con usar los mismos operadores.

```{r}
# A√±adimos una nueva columna con n¬∫ de hermanos/as
hermanos <- c(0, 0, 1, 5, 2, 3, 0)
tabla <- data.frame(tabla, hermanos)
tabla

# Accedemos a la tercera columna
tabla[, 3]

# Accedemos a la quinta fila
tabla[5, ]

# Accedemos a la tercera variable del quinto registro
tabla[5, 3]
``` 


Un `data.frame` **no solo tiene las ventajas de una matriz sino que tambi√©n tiene las ventajas de una tabla de datos**. Por ejemplo, podemos **aceder a las variables** por el √≠ndice de columna que ocupan pero **tambi√©n por su nombre**, poniendo el nombre de la tabla, el s√≠mbolo `$` y con el tabulador nos aparecer√° un men√∫ de columnas a elegir. 

```{r tabla-dolar, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Men√∫ desplegable de variables (columnas) de un data.frame."}
knitr::include_graphics("./img/tabla_dolar.jpg")
```

**Volvamos a nuestro script**.

Vamos a crear un script nuevo en la caprta `CODIGOS` de nuestro proyecto que se llame `primer_data_frame.R`. En √©l vamos a definir las variables que hab√≠amos lanzado en consola, y vamos a construir el mismo `data.frame` llamado `tabla` que ten√≠amos pero en nuestro script.


```{r codigo-primer-data-frame, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Creando nuestro primer data.frame en el script."}
knitr::include_graphics("./img/codigo_primer_data_frame.jpg")
```

```{r}

# Descripci√≥n: creaci√≥n de nuestros primeros data.frame

# Variables
edades <- c(14, 24, 56, 31, 20, 87, 73) # vector num√©rico de longitud 7
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
apellidos <- c("P√©rez", "Gonz√°lez", "Fern√°ndez", "Mart√≠nez", "Li√©bana", "Garc√≠a", "Ortiz")
casado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)
fecha_creacion <-
  as.Date(c("2021-03-04", "2020-10-12", "1990-04-05", "2019-09-10",
            "2017-03-21", "2020-07-07", "2000-01-28"))
hermanos <- c(0, 0, 1, 5, 2, 3, 0)

# Creamos el data.frame
tabla <- data.frame("Nombre" = nombres, "Apellido" = apellidos,
                    "Edad" = edades, "Tel√©fono" = tlf, "C√≥digo Postal" = cp,
                    "Casado" = casado, "Fecha_de_creaci√≥n" = fecha_creacion)
tabla <- data.frame(tabla, hermanos)
tabla
```


```{r codigo-2, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Llamando a nuestro script desde nuestro c√≥digo principal."}
knitr::include_graphics("./img/codigo_2.jpg")
```

Adem√°s de dicho conjunto de datos, vamos a instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy √∫til en `R` llamado `{datasets}`. Los paquetes que vayamos necesitando los instalaremos y llamaremos al inicio del c√≥digo principal.

```{r carga-paquetes-inicial, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Instalamos y cargamos los paquetes necesarios al principio de nuestro main.R."}
knitr::include_graphics("./img/carga_paquetes_inicial.jpg")
```


```{r}
# Paquetes necesarios
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
```

Tras ello llamaremos a nuestro script `primer_data_frame.R` desde nuestro c√≥digo principal `main.R` y guardaremos el script con el _source on save_ activado para que se ejecute. Adem√°s de que ahora tenemos nuestro conjunto de datos `tabla` en nuestro panel de entorno, si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usados: el paquete `datasets` nos proporciona `data.frames` de prueba para que podamos usarlos en nuestros c√≥digos seg√∫n vamos aprendiendo.

```{r datasets, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Men√∫ desplegable con los data.frame de prueba en datasets"}
knitr::include_graphics("./img/datasets.jpg")
```

Una de las **ventajas de los `data.frame`** es que podemos visualizarlos como si fuera una tabla de Excel dentro de nuestro `R` con la funci√≥n `View()`. Vamos a visualizar no solo el conjunto de datos `tabla` sino tambi√©n el conjunto `iris` del paquete `datasets`: **los `data.frame` nos permiten trabajar con ellos como bases de datos o como matrices, con las ventajas de ambos**.

```{r eval = FALSE}
View(iris)
View(tabla)
```

```{r view-datasets, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Men√∫ desplegable con los data.frame de prueba en datasets"}
knitr::include_graphics("./img/view_datasets.jpg")
```

&nbsp;

En el caso de los `data.frame` tenemos adem√°s a nuestro disposici√≥n una **herramienta muy potente: la funci√≥n `subset()`** Dicha funci√≥n nos va a permitir seleccionar filas y columnas autom√°ticamente, tomando de entrada los siguientes argumentos

- `x`: una tabla de entrada, un `data.frame` de entrada.
- `subset`: la condici√≥n l√≥gica que queramos usar para seleccionar registros (filas).
- `select`: un vector que contenga el nombre de las columnas que queremos seleccionar (a lo mejor solo queremos filtrar por filas pero quiz√°s tambi√©n por columnas).

Por ejemplo, vamos a seleccionar solo los nombres y apellidos de aquellas personas mayores de edad de nuestro conjunto de datos `tabla`, y del conjunto `iris` vamos a extraer todos los registros en los que el largo del s√©palo es mayor que 7.1, seleccionando solo las columnas de longitud de s√©palo y la especie de la planta.


```{r}
subset(tabla, subset = Edad > 18, select = c("Nombre", "Apellido"))
subset(iris, subset = Sepal.Length > 7.1, select = c("Sepal.Length", "Species"))
``` 

<details>
  <summary>üìù<strong>Ejercicio</strong>: del conjunto `iris` del paquete `datasets` obt√©n el nombre de las variables, y selecciona aquellas filas cuya variable `Petal.Width` sea distinta de 0.2, y qu√©date solo con las variables `Sepal.Length`, `Sepal.Width` y `Species`. Calcula el n√∫mero de filas borradas. Tras hacer todo ello, traduce a castellano el nombre de las columnas del `data.frame` filtrado.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Nombres de variables
names(iris)

# Filtramos filas
filtro_fila <- subset(iris, subset = Petal.Width != 0.2)

# Filtramos columnas
filtro_col <- subset(filtro_fila,  select = c("Sepal.Length", "Sepal.Width", "Species"))

# Todo de una vez
filtro <- subset(iris, subset = Petal.Width != 0.2, select = c("Sepal.Length", "Sepal.Width", "Species"))
filtro

# Filas borradas
nrow(iris) - nrow(filtro)

# Cambiamos nombres a castellano del conjunto filtrado
names(filtro) <- c("longitud_sepalo", "anchura_sepalo", "especies")
```

<!-- tocstop -->
</details>


# Importando/exportando {#importar_exportar}

Hemos aprendido a **crear nuestros propios datos** pero la mayor√≠a de veces los cargaremos de distintos archivos, fuentes, etc. Vamos a ver las **4 formas m√°s comunes de importar (cargar) datos**

## Importaci√≥n de datos

Las **4 formas m√°s comunes de importar (cargar) datos** son:

- desde un archivo propio de `R` (extensi√≥n `.RData`).
- desde un archivo separado por comas (un archivo `.csv`).
- desde un excel (archivo `.xlsx`).
- desde un enlace de internet.

### Archivo .RData

La forma m√°s sencilla de guardar datos y variables en `R`, y que adem√°s ocupa menos espacio en nuestro disco duro, es guardarlo en archivos propios que tiene `R` como son los archivos con extensiones `.rda` y `.RData`.

Es **recomendable** tener los datos en la misma carpeta del proyecto pero una carpeta separada, ya que podemos tener muchos archivos y as√≠ no mezclamos dichos ficheros con los c√≥digos que escirbamos. En la carpeta `DATOS` del proyecto tenemos 4 archivos `.RData`: `coches.RData`, `panel_vacunas_ccaa.RData`, `panel_vacunas_fecha.RData` y `panel_variables.RData`. **¬øC√≥mo cargar archivos `.RData`?**

Muy sencillo: como son ficheros nativos de `R`, basta con usar la funci√≥n de carga `load()`, y dentro la ruta de los archivos. 

```{r include = FALSE}
# Al fijar directorio de trabajo, no necesitamos toda la ruta, solo "./" y la ruta dentro de la carpeta del proyecto
load("./DATOS/coches.RData")
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
load("./DATOS/panel_variables.RData")
```

```{r eval = FALSE}
# Al fijar directorio de trabajo, no necesitamos toda la ruta, solo "./" y la ruta dentro de la carpeta del proyecto
load("./DATOS/coches.RData") 
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
load("./DATOS/panel_variables.RData")
```

```{r carga-RDATA, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Importaci√≥n de ficheros de extensi√≥n .RData."}
knitr::include_graphics("./img/carga_RDATA.jpg")
```


Como ves en la imagen \@ref(fig:carga-RDATA), en el panel de entorno de la parte superior derecha ahora tendremos 4 `data.frames` que antes no ten√≠amos. Un funci√≥n muy √∫til es `head()`, con argumento el nombre de un `data.frame`, que nos permite visualizar las primeras columnas.

```{r}
# Ver las primeras filas de la tabla que guarda distintos modelos de coche y caracter√≠sticas
head(coches)
```


### Archivo .csv

Otra opci√≥n de importaci√≥n habitual son los **archivos `.csv` (comma separated values)**: son archivos separados por comas (u otro caracter como puntos, puntos y comas, o tabuladores). En apariencia cuando los abrimos en el ordenador son como un Excel (ya que los abre el Excel), pero ocupan mucho menos que un Excel y su **lectura es universal** (independiente de tener instalado o no el Excel) ya que son archivos de texto **sin formato**.

Para leer un archivo `.csv` basta con usar la funci√≥n `read.csv()`, y la mayor√≠a de las veces basta indicarle la ruta del archivo para su lectura (argumento `file`).

```{r include = FALSE}
vacunas_esp <- read.csv(file = "~/Dropbox/DIVULGACI√ìN/CURSO R BIOQUIMICA EN MOVIMIENTO/CURSO R/curso_R/DATOS/datos_ES.csv")
```


```{r eval = FALSE}
vacunas_esp <- read.csv(file = "./DATOS/datos_ES.csv")

```

```{r}
names(vacunas_esp) # Todas las variables del data.frame
vacunas_esp[1:5, 1:7] # Primeras filas y columnas
```

Podemos personalizar la lectura en funci√≥n del archivo, dando valores a los argumentos `sep` (para indicar el caracter que se est√° usando para separar columnas, en caso de no ser `","` por defecto), `dec` (el caracter que esdtamos usando para marcar decimales, por defecto es `"."`) o `header` (por defecto en `TRUE`, lo que le indicamos que el nombre de las columnas est√° en la primera fila). Al tener nuestro archivo preparado para que sirva con los par√°metros por defecto no debemos a√±adirlo, pero podemos hacer la prueba para ver que la lectura es la misma.

```{r include = FALSE}
vacunas_esp <- read.csv(file = "~/Dropbox/DIVULGACI√ìN/CURSO R BIOQUIMICA EN MOVIMIENTO/CURSO R/curso_R/DATOS/datos_ES.csv", sep = ",", dec = ".", header = TRUE)
```

```{r eval = FALSE}
vacunas_esp <- read.csv(file = "./DATOS/datos_ES.csv", sep = ",", dec = ".", header = TRUE)
```

```{r}
vacunas_esp[1:5, 1:7] # Primeras filas y columnas
```


### Archivo .xlsx

Muchas veces no tendremos un `.csv` (por desgracia) y nos tocar√° leer desde un excel. Para ello deberemos instalar (la primera vez) y cargar el paquete `{readxl}` que nos permitir√° usar funciones para cargar archivos `.xls` (la funci√≥n `read_xls()`) y archivos `.xlsx` (la funci√≥n `read_xlsx()`). Adem√°s del argumento `path` con la ruta del archivo, podemos en el argumento `sheet` indicarle la hoja de Excel a leer (en caso de tener varias).

```{r eval = FALSE}
install.packages("readxl")
library(readxl)
boston <- read_xlsx(path = "./DATOS/Boston.xlsx")
```

```{r include = FALSE}
library(readxl)
boston <- read_xlsx(path = "~/Dropbox/DIVULGACI√ìN/CURSO R BIOQUIMICA EN MOVIMIENTO/CURSO R/curso_R/DATOS/Boston.xlsx")
```

```{r}
head(boston)
```



### Desde web

Por √∫ltimo, muchas veces querremos cargar archivos colgados en la web que, aunque al descargarlos son `.csv` o `.xlsx`, son archivos din√°micos que sabemos que van a ir cambiando, como por ejemplo los datos de casos covid, hospitalizados, ingresos UCI y fallecidos, de la p√°gina del ISCIII <https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos>.


```{r ISCIII, echo = FALSE, out.width = "75%", fig.align = "center", fig.cap = "Archivos de la pandemia en el ISCIII."}
knitr::include_graphics("./img/ISCIII.jpg")
```

Esos archivos cambian cada d√≠a, por lo que para visualizarlos, analizarlos o guardarlos cada d√≠a, tendr√≠amos que, cada d√≠a, entrar de forma manual a la p√°gina y bajarnos el archivo. O no...

`R` nos permite **leer archivos subidos en una web, d√°ndole a la funci√≥n de lectura el enlace del archivo en lugar de la ruta local de nuestro ordenador** (para averiguar el enlace, basta con clickar bot√≥n derecho en la web y seleccionar ¬´copiar direcci√≥n de enlace¬ª)

```{r}
datos_ISCIII <- read.csv(file = "https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv")
head(datos_ISCIII)
```

Mientras el enlace web no cambie, cada vez que ejecutemos esa orden en nuestro c√≥digo tendremos en `datos_ISCIII` el √∫ltimo archivo actualizado que haya, sea el que sea, sin tener que descargarlo de forma manual, ¬°y sin necesidad de guardarlo en nuestro local, solo en la memoria virtual de nuestra sesi√≥n de `R`!


## Exportaci√≥n de datos

Aunque se puede exportar en cualquier formato que puedas importar, vamos a ver las **dos formas m√°s √∫tiles y eficientes de exportar datos en `R`**: 

- fichero `.RData`.
- fichero `.csv` (obviaremos la exportaci√≥n a Excel porque un `.csv` ya es posible abrirlo con dicho engendro del demonio).

### Guardar en .RData

La exportaci√≥n en fichero `.RData` es la opci√≥n **m√°s recomendable si t√∫ o tu equipo solo trabaj√°is con `R`**, es la opci√≥n nativa de fichero, para que su importaci√≥n sea tan sencilla como una funci√≥n `load()`. Para exportar en `R.Data` basta con uses la funci√≥n `save()`, ind√≠candole lo que quieres guardar y la ruta donde quieres guardarlo.

Es **importante** entender que la principal ventaja de exportar un fichero `.RData` es que no se est√° portando una tabla, o un fichero tabulado con un formato de filas y columnas: est√°s exportando **cualquier cosa**, cualquier variable de `R`, con la naturaleza de esa variable intacta, sin necesidad de pasarlo otro formato.

```{r eval = FALSE}
# Exportamos en .RData la variable nombres 
save(nombres, file = "./EXPORTAR/nombres.RData")
``` 

Para tenerlo organizado, la orden anterior est√° hecha habiendo creado en nuestra carpeta del proyecto una carpeta `EXPORTAR` para guardar lo que vayamos exportando. Ese fichero solo podr√° ser abierto por `R`, pero cuando lo cargemos, tendremos la variable `nombres` tal cual la hemos guardado.

### Guardar en .csv

No siempre trabajamos en `R` y a veces necesitamos una exportaci√≥n de  un `data.frame` o una tabla que podamos abrir en nuestra ordenador, ya sea para explic√°rsela a alguien o para envi√°rsela a otra persona. Para ello exportaremos en `.csv`, un fichero sin formato, y que es capaz de ser abierto por todo tipo de hojas de c√°lculo: basta que usemos la funci√≥n `write.csv()`.

```{r eval = FALSE}
# Exportamos en .csv el data.frame tabla
write.csv(tabla, file = "./EXPORTAR/tabla.csv")
```

Podemos consultar con `? write.csv` las distintas opciones de exportaciones (por ejemplo, con `row.names` podemos indicarle si queremos nombres de filas o no, y con `col.names` si queremos exportar la cabecera con el nombre de las columnas).

&nbsp;

<details>
  <summary>![](img/logo_info.png){width=4%}  <strong>Consejos y tips</strong></summary>
  
<!-- toc -->

* **Paquetes `{readr}` y `{tidyr}`**

En dichos paquetes tienes m√°s funciones para una **f√°cil exportaci√≥n y tabulaci√≥n de distintos tipos de datos**, sea el formato que sea. Ver <https://tidyr.tidyverse.org/> y <https://readr.tidyverse.org/>

```{r paquete-readr, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete readr."}
knitr::include_graphics("./img/readr.png")
```

```{r tidyr, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete tidyr."}
knitr::include_graphics("./img/tidyr.png")
```


&nbsp;  

&nbsp;  

* **Paquete `{tibble}`**

En dicho paquete tienes m√°s **funciones para una gesti√≥n m√°s √°gil, eficiente y coherente de los `data.frame`**. Ver <https://tibble.tidyverse.org/>.

&nbsp;  

&nbsp;  

* **Paquete `{rvest}`**

En dicho paquete tienes m√°s **funciones para una lectura directamente de una p√°gina web (no desde un documento, desde la propia p√°gina web, como si estuvieras navegando en ella)**. Ver <https://github.com/tidyverse/rvest>.


&nbsp;  

&nbsp;  

* **Secciones**

Los comentarios no solo sirven para documentar el c√≥digo sino que adem√°s pueden servirnos para **construir secciones de c√≥digo**. Prueba a escribir un comentario con varias `###############`: ¬øves la flecha que te aparece en la parte izquierda? Sirve para minimizar o maximizar trozos de c√≥digo, de forma que tu c√≥digo a√∫n m√°s limpio.

```{r indice, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Secciones en el c√≥digo."}
knitr::include_graphics("./img/indice.jpg")
```

&nbsp;  

&nbsp;  

* **L√≠neas de c√≥digo**

Dado que los errores del c√≥digo nos vendr√°n referenciados en la consola por el n√∫mero de l√≠nea donde fueron detectados, puede sernos muy √∫til mostrar dichos n√∫meros en la barra lateral izquierda, yendo a `Tools << Global Options << Code << Display << Show line numbers`

```{r show-line-numbers, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "L√≠neas de c√≥digo."}
knitr::include_graphics("./img/show_line_numbers.jpg")
```

&nbsp;  

&nbsp;  

* **Margen derecho**

Aunque no afecte a nuestro c√≥digo escribir todo en una l√≠nea sin saltos de l√≠nea, no somos b√°rbaros/as. ¬øPor qu√© cuadno escribes en un Word lo haces en formato vertical pero cuando programas pones todas las √≥rdenes seguidas? Recuerda que la legibilidad de tu c√≥digo no solo te ahorrar√° tiempo sino que te har√° programar mejor. ¬øC√≥mo podemos fijar un margen imaginario para nosotros ser quienes demos al _ENTER_? Yendo a `Tools << Global Options << Code << Display << Show margin` (es un margen imaginario para ser nosotros quienes lo hagamos efectivo, a `R` le da igual)

```{r show-margin, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Margen derecho."}
knitr::include_graphics("./img/show_margin.jpg")
```

<!-- tocstop -->
</details>



