# Estructuras de control {#control}

Aunque la mayoría de veces son sustituibles por otras expresiones más legibles y eficientes, es importante que conozcamos como se usan las **expresiones de control más típicas**.

## if...else
 
 
Como en cualquier lenguaje de programación, las **estructuras `if...else...` nos permiten ejecutar partes de nuestro código solo cuando se cumple la condición o condiciones lógicas** que queremos. Cuando ejecutamos un `if` estamos diciendo

> SI las condiciones impuestas se cumplen (TRUE), ejecuta las ordenes que tengamos dentro de las llaves. En caso contrario, no sucede nada SALVO que tengamos además un else anidado.

Si el`if` devuelve `FALSE`, no sucederá nada **SALVO** que tengamos además un **`else`: lo que sucede cuando no se cumple**, como en el ejemplo que tenemos debajo.


```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73)
mayores_de_edad <- FALSE 

if (all(edades >= 18)) { # Si todas las personas son mayores de edad
  
  mayores_de_edad <- TRUE
  print("todos mayores de edad")
  
} else { # si la condición no se cumple: filtramos solo los mayores

  edades <- edades[edades >= 18]  
  print("algún menor de edad se ha eliminado")
  
}
```

Las órdenes dentro del primer `if` se ejecutará si todas las personas son mayores de edad. En caso de no cumplirse (como es el caso), se ejecutará lo que hay entre llaves tras el `else` (filtra solo los mayores de edad e imprime un mensaje de control).

Dicha estructura puede **anidarse**, de forma que vayamos concatenando estructuras `ifelse`, como en el ejemplo que tenemos debajo.

```{r}
edades <- c(14, 14, 16, 11, 2, 17, 13)

if (all(edades >= 18)) { # Si todas las personas son mayores de edad
  
  mayores_de_edad <- TRUE
  print("todos mayores de edad")
  
} else if (any(edades >= 18)) { # si alguna es mayor de edad

  edades_18 <- edades[edades >= 18]  
  print("algún menor de edad se ha eliminado")
  
} else { # ninguna persona mayor de edad
  
  print("todas las personas son menores de edad")
  
}
```


Esta **estructura condicional puede ser vectorizada**, de forma que podamos reunir en una **sola fila un número elevado de estructuras de comparación**. Por ejemplo, vamos a definir un vector de números y vamos a comprobar si son números pares o impares (para ello, usamos el operador `%%`, que nos calcula el resto de cada número al dividirlo por una cifra).

```{r}
1 %% 2
2 %% 2
3 %% 2
5 %% 3
```

Para nuestro objetivo aplicaremos la función `ifelse()`, cuyos argumentos de entrada serán la condición a evaluar, lo que sucede cuando se cumple y lo que no, que aplicará a cada elemento del vector de entrada.


```{r}
numeros <- 1:10
ifelse((numeros %% 2) == 0, "par", "impar") # Los pares al dividir entre 2 tienen resto 0
```

Esta función `ifelse()` es muy util para codificar variables o averiguar cuales cumplen una condición, sin necesidad de hacer un bucle que recorra todos los valores. **Recuerda: di (por lo general) no a los bucles**.


## for/while

Aunque el 99% (porcentaje inventado, pero más o menos) de las veces los bucles pueden ser sustituidos por códigos de forma vectorial mucho más eficientes (ya hemos visto algunos ejemplos), a veces no nos quedará más remedio que usarlos por lo que nunca viene mal conocer su estructura.

Un **bucle `for{}` es una estructura que nos permite ejecutar un conjunto de órdenes un número repetido (finito y conocido)** de veces: dado un conjunto de índices, el **bucle irá recorriendo cada elemento** de dicho conjunto, y para cada uno de ellos ejecutará lo que tenga dentro de las llaves.

```{r}
indices <- 1:10
variable <- NULL # vector donde guardaremos los pasos del bucle
for (i in 1:10) { 
  
  variable[i] <- i # R es silenciosos: salvo que hagamos un print dentro del bucle no nos imprimirá nada por pantalla
}
variable

for (i in 1:length(indices)) { 
  
  variable[i] <- i
}
variable

for (i in 1:length(indices)) { 
  
  print(i^3) # imprimimos el índice al cubo
}
```

Escribiendo `length(indices)`, si cambiamos la variable `indice` no necesitamos cambiar el bucle (llegará hasta el final de dicho conjunto de valores, valga lo que valga).

Aunque normalmente el conjunto que recorre el bucle suelen ser índices numéricos, **podemos recorrer cualquier tipo de objeto**.

```{r}
dias_semana <- c("lunes", "martes", "miércoles", "jueves",
                 "viernes", "sábado", "domingo")
nombre_mayuscula <- NULL
for (dias in dias_semana) { # dias recorre los días de la semana tomando sus valores
  
  print(toupper(dias))
}
```


&nbsp;

Otra manera de diseñar un bucle es con la **estructura `while{}`**, que ejecutará el **bucle un número de veces a priori desconocido** hasta que la condición impuesta deje de ser `TRUE`.

```{r}
max_ciclos <- 10
ciclos <- 1

# Mientras el número de ciclos sea inferior 10, imprime
while(ciclos <= max_ciclos) {
  
  print(paste("Todavía no, vamos por el ciclo ", ciclos)) # Pegamos la frase al número de ciclo por el que vayamos con paste
  ciclos <- ciclos + 1
  
}
``` 

**¿Y qué sucede cuando la condición nunca llega a ser `FALSE`?** Compruébalo tú mismo/a.

```{r eval = FALSE}
while (1 > 0) { # Nunca va a dejar de ser cierto
  
  print("Presiona ESC para salir del bucle")
  
}
```

### BREAK/NEXT

En `R` tenemos dos comandos reservados para poder **abortar un bucle** o **avanzar forzosamente un bucle**: dichas palabras son `break` y `next`. La primera nos habilita para **parar un bucle** aunque no haya llegado al final de su conjunto de índices a recorrer (o se siga cumpliendo la condición del `while{}`).

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    break # si i es 7, el bucle frena aquí (nunca llegará a imprimir el 7 ni los sucesivos)
    
  }
  print(i)
}
```

Mientras que la segunda **obliga al bucle a avanzar a la siguiente interacción**, abortando la iteración actual en la que se encuentra. 

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    next # si i es 7, la iteración frenará aquí y pasará a la siguiente por lo que imprimirá todos menos el 7
    
  }
  print(i)
}
```

### REPEAT

Aunque es una opción muy poco usada, existe una estructura de control llamada `repeat{}` que nos **ejecuta un bucle de forma infinita** hasta que le ordenemos parar con un `break`.

```{r}
conteo <- 0
repeat { 
  
  conteo <- conteo + 1
  if (conteo >= 100) { break }
  
}
conteo
``` 




## ![](img/logo_info.png){width=4%} Consejos y tips

<details>
  <summary><strong>Cuidado con los bucles infinitos</strong></summary>
  
Las estucturas `while{}` y `repeat{}` son de las menos usadas por su peligrosidad, ya que si no incluimos un `break` o la condición nunca llega a ser `TRUE`, el bucle seguirá ejecutándose de forma infinita y solo podrá ser detenido abortando la ejecución con la tecla `ESC`.

</details>

&nbsp;  

<details>
  <summary><strong>Código limpio: minimizando estructuras de control en el código</strong></summary>
  
Puedes minimizar las estructuras de control pulsando en la flecha que aparece a la izquierda de ellas. 

</details>

