```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# Tipos de datos II: datos estructurados {#datos}

Ya sabemos un poco la gramática y ortografía de nuestro lenguaje, y algunas de las funcionalidades básicas de nuestro «Word». Vamos a aprender cómo escribir la mejor trama para la novela: hablemos de <mark>**estructuras de datos**</mark>.

## Matrices

Hasta ahora **hemos visto solo datos en una dimensión**: una variable, que tiene $n$ valores numéricos, $n$ valores lógicos o $n$ valores de tipo texto. **Una sola variable** (de $n$ elementos).

```{r}
c(1, 4, NA, -2, 0)
c("a", NA, "b", "c")
c(TRUE, TRUE, FALSE, TRUE)
```

Pero cuando analizamos datos solemos tener varias variables distintas, por ejemplo, la **estatura y el peso de una persona**. Cuando tenemos **distintas variables numéricas de IGUAL longitud**, un formato de dato muy habitual es lo que conocemos como <mark>**matrices**</mark>: una **<mark>«tabla» de números**</mark>, con filas y columnas.

Vamos a empezar con una matriz sencilla: guardamos las estaturas y pesos de 5 personas.

```{r}
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
```

Hasta ahora, cada variable la hemos definido por separado, pero ahora vamos a **juntarlas**: vamos a crear nuestro **primer conjunto de datos** juntado todas ellas en una matriz, un conjunto de números organizado en **2 columnas (una por variable)** y **5 filas o registros (una por persona)**. Para ello usaremos la función `cbind()`, que nos <mark>**concatena vectores de igual longitud en formato columna**</mark>.


```{r}
datos_matriz <- cbind(estaturas, pesos) # Construimos la matriz por columnas
datos_matriz
```

Para practicar vamos a definir otro ejemplo con las **edades, teléfonos y códigos postales de una serie de individuos**.

```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73) # vector numérico de longitud 7
tlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)
cp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)

# Construimos la matriz por columnas
datos_matriz <- cbind(edades, tlf, cp) 
datos_matriz
```

Lo que tenemos es **una columna por variable y una fila por registro**. También podemos construir la **matriz por filas** con el comando `rbind()`, que nos permite añadir filas a una matriz o construirla desde cero (aunque lo habitual es tener cada variable en una columna).


```{r}
datos_matriz_filas <- rbind(edades, tlf, cp) # Construimos la matriz por filas
datos_matriz_filas

# Añadimos una fila
rbind(datos_matriz_filas, c(27, 620125780, 28051))
```

Como ves, ahora nuestros <mark>**datos están tabulados**</mark>, tienen dos dimensiones. ¿Cómo saber las **dimensiones** que tiene una matriz? Prueba a ejecutar la función `dim()`.

```{r}
dim(datos_matriz)
dim(datos_matriz_filas)
```

Fíjate que `dim()` devuelve un vector de 2 elementos, por lo que para acceder al número de filas deberemos ejecutar `dim(x)[1]` (y `dim(x)[2]` para el número de columnas). 

```{r}
dim(datos_matriz)[1]
dim(datos_matriz)[2]
```

También tenemos a nuestra disposición las funciones `nrow()` y `ncol()`, que nos devuelven directamente el número de filas y columnas.

```{r}
nrow(datos_matriz)
ncol(datos_matriz)
```

Bien, ya sabemos **definir una matriz a partir de variables sueltas**. Igual que a veces es útil generar un vector de elementos repetidos, también podemos definir una <mark>**matriz de números repetidos**</mark> (por ejemplo, de ceros), con la función `matrix()`, indicándole el número de filas y columnas.

```{r}
matrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0's
```

También podemos definir una **matriz a partir de un vector numérico**, reorganizando los valores en forma de matriz (con una dimensión tal que `filas * columnas = longitud del vector`), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba a abajo).

```{r}
z <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)
z
class(z) # Clase de la variable
```

&nbsp;

Dada una matriz también podemos darle vuelta (lo que se conoce como <mark>**matriz transpuesta**</mark>, donde filas pasan a ser columnas y viceversa) con la función `t()`.

```{r}
datos_matriz
t(datos_matriz) # Matriz transpuesta
```


Con las matrices sucede como con los vectores: cuando <mark>**aplicamos una operación aritmética**</mark>, se la estamos aplicando elemento a elemento, por ejemplo, dividir entre 5.

```{r}
datos_matriz / 5
```

## Apply vs bucles


Si eres un programador avezado te estarás preguntando: **¿no se usan apenas los bucles en `R`?** Existir existen, pero la razón por la que no usaremos apenas **bucles**, e intentaremos evitarlos lo máximo posible, es porque en `R` son **muy ineficientes** en tiempo de ejecución. Vamos a poner un ejemplo. Supongamos que queremos calcular la suma de cada fila (es decir, 7 valores). Con bucles sería así.

```{r}
# Creamos la matriz
estaturas <- c(150, 160, 170, 180, 190)
pesos <- c(60, 70, 80, 90, 100)
x <- cbind(estaturas, pesos)

# Bucle
suma <- rep(0, dim(x)[1]) 
for (i in 1:dim(x)[1]) { # Bucle recorriendo filas

  suma[i] <- sum(x[i, ], na.rm = TRUE) # Suma de la fila i
    
}
suma
``` 

En el código anterior puedes ver como para <mark>**acceder a la fila i-ésima de la matriz**</mark> se usa el operador `[i, ]` (dejando libre el índice de la columna), mientras que para **acceder a la columna j-ésima de la matriz** se usaría el operador `[, j]`. Para **acceder al elemento `(i, j)`** se usa el operador `[i, j]`. 


La pregunta es: **¿no hay una forma más eficiente de hacerlo?** La respuesta: sí. La **función `apply()` nos permite ejecutar una función por filas o por columnas**.

```{r}
# Suma por filas (MARGIN = 1)
suma_por_filas <- apply(x, MARGIN = 1, FUN = "sum")
suma_por_filas 

# Una función cualquiera por filas
operacion_por_filas <- apply(x, MARGIN = 1, FUN = function(x) { sum(sqrt(2) - 2) })
operacion_por_filas

# Suma por columnas (MARGIN = 2)
suma_por_cols <- apply(x, MARGIN = 2, FUN = "sum")
suma_por_cols
```

Como puedes observar, necesitas tres argmentos y otros opcionales: la matriz, el índice por el que operar (`MARGIN = 1` por filas, `MARGIN = 2` por columnas) y la función a aplicar, amén de otros argumentos extras que pudiera necesitar la función.

Veamos qué es más eficiente con el paquete `{microbenchmark}`, que nos permite **comparar el tiempo de dos conjuntos de órdenes**.

```{r}
library(microbenchmark)

# Comparamos tiempos de ejecución de ambas formas, y lo
# repetimos 100 veces para sacar tiempos medios
microbenchmark(
  # órdenes 1
  for (i in 1:dim(x)[1]) {
    
    suma_por_filas[i] <- sum(x[i, ]) 
    
  },
  # órdenes 2
  apply(x, MARGIN = 1, FUN = "sum"), times = 500) 
```

**¡El bucle nos tarda 40-80 veces más que el `apply`!**

&nbsp;


## Tablas: data.frames


Además del nombre de las columnas (heredado de los nombres de las variables con las que hemos construido las columnas), podemos poner **nombre a los registros**, por ejemplo, el nombre de las personas a las que pertenece cada dato, **definiendo una nueva variable con los nombres y concatenándola**.


```{r}
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
cbind(nombres, datos_matriz)
```

**¿Has visto lo que ha sucedido?**

Como <mark>**una matriz SOLO puede tener un tipo de dato**</mark>, al añadir una variable de tipo texto, ha convertido los números también a texto poniéndole comillas: **hemos roto la integridad de nuestro dato**. Una forma de añadir **nombre a los registros, sin incluirlo como variable**, es usando la función `row.names()`.

```{r}
row.names(datos_matriz) <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")
datos_matriz
```

&nbsp; 

**¿Qué sucede si realmente queremos añadir variables cuyos <mark>tipos sean distintos (¡ojo, pero con la misma longitud!)</mark>?**

Vamos a crear nuevas variables de texto `nombres` y `apellidos`, un valor lógico `casado`, valores numéricos `edades`, `cp` y `tlf`, y una fecha `fecha_creacion` (fecha de entrada en el sistema) para cada persona.

```{r}
# Nombres
nombres <- c("Sonia", "Carla", "Pepito", "Carlos", "Lara", "Sandra", "Javi")

# Apellidos
apellidos <- c(NA, "González", "Fernández", "Martínez", "Liébana", "García", "Ortiz")

# Código postal
cp <- c(28019, 28001, 34005, 18410, 33007, 34500, 28017)

# Edades
edades <- c(45, 67, NA, 31, 27, 19, 50)

# Estado civil (no lo sabemos de una persona)
casado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)

# Teléfono
tlf <- c(618910564, 914718475, 934567891, 620176565, NA, NA, 688921344)

# Fecha de creación (fecha en el que esa persona entra en el sistema)
# lo convertimos a tipo fecha
fecha_creacion <-
  as.Date(c("2021-03-04", "2020-10-12", "1990-04-05",
            "2019-09-10", "2017-03-21", "2020-07-07",
            "2000-01-28"))
```


Seguimos teniendo 7 registros, uno por persona pero ahora tenemos un popurrí de variables, de la <mark>**misma longitud pero de tipos distintos**</mark>: 

* `(edades, tlf, cp)` son variables **numéricas**.
* `(nombres, apellidos)` son variables de **texto**.
* `casado` es una variable **lógica**.
* `fecha_creacion` de tipo **fecha**.

**¿Qué sucedería si yo intento mezclar todo en una matriz?**


```{r}
# Juntamos todo en una matriz (juntamos por columnas)
x <- cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)
x
```

Efectivamente: como en una matriz solo puede haber datos de un tipo, los números los convierte a texto, las variables lógicas las convierte a texto (`TRUE` es un valor lógico, `"TRUE"` es un texto, como `"Pepito"`, sin significado lógico de verdadero/falso) y las fechas las ha convertido a texto (aunque las veas igual, ya no son de tipo de fecha, son texto y no podemos operar con ellas).

```{r error = TRUE}
# Días entre la primera y el segundo elemento de fecha de creación
fecha_creacion[1] - fecha_creacion[2]

# Días entre primera y segunda fecha de creación pero tomándolo de nuestra matriz (columna 7, fila 1 y 2)
x[1, 7] - x[2, 7]
```

&nbsp; 

He aquí LA PREGUNTA

<mark>**¿Cómo juntar variables de distinto tipo, sin cambiar su naturaleza, como cuando juntamos datos en una tabla de excel?**</mark>

El formato de tabla de datos en `R` que vamos a empezar a usar se llama <mark>**`data.frame`**</mark>: una colección de <mark>**variables de igual longitud pero cada una de un tipo distinto**</mark>. Para crear un objeto de este tipo basta con usar la función `data.frame()`, pasándole como argumentos (separados por comas) las variables que queremos reunir, indicando en texto el nombre de las columnas.

```{r}
# Creamos nuestro primer data.frame
tabla <- data.frame("Nombre" = nombres, "Apellido" = apellidos,
                    "Edad" = edades, "Teléfono" = tlf,
                    "Código Postal" = cp, "Casado" = casado,
                    "Fecha_de_creación" = fecha_creacion)
tabla
```

<mark>**¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!**</mark>

Puedes <mark>**visualizarlo**</mark> escribiendo su nombre en consola o con la función `View()`

```{r eval = FALSE}
View(tabla)
```


### Selección de columnas y filas

Si tenemos un `data.frame` ya creado y queremos <mark>**añadir una columna**</mark> es tan simple como usar la función  `data.frame()` que ya hemos visto para concatenar la columna. 

```{r}
# Añadimos una nueva columna con nº de hermanos/as
hermanos <- c(0, 0, 1, 5, 2, 3, 0)
tabla <- data.frame(tabla, hermanos)
tabla
```

Si queremos <mark>**acceder a una columna, fila o elemento en concreto**</mark>, los **`data.frame` tienen las mismas ventajas que una matriz**, así basta con usar los mismos operadores.

```{r}
# Accedemos a la tercera columna
tabla[, 3]

# Accedemos a la quinta fila
tabla[5, ]

# Accedemos a la tercera variable del quinto registro
tabla[5, 3]
``` 


Un `data.frame` **no solo tiene las ventajas de una matriz** si no que también tiene las <mark>**ventajas de una tabla de datos**</mark>. Por ejemplo, podemos **aceder a las variables** por el índice de columna que ocupan pero <mark>**también acceder a las columnas por su nombre**</mark>, poniendo el nombre de la tabla, el símbolo `$` y con el tabulador nos aparecerá un menú de columnas a elegir. 

```{r tabla-dolar, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Menú desplegable de variables (columnas) de un data.frame."}
knitr::include_graphics("./img/tabla_dolar.jpg")
```


Además del conjunto de datos `tabla` que ya tenemos, vamos a instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy útil en `R` llamado `{datasets}`. Los paquetes que vayamos necesitando los instalaremos y llamaremos al inicio del código principal.


```{r}
# Paquetes necesarios
# install.packages("datasets") # Descomentar si nunca se ha instalado
library(datasets)
```

Amén de nuestro conjunto de datos `tabla` en nuestro panel de entorno, si escribimos `datasets::` y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usados: el paquete `datasets` nos proporciona `data.frames` de prueba para que podamos usarlos en nuestros códigos según vamos aprendiendo.

Una de las **ventajas de los `data.frame`** es que podemos visualizarlos como si fuera una tabla de Excel dentro de nuestro `R` con la función `View()`. Vamos a visualizar no solo el conjunto de datos `tabla` sino también el conjunto `iris` del paquete `datasets`: los <mark>**`data.frame` nos permiten trabajar con ellos como bases de datos o como matrices**</mark>, con las ventajas de ambos.

```{r eval = FALSE}
View(iris)
View(tabla)
```

```{r view-datasets, echo = FALSE, out.width = "50%", fig.align = "center", fig.cap = "Menú desplegable con los data.frame de prueba en datasets"}
knitr::include_graphics("./img/view_datasets.jpg")
```

&nbsp;

En el caso de los `data.frame` tenemos además a nuestro disposición una <mark>**herramienta muy potente: la función `subset()`**</mark> Dicha función nos va a permitir <mark>**seleccionar filas y columnas a la vez**<mark>, tomando de entrada los siguientes argumentos

* `x`: una tabla de entrada, un `data.frame` de entrada.
* `subset`: la condición lógica que queramos usar para seleccionar registros (filas).
* `select`: un vector que contenga el nombre de las columnas que queremos seleccionar (a lo mejor solo queremos filtrar por filas pero quizás también por columnas).

Por ejemplo, vamos a **seleccionar solo los nombres y apellidos de aquellas personas mayores de edad** de nuestro conjunto de datos `tabla`, y del conjunto `iris` vamos a extraer todos los registros en los que el largo del sépalo es mayor que 7.1, seleccionando solo las columnas de longitud de sépalo y la especie de la planta.


```{r}
subset(tabla, subset = Edad > 18, select = c("Nombre", "Apellido"))
subset(iris, subset = Sepal.Length > 7.1, select = c("Sepal.Length", "Species"))
``` 


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Acceder a las funciones de los paquetes", "#20935E")`**

A veces puede que no queramos cargar todo un paquete sino solo una función del mismo, para lo que es suficiente `nombre_paquete::nombre_funcion`. Recuerda que instalar un paquete es cómo comprar un libro, cargar el paquete con `library()` es cómo traer el libro comprado de la estantería a tu mesa, y usar solo una función con `nombre_paquete::nombre_funcion` es cómo pedirle a alguien que te arranque solo una página y te la traiga a la mesa.

&nbsp;

**`r colorize("CONSEJO: nombre de variables", "#20935E")`**

La función `names()` no solo sirve para consultar los nombres de las variables de un `data.frame` sino también para cambiarlos a nuestro gusto.

```{r}
# Consultamos nombres
names(tabla)

# Cambiamos nombres
names(tabla) <- c("nombre_persona", "apellido_persona", "edad", "tlf",
                  "cp", "casado", "f_creacion")
tabla
```


## 📝 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary><strong>Ejercicio 1</strong>: define una matriz `x` de ceros de 3 filas y 7 columnas. Tras ello suma un 1 a cada número de la matriz y divide el resultado entre 5</summary>

- Solución:

```{r}
# Matriz
x <- matrix(0, nrow = 3, ncol = 7)
x

(x + 1) / 5
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: tras definir la matriz `x` calcula su transpuesta y obtén sus dimensiones</summary>

- Solución:

```{r}
# Transpuesta
t(x)

# Dimensiones transpuesta: pasa de ser 3x7 a 7x3
dim(t(x))
ncol(t(x)) # número de columnas de la transpuesta
nrow(t(x)) # número de filas de la transpuesta
```

</details>

&nbsp;

<details>
  <summary><strong>Ejercicio 3</strong>: calcula la suma de cada fila de la matriz `matrix(1:12, nrow = 4)` usando un bucle. Haz lo mismo evitando usar bucles.</summary>

- Solución:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

# Con bucle (recorremos sus filas)
suma <- rep(0, nrow(matriz)) # Definimos un vector de 0's con tantos elementos como filas, donde iremos metiendo los valores de la suma
for (i in 1:nrow(matriz)) {
  
  suma[i] <- sum(matriz[i, ]) # Sumamos la fila i
}
suma

# Sin bucle (MARGIN = 1 ya que es una operación por filas)
suma <- apply(matriz, MARGIN = 1, FUN = "sum")
suma
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 4</strong>: con la matriz `matrix(1:12, nrow = 4)` anterior, calcula la media de todos los elementos, la media de cada fila y la media de cada columna.</summary>

- Solución:

```{r}
# Matriz
matriz <- matrix(1:12, nrow = 4)

#  media de todos
mean(matriz)

# Media por filas (MARGIN = 1 ya que es una operación por filas)
apply(matriz, MARGIN = 1, FUN = "mean")

# Media por filas (MARGIN = 2 ya que es una operación por filas)
apply(matriz, MARGIN = 2, FUN = "mean")
```
</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 5</strong>: del data.frame `iris` (al que puedes acceder desde el paquete `{datasets}`), obtén el nombre de las variables.</summary>
  
- Solución:

```{r}
# Nombres de variables
names(iris)
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 6</strong>: del conjunto `iris` selecciona aquellas filas cuya variable `Petal.Width` sea distinta de 0.2.</summary>
  
- Solución:

```{r}
# Filtramos filas
filtro_fila <- subset(iris, subset = Petal.Width != 0.2)
filtro_fila
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 7</strong>: del conjunto `iris` quédate solo con las variables `Sepal.Length`, `Sepal.Width` y `Species`.</summary>
  
- Solución:

```{r}
# Filtramos columnas
filtro_col <- subset(iris,  select = c("Sepal.Length", "Sepal.Width", "Species"))
filtro_col
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 8</strong>: del conjunto `iris` selecciona a la vez aquellas filas cuya variable `Petal.Width` sea distinta de 0.2, y quédate solo con las variables `Sepal.Length`, `Sepal.Width` y `Species`.</summary>
  
- Solución:

```{r}
# Todo de una vez
filtro <- subset(iris, subset = Petal.Width != 0.2, select = c("Sepal.Length", "Sepal.Width", "Species"))
filtro
```

</details>


&nbsp; 

<details>
  <summary><strong>Ejercicio 9</strong>: calcula el número de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce a castellano el nombre de las columnas del `data.frame` filtrado.</summary>
  
- Solución:

```{r}
# Filas borradas
nrow(iris) - nrow(filtro)

# Cambiamos nombres a castellano del conjunto filtrado
names(filtro) <- c("longitud_sepalo", "anchura_sepalo", "especies")
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 10</strong>: del conjunto `iris`  accede a las columnas con nombres `"Sepal.Length"` y  `"Sepal.Width"`.</summary>
  
- Solución:

```{r}
# Accedemos por índice
iris[, 1:2]

# Accedemos por nombre
iris[, c("Sepal.Length", "Sepal.Width")]

# Accedemos a cada una individualmente
iris$Sepal.Length
iris$Sepal.Width
```

</details>


