```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Un pasito m√°s {-}

# Listas {#listas}

Hasta ahora hemos hecho un <mark>**resumen de los elementos b√°sicos**</mark> de `R`:

* <mark>**vectores**</mark>: colecci√≥n de elementos de <mark>**igual tipo**</mark>. Recuerda que un elemento individual, por ejemplo `x <- 1`, es en realidad un vector (de longitud 1). Pueden ser **n√∫meros**, **caracteres**, **fechas** o **valores l√≥gicos**, entre otros.

* <mark>**matrices**</mark>: colecci√≥n <mark> **BIDIMENSIONAL**</mark> de elementos de <mark>**igual tipo**</mark> e <mark>**igual longitud**</mark>.

* <mark>**data.frame**</mark>: colecci√≥n <mark> **BIDIMENSIONAL**</mark> de elementos de <mark>**igual longitud**</mark> pero <mark>**de cualquier tipo**</mark>, lo m√°s parecido a lo que conocemos como una tabla en Excel.


Adem√°s hemos visto una **serie de herramientas** para tratar esos datos:

* <mark>**estructuras condicionales**</mark> `if-else`
* <mark>**bucles**</mark> para repetir trozos de c√≥digo.
* <mark>**organizar el c√≥digo en proyectos**</mark> para facilitar nuestro trabajo
* <mark>**importar/exportar**</mark> datos


Con todos estos ingredientes estamos preparados/as para ver el que probablemente sea el tipo de dato m√°s importante en `R`: las <mark>**listas**</mark>.

Las <mark>**listas**</mark> son **colecciones** de variables de <mark>**diferente tipo pero que pueden ser tambi√©n de diferente longitud**</mark>, con estructuras totalmente heter√≥geneas, de ah√≠ que sea el formato de salida de much√≠simas funciones de `R` que te devuelven a la vez un cadena de texto, un vector de n√∫meros o una tabla, todo guardado en la misma variable (incluso **una lista puede tener dentro a su vez otra lista**).

Vamos a <mark>**crear nuestra primera lista**</mark> con tres elementos: el nombre de nuestros padres/madres, nuestro lugar de nacimiento y edades de nuestros hermanos.

```{r}
variable_1 <- c("Paloma", "Gregorio")
variable_2 <- "Madrid"
variable_3 <- c(25, 30, 26)

lista <- list("progenitores" = variable_1,
              "lugar_nacimiento" = variable_2,
              "edades_hermanos" = variable_3)
lista
length(lista)
```

Si observas el objeto que hemos definido como `lista`, la longitud del objeto es de 3: tenemos guardados tres elementos

* un vector de caracteres (de longitud 2)
* un caracter (vector de longitud 1)
* un vector de n√∫meros (de longitud 3)

Tenemos guardados elementos de distinto tipo (algo que ya pod√≠amos con los `data.frame` pero de longitudes dispares).

```{r}
dim(lista) # devolver√° NULL al no tener dos dimensiones
length(lista)
class(lista) # de tipo lista
```

Para <mark>**acceder a un elemento de la lista**</mark> tenemos dos opciones:

- **Acceder por √≠ndice**: con el operador `[[i]]` accedemos al elemento i-√©simo de la lista.

- **Acceder por nombre**: con el operador `$nombre_elemento` accedemos al elemento por su nombre

```{r}
# Accedemos por √≠ndice
lista[[1]]

# Accedemos por nombre
lista$progenitores
```

Dada su heterogeneidad y flexibilidad, para acceder a un elemento particular, las listas tienen una forma peculiar de acceder (con el corchete doble, en contraposici√≥n con el corchete simple que nos permite <mark>**acceder a varios elementos a la vez**</mark>)

```{r seleccionar-varios}
# Varios elementos
lista[1:2]
```

Las listas nos dan tanta flexibilidad que es el formato de dato natural para guardar datos que no est√°n estructurados, como pueden ser los datos almacenados en el registro de una persona

```{r}
# Fecha de nacimiento
fecha_nacimiento <- as.Date("1989-09-10")

# Notas de asignaturas en primer y segundo parcial
notas <- data.frame("biolog√≠a" = c(5, 7), "f√≠sica" = c(4, 5),
                    "matem√°ticas" = c(8, 9.5))
row.names(notas) <- # Nombre a las filas
  c("primer_parcial", "segundo_parcial")

# N√∫meros de tel√©fono
tlf <- c("914719567", "617920765", "716505013")

# Nombres
padres <- c("Juan", "Julia")

# Guardamos TODO en una lista (con nombres de cada elemento)
datos <- list("nacimiento" = fecha_nacimiento,
              "notas_insti" = notas, "tel√©fonos" = tlf,
              "nombre_padres" = padres)
datos
names(datos)
length(datos)
``` 

Hemos creado ahora una lista algo m√°s compleja de 4 elementos:

* `nacimiento`: una fecha.
* `notas_insti`: un `data.frame`.
* `tel√©fonos`: vector de n√∫meros.
* `nombre_padres`: vector de texto.

```{r}
datos[[1]]
datos$nacimiento

datos[[2]]
datos$notas_insti
```

Como hemos comentado, tambi√©n podemos **aplicar la recursividad** y hacer **listas con otras listas dentro**, de forma que para acceder a cada nivel deberemos usar el operador `[[]]`.

```{r}

lista_de_listas <- list("lista_1" = datos[3:4], "lista_2" = datos[1:2])
names(lista_de_listas) # Nombres de los elementos del primer nivel
names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista
lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior
```

Un ejemplo de la utilidad de las listas la tenemos en los archivos `R.Data` de vacunas que hemos cargado en nuestro script. Con `names(panel_vacunas)` podemos ver que elementos contiene en el primer nivel.

```{r include = FALSE}
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
```

```{r}
names(panel_vacunas)
```

Cada elemento de la lista es un `data.frame` de una comunidad auton√≥noma, que a su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): <mark>**¬°nos permite guardar ¬´datos n-imensionales¬ª!**</mark>.

```{r vacunas}
class(panel_vacunas$ES)
names(panel_vacunas$ES)
head(panel_vacunas$ES[, 1:5])
```

El acceso lo podemos realizar por orden que ocupa en la lista pero tambi√©n de forma intuitiva con `$` y el c√≥digo ISO de la comunidad aut√≥noma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, est√° guardada la informaci√≥n de cada variable (columna) y cada comunidad (fila).

```{r}
names(panel_vacunas_fecha)
names(panel_vacunas_fecha$`2021-04-23`)
head(panel_vacunas_fecha$`2021-04-23`[, 1:7])
```

&nbsp;

**`r colorize("WARNING: operaciones aritm√©ticas con listas", "#dc3545")`**

Una **lista no se puede vectorizar de forma inmediata**, por lo cualquier operaci√≥n aritm√©tica aplicada a una lista dar√° error (para ello est√° disponible la funci√≥n `lapply()`, cuyo uso corresponde a otros cursos m√°s avanzados).

```{r error = TRUE}
datos <- list("a" = 1:5, "b" = 10:20)
datos / 2
``` 

```{r lapply}
lapply(datos, FUN = function(x) { x / 2})
``` 

&nbsp;

## üìù Ejercicios

<details>
  <summary><strong>Ejercicio 1</strong>: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluir√© uno que sea un `data.frame` para que veas que en una lista cabe de todo).</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r ejercicio-1}
# Ejemplo: lista con texto, num√©rico, l√≥gico y un data.frame
lista_ejemplo <- list("nombre" = "Javier", "cp" = 28019,
                      "soltero" = TRUE,
                      "notas" = data.frame("mates" = c(7.5, 8, 9),
                                           "lengua" = c(10, 5, 6),
                                           "gimnasia" = c(4, 8, 6)))
lista_ejemplo

# Longitud
length(lista_ejemplo)

# Accedemos al elemento dos
lista_ejemplo[[2]]
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: accede a los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Accedemos al 1 y al 4
lista_ejemplo[c(1, 4)]
```

Otra opci√≥n es acceder con los nombres

```{r}
# Accedemos al 1 y al 4
lista_ejemplo$nombre
lista_ejemplo$notas

lista_ejemplo[c("nombre", "notas")]
```

</details>

&nbsp; 


<details>
  <summary><strong>Ejercicio 3</strong>: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato num√©rico) y si est√°s soltero/a.</summary>
  
  
<!-- toc -->
- Soluci√≥n:

```{r}
library(lubridate)
# Creamos lista: con lubridate calculamos la diferencia de a√±os desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "√Ålvarez Li√©bana",
                       "edad" = time_length(interval(ymd("1989-09-10"), ymd(Sys.Date())), unit = "years"),
                       "soltero" = TRUE)
lista_personal

# Otra opci√≥n: la edad calculada con floor (quita decimales y se queda con la parte entera)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "√Ålvarez Li√©bana",
                       "edad" = floor(time_length(interval(ymd("1989-09-10"), ymd(today())), unit = "years")),
                       "soltero" = TRUE)
lista_personal
```

</details>




