```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Conceptos básicos {-}

# Tipos de datos I: vectores {#vectores}


Bien, ya controlamos la calculadora. Vamos a ir más allá: ¿y si en lugar de tener un solo número tenemos una <mark>**colección de elementos**</mark>? En este capítulo vamos a ver un clásico de cualquier lenguaje de programación: los <mark>**vectores o arrays**</mark>, una <mark>**concatenación**</mark> de elementos (del mismo tipo). De hecho un número individual (por ejemplo, `1`) es en realidad un vector de longitud uno (un solo elemento).




## Vectores numéricos


La forma más sencilla de **crear un vector** en `R` es con el comando `c()` (de **concatenar elementos**), y basta con introducir sus elementos entre paréntesis, y separados por comas. Vamos a crear el vector con los tres primeros números naturales pares (el 0 no es natural, no seas bárbaro/a).

```{r}
z <- c(2, 4, 6)
z
```

Como ves ahora en el **environment (entorno, arriba a la derecha) tenemos una colección de elementos**, tres en concreto, guardados en una misma variable `z`. La longitud de un vector se puede calcular con el comando `length()` (nos devolverá el número de elementos de la variable que le pasemos como argumento).

```{r}
length(z)
```

Además podemos **concatenar a su vez vectores**: vamos a concatenar el vector `z` consigo mismo, y añadiéndole al final un 8.

```{r}
c(z, z, 8)
```

Esta última concatenación lo que nos ha dado son, primero, los tres pares que ya teníamos en `z`, después de nuevo los tres primeros pares, y por último un 8.


## Secuencias numéricas con un patrón

Muchas veces nos gustaría **crear vectores de una forma mucho más rápida**. Supongamos que queremos el vector de los primeros 21 números naturales. Si construyéramos el vector como antes, tendríamos que ejecutar el comando `c(1, 2, 3, 4, 5, ...)` hasta llegar al número 21. ¿Un poco largo, no?

Hay un atajo: el comando `seq()` nos permite crear una <mark>**secuencia desde un elemento inicial hasta un elemento final**</mark>, avanzando de uno en uno.

```{r}
seq(1, 21) # secuencia desde 1 hasta 21 de uno en uno
```

Es importante que no perdamos el foco de que <mark>**programar es similar a escribir en un idioma**</mark>, por lo que si hay algo que se puede decir de una forma más limpia y que se entienda mejor, ¿por qué no usarlo? Siempre que queramos definir secuencias entre dos números naturales (por ejemplo, entre `1` y un valor `n`), cuya distancia entre elementos consecutivos sea uno, el comando `1:n` nos devuelve lo mismo que la orden `seq(1, n)`. Además, si el elemento inicial es mayor que el final, `R` entenderá solo que la secuencia la queremo decreciente.

```{r}
n <- 21
1:n # secuencia desde 1 hasta n (21) de uno en uno
n:1 # secuencia decreciente
```


&nbsp;

También podemos definir **otro tipo de distancia entre dos elementos consecutivos** (conocido como **paso de discretización**), por ejemplo de 0.5 en 0.5.

```{r}
seq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5
```

Otras veces nos interesará definir una secuencia entre un valor inicial y un valor final, pero nos da igual la distancia entre cada elemento: solo nos importa que tenga un número concreto de elementos (y que sea `R` el que decida la distancia entre elementos consecutivos para conseguirlo).

```{r}
seq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11
```

&nbsp;

Otro atajo que podemos usar para definir secuencias de números con un patrón es definir <mark>**vectores de elementos repetidos**</mark>, por ejemplo un vector lleno de ceros. La función `rep()` nos permite repetir un elemento un número fijado de veces.

```{r}
rep(0, 7) # vector de 7 ceros
```

No solo podemos repetir un número sino que podemos repetir vectores enteros.

```{r}
rep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces
```

Esa repetición además podemos definirla también de forma **intercalada**: en lugar de repetir `c(0, 1, 2)` cuatro veces seguidas, queremos cuatro 0, después cuatro 1, y después cuatro 2.

```{r}
rep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2
```


## Vectores de caracteres (texto)

Un error común es asociar el concepto de vectores solo a números: un <mark>**vector es una colección o concatenación de elementos del mismo tipo**</mark> pero no tienen porque ser necesariamente números. Vamos a crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en `R` se llaman `char`): `"Mi"`, `"nombre"`, `"es"` `"Javier"`.

Como ves las variables de tipo `char` o `character` van entre comillas dobles, ya que es un <mark>**cadena de texto**</mark>.

```{r}
mi_nombre <- c("Mi", "nombre", "es", "Javier")
mi_nombre
```

Ya tenemos nuestro primer vector de texto de longitud 4. Las **cadenas de texto** son un tipo especial de dato, con los que obviamente no podremos hacer operaciones aritméticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la función `paste()`. Dicha función nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento `collapse =`.


```{r}
paste(mi_nombre, collapse = "") # todo junto
paste(mi_nombre, collapse = " ") # separados por un espacio
paste(mi_nombre, collapse = ".") # separados por un punto .
```

Si queremos pegar los elementos de la cadena de texto sin ningún tipo de caracter, existe una forma más abreviada y limpia de ejecutar la orden `paste(mi_nombre, collapse = "")`, usando la función `paste0()` 

```{r}
paste0(mi_nombre) # todo junto sin nada separando
```

Esta función es muy útil si queremos definir variables de texto que compartan por ejemplo un prefijo (`variable_1`, `variable_2`, ...)

```{r}
paste0("variable", 1:7) # a la palabra «variable» le pegamos los números del 1 al 7
paste("variable", 1:7, sep = "_") # separado por una barra baja
```

### Paquete glue

  
Otra **forma más intuitiva de trabajar con textos y variables numéricas** es usar el paquete `{glue}`, que nos permite pegar cadenas de texto a variables numéricas de **forma simbólica**.

```{r eval = FALSE}
install.packages("glue")
library(glue)
```

```{r eval = FALSE}
edad <- 10:15 # edades
glue("La edad es de {edad} años")
```

```{r echo = FALSE}
library(glue)
edad <- 10:15 # edades
unidades <- "años"
glue("La edad es de {edad} {unidades}")
```

También podemos hacer uso de dicha función sin tener los valores numéricos previamente guardados en variables.

```{r}
# Otra forma sin definir variables a priori
glue("La edad es de {10:15} años")
```

Ya sabemos trabajar con textos :) 

¿Y si queremos **pasar todo a mayúscula**? ¿O **todo a minúscula**? ¿Y si queremos **sustituir un caracter (por ejemplo `.`) por otro en todos los elementos**? `R` también nos proporciona algunas funciones muy sencillas (del paquete `{base}`) de usar para dichas tareas. Aquí un ejemplo de algunas de ellas.

```{r}
texto <- c("Hola.", "qué", "ase?", "todo", "bien.", "y yo",
           "que", "ME", "ALEGRO")
toupper(texto) # todo a mayúscula
tolower(texto) # todo a minúscula
```

El paquete `{base}` también nos permite buscar y reemplazar patrones concretos en cadenas de texta (por ejemplo, sustituir toda letra «o» por el caracter «*»).

```{r}
gsub("o", "*", texto) # toda "o" en el texto será sustituida por *
```

&nbsp;


## Vectores lógicos (TRUE/FALSE)

- [X] Variables numéricas (individuales)
- [X] Vectores de números
- [X] Vectores de caracteres
- [ ] Vectores lógicos

Veamos un último tipo de vectores importante en todo lenguaje de programación: los <mark>**vectores de valores lógicos**</mark>. Un **valor lógico** puede tomar tres valores:

* `TRUE` (guardado internamente como un `1`).
* `FALSE` (guardado internamente como un `0`).
* `NA` (dato ausente, son las siglas de _not available_, cuando pretendemos aplicar una comparación a un dato ya de por si ausente).

Estos valores son resultado de evaluar <mark>**condiciones lógicas**</mark>. Por ejemplo, imaginemos que definimos un vector de números `x <- c(1.5, -1, 2, 4, 3, -4)`. ¿Qué numeros del vector son menores que 2? Basta con que ejecutemos la orden `x < 2`, que nos devolverá `TRUE/FALSE` en cada hueco, en función de si cumple (`TRUE`) o no (`FALSE`) la condición pedida.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 2
```

El primer, segundo y sexto elemento del vector son los únicos elementos (estrictamente) menores que `2`, de ahí que en el primer, segundo y sexto elemento aparezca un `TRUE` y en el resto un `FALSE`. Es **importante** recordar que al **evaluar una condición lógica sobre un vector** de longitud `n`, la **salida sigue siendo un vector** de longitud `n` pero con valores lógicos.

Dicha condición lógica puede hacerse con otros operadores como `<=`, `>` o `>=`. 

```{r}
x <= 2
```

```{r}
x > 2
```

```{r}
x >= 2
```

&nbsp;

También podemos **comparar si es igual a otro elemento**, para lo que usaremos el operador `==`, pudiendo usar también su opuesto `!=` («distinto de»).

```{r}
x == 2
```

```{r}
x != 2
```

Las **condiciones pueden ser combinadas**, principalmente de dos maneras:

- **Intersección**: todas las condiciones concatenadas se deben cumplir (conjunción `y`, operador `&`) para devolver un `TRUE`.

- **Unión**: basta con que una de las condiciones concatenadas se cumpla (conjunción `o`, operador `|`) para devolver un `TRUE`.

Por ejemplo, vamos a calcular qué elementos del vector `c(1.5, -1, 2, 4, 3, -4)` sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3.

```{r}
x <- c(1.5, -1, 2, 4, 3, -4)
x < 3 & x > 0 # Solo los que cumplen ambas condiciones
x < 2 | x > 3 # Los cumplen al menos una de ellas
```


## Fechas


* `numeric`: variables de tipo numéricas (algunas veces vendrán indicados como `int` o integer para enteros, y `dbl` o `double` para números con decimales).
* `character`: variables de tipo caracter.
* `Date`: variables de tipo fecha.

&nbsp;

Hay un tipo muy especial de datos que aún no hemos visto que son los <mark>**datos tipo fecha**</mark>. Una fecha podría ser a priori una simple cadena de texto `"2021-04-21"` pero podemos usar la función `as.Date()` para que `R` entienda que esa cadena de texto representa un instante temporal. Fíjate la diferencia entre una fecha en texto y una fecha con `as.Date()`.

```{r error = TRUE}
fecha_char <- "2021-04-21"
fecha_date <- as.Date(fecha_char, format = "%Y-%m-%d")
fecha_char + 1
fecha_date + 1
```

En el momento en que convertimos la cadena de texto a fecha, aunque se visualice como tal, internamente es un número, por lo que podemos restar fechas (días entre ambas), **podemos sumar números a fechas (fecha días después)**, etc. Dentro del entorno `{tidyverse}`, el paquete `{lubridate}` tiene implementadas **múltiples funciones para poder operar con fechas de forma sencilla e intuitiva**.


```{r lubridate-package, echo = FALSE, fig.align = 'center',  include = identical(knitr:::pandoc_to(), 'html'), fig.link = 'https://lubridate.tidyverse.org/', out.width = '100%'}
knitr::include_graphics('img/lubridate.png')
```

Como ya hemos dicho, **las fechas y momentos temporales no serán meras cadenas de caracter sino que tienen clases especiales asociadas** y algunas funciones especiales que pueden sernos útiles: las fechas serán de tipo `dates` mientras que las horas será de tipo `POSIXct` o `POSIXlt`. En el primer caso, las fechas serán guardadas internamente como el **número de días transcurridos desde el 1 de enero de 1970**, y las horas como **número de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

**¿Cómo obtener automáticamente la fecha de hoy, por ejemplo?** La función `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para <mark>**convertir una cadena de texto a fecha**</mark>, basta usar la función `as.Date()` del paquete `{base}`, pasándole como argumento la fecha en formato `"yyyy-mm-dd"` por defecto.

```{r}
as.Date("2021-03-10") # formato por defecto
```

Si **introducimos otro tipo de formato**, debemos especificárselo en un segundo argumento, para `R` sepa el formato de fecha que le estamos pasando

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con día-mes-año (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con día-mes-año (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-día-año (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 


&nbsp;

**`r colorize("ERROR: sin pasar a fecha no se puede operar", "#dc3545")`**

Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día).

```{r error = TRUE}
"2021-03-10" - 1 # error
```

Fíjate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
fecha <- as.Date("2021-03-10") - 1 # día previo
fecha
``` 

Aunque aparentemente parezca una cadena de texto, prueba a ejecutar `unclass(fecha)` para comprobar que tiene internamente guardado.

```{r}
unclass(fecha)
unclass(as.Date("1969-01-01")) # un año antes de la referencia a partir de la cual cuenta días
``` 

&nbsp;


Dentro del entorno de paquetes de `{tidyverse}`, el paquete `{lubridate}` tiene bastantes funciones útiles para trabajar con fechas como las siguientes


```{r}
library(lubridate)
ymd_hms("2017-11-28T14:02:00") # convertir a fecha una cadena año-mes-día + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena año-día-mes + hora
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
mdy("July 4th, 2000") # convertir a fecha una cadena textual de fecha
ymd(20170131)
```

Además el paquete nos proporciona **herramientas para extraer la fecha y hora actuales** con las funciones `today()` y `now()`

```{r}
today()
now()
```


También tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el **día de la semana, el mes o el cuatrimestre**, con las funciones `year()`, `months()`, `day()` o `wday()` (día de la semana).


```{r}
fecha <- now()
year(fecha)
month(fecha)
day(fecha)
wday(fecha, week_start = 1) # Día de la semana (empezando por el lunes)
hour(fecha)
minute(fecha)
second(fecha)
week(fecha) # Número de semana (del año)
``` 

Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos **realizar comparaciones**, por ejemplo, si el día actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- now()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
``` 



&nbsp;

**`r colorize("ERROR: sumar números a caracteres sin convertir tipos de datos", "#dc3545")`**


A veces la lectura de variables numéricas de nuestros archivos puede hacer que un número, por ejemplo `1`, sea leído como la cadena de texto `"1"`, con la que no podemos operar como un número. Las funciones `as.numeric()`, `as.character()` y `as.logical()` nos permiten convertir una variable en tipo numérico, caracter o lógico, respectivamente.

```{r error = TRUE}
"1" + 1
as.numeric("1") + 1
as.character(1)
as.logical(c(0, 1))
```


## Consejos


**`r colorize("CONSEJOS", "#20935E")`**

&nbsp;

**`r colorize("Recuperar un comando y autocompletar", "#20935E")`**

Si haces click con el ratón en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el <mark>**historial de órdenes ejecutadas**</mark>. Es una manera de ahorrar tiempo para ejecutar órdenes similares a las ya ejecutadas. Si empiezas a escribir el nombre de una variable pero no te acuerdas exactamente de su nombre, pulsando **tabulador** te **autocompletará** solo.

&nbsp;

**`r colorize("Expresiones regulares", "#20935E")`**

Dentro del entorno de paquetes `{tidyverse}`, el paquete `{stringr}` permite un manejo más complejo de cadenas de texo (como el uso de expresiones regulares).

```{r stringr2, echo = FALSE, fig.cap = "Paquete stringr para manejar cadenas de texto más complejas"}
knitr::include_graphics("./img/stringr.png")
```

&nbsp;

```{r echo = FALSE}
paquetes <-
  data.frame("paquetes" = c("{base}", "{bookdown}", "{glue}", "{stringr}"),
             "descripción" = c("utilidades básicas",
                               "creación de libros, manuales e informes en R",
                               "manejo de texto literal",
                               "manejo complejo de cadenas de texto"))
kable(paquetes, col.names = c("paquetes", "descripción"), align = "ll",
      caption = "Paquetes mencionados hasta ahora")
``` 


## 📝 Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>📝<strong>Ejercicio 1</strong>: define un vector que contenga los números 1, 10, -1 y 2, y guárdalo en una variable llamada `vector_num`. </summary>
  
<!-- toc -->
- Solución:

```{r}
# Vector de números
vector_num <- c(1, 10, -1, 2)
vector_num
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>📝<strong>Ejercicio 2</strong>: crea un vector con las palabras "Hola", "me", "llamo" (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade "y tengo 30 años". </summary>
  
<!-- toc -->
- Solución:

```{r}
# Definiendo el vector
vector_char <- c("Hola", "me", "llamo", "Javier",
                 "Álvarez", "Liébana")

# Pegamos
paste(vector_char, collapse = " ")

# Añadimos frase
paste0(paste(vector_char, collapse = " "), " y tengo 30 años.")
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>📝<strong>Ejercicio 3</strong>: obten la fecha de hoy, define la fecha de tu cumpleaños, y calcula la diferencia de días</summary>
  
<!-- toc -->
- Solución:

```{r}
# Hoy
hoy <- Sys.Date()

# Cumple (diferentes formatos de entrada)
cumple <- as.Date("1989-09-10") # por defecto
cumple <- as.Date("10-09-1989", "%d-%m-%Y")

# Diferencia
hoy - cumple
```

<!-- tocstop -->
</details>


