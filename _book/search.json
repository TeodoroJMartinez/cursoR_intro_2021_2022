[{"path":"index.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"Este curso ha sido diseñado por Javier Álvarez Liébana y pensado para introducir en el lenguaje R todas aquellas personas que nunca hayan programado en él y/o en ningún otro lenguaje. Dicho manual ha sido elaborado su vez en R con {bookdown}. Puedes ver un resumen de las funcionalidades algunos paquetes documentados por el equipo de R Studio en sus esquemas resumen. El código de dicho manual se encuentra en GitHub (https://github.com/dadosdelaplace/cursoR_intro_2021_2022). Para elaborar informes o libros con una estructura similar, de forma nativa en R, el paquete bookdown puede ser instalado desde la plataforma CRAN o desde su versión en desarrollo actualizada en Github:","code":"\ninstall.packages(\"bookdown\")\n# o desde su versión en desarrollo actualizada\n# devtools::install_github(\"rstudio/bookdown\")"},{"path":"index.html","id":"propósito","chapter":"Prefacio","heading":"Propósito","text":"El objetivo de este tutorial es introducir la programación y análisis estadístico en R toda aquella persona que nunca se haya iniciado en él, sin necesitar conocimientos previos de programación (aunque siempre ayuda, obviamente). Con este manual se pretende que adquieras un vasto y experto conocimiento de R, pero si lo suficiente como para lograr 3 objetivos:tener miedo programar.Entender los conceptos básicos de R y dotarte de una autonomía muy básica para pdoer trabajar con datos.Algunos trucos sencillos para que el trabajo sea más rápido, tanto en tiempo de escritura como de ejecución.","code":""},{"path":"index.html","id":"requisitos","chapter":"Prefacio","heading":"Requisitos","text":"Conexión internet: se necesitará tener una conexión internet disponible para la descarga de algunos datos y paquetes.Conexión internet: se necesitará tener una conexión internet disponible para la descarga de algunos datos y paquetes.Instalar R (ver 1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R (ver 1). R será nuestro lenguaje, nuestro diccionario, nuestro castellano, nuestra ortografía para poder «comunicarnos» con el ordenador. https://cran.r-project.org/Instalar R Studio (ver 1.1). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Instalar R Studio (ver 1.1). De la misma manera que podemos escribir el mismo texto en castellano en una tablet, en un ordenador, en un Word, en un papel o en un tuit, en programación podemos usar distintos IDE (entornos de desarrollo integrados, nuestro Office), para que el trabajo sea más cómodo. Nosotros trabajaremos con RStudio.Todo lo necesario para seguir este curso es de descarga gratuita: viva el software libre, abajo Excel.","code":""},{"path":"index.html","id":"código-de-colores","chapter":"Prefacio","heading":"Código de colores","text":"En los recuadros rojos encontrarás errores comunes o prácticas que deberías hacer.En los recuadros naranjas encontrarás warnings o advertencias sobre cosas tener en cuenta para evitar problemas.Anular warningsAlgunas funciones pueden arrojarse ciertas advertencias que nunca está de más leer. Pero si dichos mensajes de alerta los tenemos controlados y queremos que nos ensucie la ejecución en la consola, podemos poner al inicio del código assign(\"last.warning\", NULL, envir = baseenv()) para limpiar los warnings antiguos y options(warn = -1) para desactivarlos.En los recuadros verdes encontrarás consejos o tips para ampliar y facilitar tu programación. Además en cada cajita de código, si pasas el ratón, encontrarás un botón 📄📄 en la esquina superior derecha de la caja para copiar el código directamente tu consola. Puedes encontrarlos todos escribiendo «consejo» en el buscador.En los recuadros azules encontrarás un 📚 glosario con algunos términos estadísticos y conceptos básicos.","code":""},{"path":"index.html","id":"sobre-el-autor","chapter":"Prefacio","heading":"Sobre el autor","text":"Esto de presentarse sí mismo es siempre un poco raro pero vamos intentarlo. Mi nombre es Javier Álvarez Liébana, soy matemático, nacido en 1989 en Carabanchel (Madrid), pasando por Bologna (Italia). Tras terminar licenciatura y Máster en Ingeniería Matemática, recibí en julio de 2018 el título de Doctor en Estadística (por la Universidad de Granada, con dos estancias en Université Pierre et Marie Curie)Además de investigador (con plaza y acreditación de Ayudante Doctor en la Facultad de Estudios Estadísticos de la Universidad Complutense de Madrid, tras ocupar dicha plaza en la Universidad de Oviedo), soy docente en dicha facultad y ando intentando eso de la divulgación en estadística y dataviz (visualización de datos) en redes sociales🎲 Web\n🐦 Twitter\n📸 Instagram","code":""},{"path":"index.html","id":"licencia","chapter":"Prefacio","heading":"Licencia","text":"Este documento es publicado bajo licencia pública general GNU,\nuna licencia libre de copyleft que garantiza los usuarios finales (personas, organizaciones, compañías) la libertad de usar, estudiar, compartir (copiar) y modificar el software, citando adecuadamente al autor del mismo.","code":""},{"path":"instalacionR.html","id":"instalacionR","chapter":"Capítulo 1 Instalación","heading":"Capítulo 1 Instalación","text":"Vamos necesitar solo 3 pasos (y conexión internet).Paso 1: entra en la web https://cran.r-project.org/ y en la pantalla de inicio selecciona la instalación acorde tu sistema operativo (ver imagen 1.1)\nImagen/gráfica 1.1: Pantalla inicial de la plataforma CRAN de R.\nPaso 2: para sistemas operativos Mac basta con que hacer click en el archivo .pkg, y abrirlo una vez descargado (ver imagen 1.2)\nImagen/gráfica 1.2: Pantalla de instalación de R en Mac OS.\nPara sistemas operativos Windows, debemos clickar en install R first time (ver imagen 1.3) y en la siguiente pantalla hacer click en Download R Windows (ver imagen 1.4). Una vez descargado, abrirlo como cualquier archivo.\nImagen/gráfica 1.3: Pantalla previa de instalación de R en Windows.\n\nImagen/gráfica 1.4: Pantalla final de instalación de R en Windows.\nPaso 3: tras su instalación tendrás en tu escritorio (Windows) o en tu Launchpad (Mac Os) un ejecutable de R para abrir. En Windows puede que tengas dos ejecutables i386 y x64 (como todo programa en Windows está la versión de 32 y de 64 bits, haz click preferiblemente - si lo tienes - en el de x64). Te saldrá algo parecido lo que observas en la imagen 1.5.\nImagen/gráfica 1.5: Primera pantalla al abrir el ejecutable de R.\nPara comprobar que está correctamente instalado, prueba escribir en la consola el siguiente código (recuerda: los códigos puedes copiarlos directamente de la cajita en la que está haciendo click en el botón de la esquina superior derecha)\nImagen/gráfica 1.6: Primera suma en la consola de R.\n¡Enhorabuena! Si te ha devuelto [1] 3, ya hecho más de lo que parece: definido dos variables y b, asignado un valor numérico cada variable y las hemos usado. Ya sabemos usar R como calculadora.Como habrás advertido, en R usaremos <- para asignar valores en lugar de =, como una flecha.Bonita esta interfaz es, así que la cerraremos y la abriremos más. Tenemos nuestro lenguaje instalado, vamos instalar nuestro Word para poder programar de forma cómoda.","code":"\na <- 1\nb <- 2\na + b## [1] 3"},{"path":"instalacionR.html","id":"instalacionRStudio","chapter":"Capítulo 1 Instalación","heading":"1.1 Instalación de RStudio","text":"Para instalar RStudio deberemos ir la web https://www.rstudio.com/products/rstudio/download/#download y seleccionar el ejecutable que te aperezca acorde tu sistema operativo (ver imagen 1.7). Tras descargar el ejecutable, hay que abrirlo como otro cualquier otro ejecutable y dejar que termine la instalación.\nImagen/gráfica 1.7: Descargar el ejecutable de RStudio para su posterior instalación.\nTras instalar tendremos en el escritorio o Launchpad un ejecutable de RStudio que abriremos. Se nos aparecerá una pantalla similar esta:\nImagen/gráfica 1.8: Primer recibimiento de nuestro mejor amigo RStudio.\nConsola: es el nombre para llamar esa ventana grande que te ocupa la mayor parte de tu pantalla. Prueba escribir el mismo código que antes en ella (es el equivalente la consola de R que hemos abierto al principio).\nImagen/gráfica 1.9: Lanzando consola nuestras primeras órdenes en RStudio.\nLa consola será donde ejecutaremos órdenes y mostraremos resultadosEnvironment (entorno): la pantalla pequeña (puedes ajustar los márgenes con el ratón tu gusto) que tenemos en la parte superior derecha se denomina environment o entorno de variables, donde como puedes ver, tras ejecutar el pequeño código en la consola, nos informa de que tenemos dos variables numéricas y su valor asignado. Nos mostrará las variables que tenemos definidas, el tipo y su valor.\nImagen/gráfica 1.10: Environment de variables.\nPanel multiusos: la ventana que tenemos en la parte inferior derecha servirá para buscar ayuda de comandos y órdenes, además de para visualizar gráficos. Lo veremos cuando sea necesario.\nImagen/gráfica 1.11: Panel multiusos.\nWTF ¿Y DÓNDE PROGRAMAMOS?¿Estás emocionado/? Vamos abrir nuestro primer script (script = documento en el que programamos, nuestro .doc, pero aquí será un archivo .R).Haz click en el menú superior en File << New File << R Script como se muestra en la imagen 1.12\nImagen/gráfica 1.12: Abriendo nuestro primer script de R.\nTras abrirlo tendremos una cuarta ventana: esta será la ventana de nuestros códigos, la ventana más importante ya que es donde escribiremos lo que queremos ejecutar. Escribe el código de arriba en ese script y guarda el archivo haciendo click en el botón Save current document\nImagen/gráfica 1.13: Escribiendo y guardando nuestro primer script.\nEse código se ejecuta salvo que se lo digamos. Tenemos dos opciones para ello: o copiamos el trozo de código que queramos y lo pegamos en la consola (como hemos hecho al principio), o activamos el cuadrado Source save la derecha del botón de guardar y volvemos hacer click en el botón de guardar: siempre que esa opción esté activada, al guardar solo es nos guarda el archivo .R sino que además se ejecuta solo y nos devuelve los resultados por consola.Listo, tienes instalado (casi) todo correctamente.","code":"\na <- 1\nb <- 2\na + b"},{"path":"instalacionR.html","id":"instalacionpaquetes","chapter":"Capítulo 1 Instalación","heading":"1.2 Instalación de paquetes","text":"El lenguaje R tiene 3 ventajas principales:Es un lenguaje creado por y para estadísticos/, por lo que está pensado para optimizar al máximo los recursos, y poder hacer un análisis estadístico de calidadEs un lenguaje creado por y para estadísticos/, por lo que está pensado para optimizar al máximo los recursos, y poder hacer un análisis estadístico de calidadEs software libre (como C, C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) en su instalación sino que permite acceder al código en el que están programados los comandos y permite hacer uso de trozos de código de otras personas.Es software libre (como C, C++, Python, Fortran, y otros tantos lenguajes). El software libre solo tiene una ventaja evidente (es gratis, ok) en su instalación sino que permite acceder al código en el que están programados los comandos y permite hacer uso de trozos de código de otras personas.Es un lenguaje modular: en la instalación se instalan todas las funcionalidades sino que instala un mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante, con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código validados por la comunidad y la plataforma, de forma gratuita!Es un lenguaje modular: en la instalación se instalan todas las funcionalidades sino que instala un mínimo para poder funcionar, de forma que se ahorra espacio en disco y en memoria. Al ser software libre, existen trozos de código hechos por otras personas llamados paquetes, que podemos ir instalando nuestro gusto según los vayamos necesitando. Esto es una ventaja enorme ya que R tiene una comunidad de usuarios gigante, con más de 17 000 paquetes: ¡hay más de 17 000 trozos de código validados por la comunidad y la plataforma, de forma gratuita!\nImagen/gráfica 1.14: Paquetes disponibles en R.\nEsto nos ahorra muchísimo tiempo ya el 90% de lo que querramos hacer ya lo habrá querido hacer otra persona y podemos usar o adaptar su código para empezar de cero. Vamos instalar un paquete gráfico (ggplot2) que necesitaremos. Para ello, escribe en tu consola el siguiente código y pulsa enter.Dicha orden (puede tardar un poco la primera vez, depende de tu conexión internet) lo que hará será acceder la web de R, bajarse tu ordenador los trozos de código incluidos en el paquete llamado ggplot2, y dejarlos para siempre en él.La instalación de paquetes SOLO ES NECESARIO la primera vez que se usa dicho paquete en la vida del ordenador, hace falta hacerlo cada vez que lo usas.Una vez que tenemos los trozos de código (el paquete) en nuestro ordenador, en cada sesión de R que abramos (cada vez que cierres y abras RStudio) deberemos (si queremos) llamar ese paquete que tenemos instalado, escribiendo el siguiente comando en consolaWelcome software librePaquete: trozos de código realizadas por otros usuarios de la comunidad (y validades por el equipo de CRAN si la descarga es mediante install.packages()) para ser usados. Una vez instalados (descargados) los trozos de código nuestro ordenador, basta con «acudir» ellos con library().Haciendo una metáfora con la colección de libros que tengas en casa: con la instalación hemos comprado el libro y lo tenemos en nuestra estantería (para siempre), con la llamada al paquete, por ejemplo library(ggplot2), lo que hacemos es decidir, de entre todos los libros de la estantería, cuales queremos llevarnos de viaje (en cada maleta que hagamos).Los paquetes usados los verás denotados como {nombre_paquete} lo largo del manual.CONSEJO¿Cómo saber cuando la orden lanzada en consola ha terminado?veces R y RStudio son tan silenciosos que sabemos si ha acabado la orden que acabamos de lanzar en la consola o . Siempre que veas el símbolo > como última línea en la consola significa que está listo para que le escribamos otra orden (es la forma cariñosa de decirte que ya ha acabado, ver imagen 1.15)\nImagen/gráfica 1.15: Ejemplo de que la orden lanzada ha acabado.\nCONSEJO¿Cómo prevenir la fatiga visual programando?Estar delante de una pantalla de ordenador, con la vista muy fija mientras se programa, puede que acabes teniendo cierta fatiga visual en el trabajo. Te aconsejo que cambies en tu RStudio la tonalidad del fondo de tu programa, en tonos oscuros y blancos (¿te fijado que mis capturas tienen un azul cobalto oscuro de fondo mientras el tuyo es un blanco nuclear? Echa un vistazo las imágenes 1.16 y 1.17)\nImagen/gráfica 1.16: Menú de opciones de nuestro editor\n\nImagen/gráfica 1.17: Personalizar el color de fondo de nuestro editor, la letra y el tamaño de fuente\n","code":"\ninstall.packages(\"ggplot2\")\nlibrary(ggplot2)"},{"path":"primeros-pasos.html","id":"primeros-pasos","chapter":"Capítulo 2 Primeros pasos","heading":"Capítulo 2 Primeros pasos","text":"¿Empezamos?Veamos antes un poco de historia sobre nuestro deidad.Allá por 1975, los laboratorios Bell (los que inventaron la radio moderna tal y como la conocemos), necesitaban una alternativa los lenguajes más «rudos» y antiguos como C++ o Fortran, lenguajes rápidos en la ejecución pero complejos en su uso, con una gran curva de aprendizaje y con muy poca capacidad en la visualización de datos que se empezaba necesitar.Así que en 1976 sacaron la primera versión del lenguaje conocido S (hasta entonces estaba de moda lo de llamar los lenguajes con una sola inicial). En 1980 se empezó distribuir la primera versión pública de S, más allá de los laboratorios Bell, y en 1988 se añadieron bastantes funcionalidades nuevas como poder aplicar funciones otras funciones (los famosos apply() que ya veremos). Años más tarde, en 1991, dicho lenguaje se simplificó, reescribiendo muchas subrutinas de otros lenguajes más primitivos, para tener una versión muy parecida al actual R, permitiendo el usod de operadores, data.frames (que veremos) y otro tipo de objetos, sencillos en la programación pero muy versatiles.Sin embargo, salvo uso docente, S tenía licencia así que en 1992 Ross Ihaka y Robert Gentleman se lanzaron crear una versión de S libre y gratuita, un trabajo de casi 8 años hasta que en el año 2000, ambos investigadores de la Universidad de Auckland en Nueva Zelanda lanzaron la primera versión estable del lenguaje.Tras dicho lanzamiento, se creó un equipo de expertos en estadística computacional (el conocido como R Development Core Team) que es el que se encarga de mantener toda la aerquitectura de R y los que se encargar de actualizar y mejorar el paquete {base}, una librería motor sobre la que se construye el resto de funciones.","code":""},{"path":"primeros-pasos.html","id":"excel-no-es-tu-amigo","chapter":"Capítulo 2 Primeros pasos","heading":"2.1 Excel no es tu amigo","text":"R es un lenguaje de programación, de alto nivel para el usuario y modular. Los lenguajes de alto nivel como R, Python (curso interactivo de Python en https://checkio.org/) o Matlab, facilitan la programación al usuario, teniendo que preocuparte solo de la tarea de programar. Son lenguajes con una menor curva de aprendizaje aunque suelen ser más lentos en su ejecución en comparación con lenguajes de bajo nivel (C, C++ o Fortran), lenguajes muy rápidos en su ejecución pero cuya programación requiere un mayor tiempo y formación, teniendo que además estar pendiente del tipo de variables, espacio en memoria, etc.Por su arquitectura, R es un lenguaje que puede ser usado para un propósito general pero que está especialmente diseñado para el análisis estadístico de datos. Su modularidad nos da la ventaja de que podemos instalar las funcionalidades que vayamos necesitando de forma progresiva.¿Por qué es recomendable usar Excel?Software de pago: Excel, al igual que el resto de programas de Microsoft o SPSS (por desgracia programa estrella de nuestro sistema sanitario), es un programa de pago. nivel individual, todos hemos tenido una versión que hemos pagado, pero dicha evasión se la puede permitir una empresa o administración, que debe de pagar altas cantidades de dinero anuales por las licencias, dinero que sería necesario si los investigadores y trabajadores tuvieran formación (remunerada) en otras herramientas de software libre.Software cerrado: solo es de pago sino que es cerrado, así que solo podemos hacer lo que Excel ha creído que interesante que podamos hacer. Incluso con la programación de MACROS, las funcionalidades de Excel siguen siendo mucho más limitadas ya que viene «programadas» de antemanoAlto consumo de memoria: dicha programación predeterminada hace que Excel ocupe muchísimo espacio en el disco duro y tenga un alto consumo de memoria (la memoria es lo que te permite hacer varias tareas la vez en tu ordenador).es universal: solo es de pago sino que además, dependiendo de la versión que tengas de Excel, tendrá un formato distinto para datos como fechas, teniendo incluso extensiones distintas, de forma que un archivo .xls abierto por un Excel moderno puede provocar errores en la carga.¡ES SOLO UNA HOJA DE CÁLCULO!: el propio Microsoft desaconseja el uso de Excel para el análisis de grandes volúmenes de datos. El Excel es una herramienta maravillosa para ser usada como una sencilla hoja de cálculo: llevar las cuentas de tu familia, de tu pequeño negocio, una declaración de la Renta sencilla, planificar viajes, etc. Pero el programa ESTÁ DISEÑADO para ser una base de datos ni para análisis detallado, y muchos menos pensado para generar un entorno flexible para el análisis estadístico y la visualización de datos. ¿Puedes ser el mejor partiendo un filete con una cuchara? Seguramente puedas (en Excel puedes hasta programar con macros), y si siempre lo hiciste así, acabarás normalizándolo, pero seguirás siendo una persona comiendo filete con cuchara.¿Qué sucede si usamos la herramienta equivocada? Tres ejemplos:Problemas para codificar fechas: en 2016 se publicó una revisión de artículos en genética, descubriendo que 1 de cada 5 artículos contenían errores debido una mala codificación de las fechas, conviertiendo por ejemplo los genes Septin-2 (conocido como SEPT2) en fechas, y al revés (Ziemann, Eren, El-Osta 2016).\nImagen/gráfica 2.1: Excel en una noche loca.\nProblemas de memoria: un Excel permite por defecto una cantidad máxima de filas. Aunque dicha cantidad se puede ampliar, sigue siendo finita, por lo que cuando superas el umbral de filas, al añadir filas Excel te borra registros sin avisarte de que lo está haciendo. Esto es lo que sucedió con los registros de casos covid en Reino Unido.\nImagen/gráfica 2.2: Cuando Excel dice basta.\nProblemas para codificar edades: una variable de tipo fecha, aunque nosotros la veamos con letras, en realidad es una variable numérica que representa los días que han pasado desde una fecha origen. En función de las distintas versiones de Excel, dicha fecha origen cambia. Además, si se codifica mal la fecha en formato dd-mm-YY, dicho formato cuando se exporta otro excel en texto, permite distinguir un nacido en 1918 y un nacido en 2018, así que podemos estar confundiendo personas de 103 años con niños de 3 años (y es lo que sucedió en España, observando unas tasas de mortalidad en niños muy pequeños equivalentes personas mayores).\nImagen/gráfica 2.3: Los centenarios con biberón.\n","code":""},{"path":"primeros-pasos.html","id":"primeros-pasos-calculadora","chapter":"Capítulo 2 Primeros pasos","heading":"2.2 Primeros pasos: calculadora","text":"¿Te acuerdas de lo que era la consola? Vamos trabajar de momento en esa ventana que tienes en la ventana inferior.\nImagen/gráfica 2.4: Lanzando consola nuestras primeras órdenes en RStudio.\nLo que ya hemos descubierto en los pasos de la instalación (ver imagen 2.4) es que la consola de R tiene una función muy básica y evidente: nos sirve de calculadora. Un ejemplo muy simple: si escribimos 3 en la consola y pulsamos ENTER, la consola nos mostrará el resultado de la suma ¿Pero cuál es la diferencia entre una calculadora y un lenguaje de programación?Imagina que dicha suma 3 la quisiéramos utilizar para un segundo cálculo: ¿y si en lugar de lanzarlo la consola sin más lo almacenamos en alguna variable?Como hemos visto en la instalación de RStudio, para asignar variables lo haremos con la orden x <- 1 + 2: una variable de nombre x va tener asignada <- lo que valga la suma 1 + 2Como puedes comprobar, en tu parte superior derecha (nuestro entorno de variables), podrás ver como una nueva variable x es ahora visualizada, con su valor asignado (se mostrará en consola salvo que escribas 3 en ella: R asume que querías visualizarla en consola sino solo guardarla).\nImagen/gráfica 2.5: Environment.\nDicha variable x además podemos reciclarla para definir una variable y, restándole una constante. De la misma manera que hemos hecho restas, sumas y multiplicaciones, R tiene todas las operaciones clásicas que podrías tener en una calculadora. Prueba ejecutar en la consola las órdenes x^2, sqrt(x) o abs(y): R calculará las operaciones elevar al cuadrado, raíz cuadrada y valor absoluto de la variable que tengan entre paréntesis ","code":"\n1 + 2## [1] 3\nx <- 1 + 2\nx^2## [1] 9\nsqrt(x)## [1] 1.732051\ny <- x - 5\nabs(y)## [1] 2"},{"path":"primeros-pasos.html","id":"tipos_errores","chapter":"Capítulo 2 Primeros pasos","heading":"2.3 Tipos de errores","text":"Durante tu aprendizaje en R va ser muy habitual que las cosas salgan la primera, apareciendo en consola mensajes en un color rojo. Un miedo muy habitual cuando se empieza programar es pensar que si haces algo mal o aparece algún mensaje de error, el ordenador puede explotar en cualquier momento. programar se aprende programando, así que haz las pruebas que quieres, lo peor que puede pasar es que necesites cerrar sesión en R Studio y abrirlo de nuevo.Dado que el 99.99999% de veces tu código tendrá errores que deberás ir solventando, está de más conocer los tipos de mensajes que R puede sacarte por consola:Los mensajes de error irán precedidos de la frase «Error …», dándote veces incluso el tipo de error y la línea de código en la que se ha producido. Veamos un ejemplo intentando sumar un número una cadena de texto.Los errores son aquellos fallos que seguramente impidan la ejecución del código. Un error muy habitual es intentar acceder alguna función de algún paquete que, o bien tenemos instalado, o bien hemos llamado haciendo uso del library(): estás intentando leerte un libro de tu biblioteca pero ni siquiera ido la tienda «comprarlo».Los mensajes de warnings irán precedidos de la frase «Warning …», y son los fallos más delicados ya que son posibles errores o incoherencias que R detecta en tu código pero que van hacer que tu código deje de ejecutarse, aunque probablemente lo haga como ti te gustaría. Un ejemplo es cuando tratamos de hacer la raiz cuadrada de un número negativo.¿Ha ejecutado la orden? Sí, pero te **advierte de que el resultado de la operación es un NaN, un valor que existe (al menos dentro de los números reales), un Number (ver Sección 3.7).Los mensajes de control serán aquellos que aparecerán por consola sin empezar por «Error …» ni «Warning:…». Dichos mensajes, que puedes incluir tú mismo en tu código con funciones como cat() para monitorizar la ejecución de códigos largos, son errores ni problemas, son simplemente información que R considera útil aportarte.CONSEJO: panel de ayudaSi escribes en la consola ? nombre_funcion (por ejemplo, escribe en la consola ? sqrt), en el panel inferior derecho te aparecerá una documentación de ayuda de la función para saber que argumentos necesita, como puedes usar la función, qué es lo que te devuelve, ejemplos de uso, etc.\nImagen/gráfica 2.6: Panel de ayuda.\n","code":"\n\"a\" + 1## Error in \"a\" + 1: argumento no-numérico para operador binario\nsqrt(-1)## Warning in sqrt(-1): Se han producido NaNs## [1] NaN\n? sqrt"},{"path":"primeros-pasos.html","id":"ejercicios","chapter":"Capítulo 2 Primeros pasos","heading":"2.4 📝 Ejercicios","text":"📝Ejercicio 1: calcula en consola la suma de 3 más 4, y todo ello multiplicado por 10, y asígnalo una variable x (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 2: asigna un valor positivo x y calcula su raíz cuadrada; asigna otro negativo y calcula su valor absoluto (haz click en la flecha para la solución propuesta).Solución:Las órdenes sqrt(x) y abs(y) se llaman funciones, y la variable que tienen entre paréntesis se llama argumento de la función: una variable que toma de entrada la función y con la que opera internamente. 📝Ejercicio 3: usando la variable x ya definida, calcula x - 5 y guárdalo en una nueva variable z (haz click en la flecha para la solución propuesta).Solución: 📝Ejercicio 4: usando las variables x y z ya definidas, calcula la raíz cuadrada del máximo entre ambas, y guárdalo en una nueva variable t (haz click en la flecha para la solución propuesta).Solución:CUIDADONo hace falta gastar una línea por cada orden que quieras ejecutar. Tampoco necesitas guardar cada paso intermedio que realices. Cuidado con la memoria: cada asignación que hagas es una variable guardada que consume recursos en tu ordenador.","code":"\nx <- (3 + 4) * 10\n# Raíz cuadrada\nx <- 73\nsqrt(x)## [1] 8.544004\n# Valor absoluto\ny <- -73\nabs(y)## [1] 73\nz <- x - 5\nz## [1] 68\nt <- sqrt(max(x, z)) \nt## [1] 8.544004"},{"path":"tipos-de-datos-i-vectores.html","id":"tipos-de-datos-i-vectores","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"Capítulo 3 Tipos de datos I: vectores","text":"CONSEJO: recuperar un comando y autocompletarSi haces click con el ratón en la consola y pulsas la flecha «arriba» del teclado, te irá apareciendo todo el historial de órdenes ejecutadas. Es una manera de ahorrar tiempo para ejecutar órdenes similares. Si empiezas escribir el nombre de una variable pero te acuerdas exactamente de su nombre, si pulsas tabulador, R te autocompletará solo (prueba escribir solo variab y pulsa tabulador)Bien, ya controlamos la calculadora. Vamos ir más allá: ¿y si en lugar de tener un solo número tenemos un CONJUNTO de elementos? En este capítulo vamos ver un clásico de cualquier lenguaje de programación: los vectores o arrays.","code":""},{"path":"tipos-de-datos-i-vectores.html","id":"vectores-numéricos","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.1 Vectores numéricos","text":"Un conjunto de elementos del mismo tipo se llama vector (en este caso de números), y de hecho un número individual (por ejemplo, 1) es en realidad un vector de longitud uno (un solo elemento).La forma más sencilla de crear un vector en R es con el comando c() (de concatenar elementos), y basta con introducir sus elementos entre paréntesis, y separados por comas. Vamos crear el vector con los tres primeros números naturales pares (el 0 es natural, seas bárbaro/).Como ves ahora en el environment tenemos una colección de elementos, tres en concreto, guardados en una misma variable z. La longitud de un vector se puede calcular con el comando length() (nos devolverá el número de elementos de la variable que le pasemos como argumento).Además podemos concatenar su vez vectores: vamos concatenar el vector z consigo mismo, y añadiéndole al final un 8.Esta última concatenación lo que nos ha dado son, primero, los tres pares que ya teníamos en z, después de nuevo los tres primeros pares, y por último un 8.","code":"\nz <- c(2, 4, 6)\nz## [1] 2 4 6\nlength(z)## [1] 3\nc(z, z, 8)## [1] 2 4 6 2 4 6 8"},{"path":"tipos-de-datos-i-vectores.html","id":"secuencias-con-un-patrón","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.2 Secuencias con un patrón","text":"Muchas veces nos gustaría crear vectores de una forma mucho más rápida. Supongamos que queremos el vector de los primeros 21 números naturales. Si construyéramos el vector como antes, tendríamos que ejecutar el comando c(1, 2, 3, 4, 5, ...) hasta llegar al número 21. ¿Un poco largo, ?Hay un atajo: el comando seq() nos permite crear una secuencia desde un elemento inicial hasta un elemento final, avanzando de uno en uno.Es importante que perdamos el foco de que programar es similar escribir en un idioma, por lo que si hay algo que se puede decir de una forma más limpia y que se entienda mejor, ¿por qué usarlo? Siempre que queramos definir secuencias entre dos números naturales (por ejemplo, entre 1 y un valor n), cuya distancia entre elementos consecutivos sea uno, el comando 1:n nos devuelve lo mismo que la orden seq(1, n). Además, si el elemento inicial es mayor que el final, R entenderá solo que la secuencia la queremo decreciente. También podemos definir otro tipo de distancia entre dos elementos consecutivos (conocido como paso de discretización), por ejemplo de 0.5 en 0.5.Otras veces nos interesará definir una secuencia entre un valor inicial y un valor final, pero nos da igual la distancia entre cada elemento: solo nos importa que tenga un número concreto de elementos (y que sea R el que decida la distancia entre elementos consecutivos para conseguirlo). Otro atajo que podemos usar para definir secuencias de números con un patrón es definir vectores repetidos, por ejemplo un vector lleno de ceros. La función rep() nos permite repetir un elemento un número fijado de veces.solo podemos repetir un número sino que podemos repetir vectores enteros.Esa repetición además podemos definirla también de forma intercalada: en lugar de repetir c(0, 1, 2) cuatro veces seguidas, queremos cuatro 0, después cuatro 1, y después cuatro 2.","code":"\nseq(1, 21) # secuencia desde 1 hasta 21 de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn <- 21\n1:n # secuencia desde 1 hasta n (21) de uno en uno##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21\nn:1 # secuencia decreciente##  [1] 21 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\nseq(1, 10, by = 0.5) # secuencia desde 1 a 10 de 0.5 en 0.5##  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5  8.0\n## [16]  8.5  9.0  9.5 10.0\nseq(1, 50, l = 11) # secuencia desde 1 a 50 de longitud 11##  [1]  1.0  5.9 10.8 15.7 20.6 25.5 30.4 35.3 40.2 45.1 50.0\nrep(0, 7) # vector de 7 ceros## [1] 0 0 0 0 0 0 0\nrep(c(0, 1, 2), 4) # repetimos el vector c(0, 1, 2) 4 veces##  [1] 0 1 2 0 1 2 0 1 2 0 1 2\nrep(c(0, 1, 2), each = 4) # cuatro 0, luego cuatro 1, luego cuatro 2##  [1] 0 0 0 0 1 1 1 1 2 2 2 2"},{"path":"tipos-de-datos-i-vectores.html","id":"operaciones-aritméticas-con-vectores-numéricos","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.3 Operaciones aritméticas con vectores numéricos","text":"Hemos dicho que un número es un vector de longitud 1, así que toda operación aritmética que podamos hacer con un número la vamos poder hacer con un vector de números, de forma que si hacemos por ejemplo la operación 2 * z, lo que sucederá es que CADA ELEMENTO del vector será multiplicado por 2. De la misma manera se pueden definir sumas z + x, raíces cuadradas sqrt(z) o elevar cada elemento al cuadrado z^2.CONSEJOEsto último, aunque parezca banal, es bastante importante que se te olvide ya que en otros lenguajes siempre es así. En R, salvo que especifiquemos lo contrario, toda operación ARITMÉTICA que hagas un vector será elemento elemento: si multiplicas dos matrices, la operación la realizará elemento elemento, como la multiplicación matricial que quizás te enseñaran en matemáticas (upon time…)Dado que la operación (por ejemplo, una suma) se realiza elemento elemento, ¿qué sucederá si sumamos dos vectores de distinta longitud? Prueba definir un vector con los 4 primeros impares, e intentar hacer la suma z + y (un vector de longitud 3 más un vector de longitud 4).R intenta molestarte lo menos posible, así que lo que hace es reciclar: si tiene un vector de 4 elementos y le intentas sumar uno de 3 elementos, lo que hará será reciclar elementos del vector con menor longitud: hará 1+2, 3+4, 5+6 pero… 7+2 (vuelve al primero).CONSEJO: diferencia de conjuntosUna función muy útil para ver las diferencias entre dos conjuntos es setdiff(), una función que nos devuelve los elementos distintos entre dos conjuntos.","code":"\n# Multiplicamos por 2 a CADA ELEMENTO del vector\nz <- c(2, 4, 6)\n2 * z## [1]  4  8 12\n# Sumamos 3 a CADA ELEMENTO DEL VECTOR\nz + 3## [1] 5 7 9\n# Hacemos la raíz cuadrada de CADA ELEMENTO DEL VECTOR\nsqrt(z)## [1] 1.414214 2.000000 2.449490\n# Elevamos al cuadrado CADA ELEMENTO DEL VECTOR\nz^2## [1]  4 16 36\ny <- c(1, 3, 5, 7)\nz + y## [1]  3  7 11  9\ny <- 1:10\nz <- c(1, 3, 7, 10)\nsetdiff(y, z) # Elementos en y que no están en z ## [1] 2 4 5 6 8 9"},{"path":"tipos-de-datos-i-vectores.html","id":"operaciones-estadísticas-con-vectores-numéricos","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.4 Operaciones estadísticas con vectores numéricos","text":"Al igual que podemos ejecutar operaciones aritméticas, podemos realizar también operaciones estadísticas con los vectores, como calcular su suma (sum()), su media (mean()), su mediana (median()), su suma acumulada (cumsum() cada elemento lo acumula al anterior) o percentiles (quantiles()).CONSEJOComo podido comprobar, este otro tipo de operaciones ESTADÍSTICAS se realizan elemento elemento: la media o la suma las realiza tomando todos los elementos del vector.Media: medida de centralización que consiste en sumar todos los elementos y dividirlos entre la cantidad de elementos sumados. pesar de ser la más conocida, la media es muy poco robusta: dado un conjunto, si se introducen valores atípicos o outliers (valores muy grandes o muy pequeños), la media se perturbar con mucha facilidad. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(\\overline{x}\\).\\[\\overline{x} = \\frac{\\displaystyle \\sum_{=1}^{n}x_i}{n}\\]Mediana: medida de centralización que consiste en, tras ordenar los datos de menor mayor, quedarnos con el valor que ocupa el medio (deja tantos números por debajo como por encima). Más robusta que la media aunque menos la moda. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Me_x\\).\\[Me_x = \\displaystyle \\arg \\min_{x_i} \\left\\lbrace F_i > 0.5 \\right\\rbrace, \\quad F_i = \\frac{\\#\\left\\lbrace x_j \\leq x_i \\right\\rbrace}{n}\\]Moda: medida de centralización que consiste en encontrar el valor más repetido (el valor trending). Es la medida de centralización más robusta. Dado un vector de valores \\(x = (x_1, \\ldots, x_n)\\), se denota como \\(Mo_x\\).\\[Mo_x = \\displaystyle \\arg \\max_{x_i} f_i  , \\quad f_i = \\frac{\\#\\left\\lbrace x_j = x_i \\right\\rbrace}{n}\\]","code":"\nsum(y) # suma## [1] 55\nmean(y) # media## [1] 5.5\nmedian(y) # mediana## [1] 5.5\ncumsum(y) # suma acumulada##  [1]  1  3  6 10 15 21 28 36 45 55\ny <- c(1, 2, 5, 5, 8, 9, 10, 10, 10, 11, 13, 15, 20, 23, 24, 29)\nquantile(y, probs = c(0.15, 0.3, 0.7, 0.9)) # Percentiles p15, p30, p70 y p90##  15%  30%  70%  90% \n##  5.0  8.5 14.0 23.5"},{"path":"tipos-de-datos-i-vectores.html","id":"vectores-de-caracteres-texto","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.5 Vectores de caracteres (texto)","text":"Un error común es asociar vectores solo números: un vector es una colección de elementos del mismo tipo pero tienen porque ser necesariamente números. Vamos crear una frase de ejemplo, un vector de 4 elementos de tipo texto (en R se llaman char): \"Mi\", \"nombre\", \"es\" \"Javier\".Como ves las variables de tipo char van entre comillas dobles, ya que es un cadena de texto.Ya tenemos nuestro primer vector de texto de longitud 4. Las cadenas de texto son un tipo especial de dato, con los que obviamente podremos hacer operaciones aritméticas como la suma o la media, pero si podemos hacer operaciones propias de cadenas de texto como puede ser la función paste(). Dicha función nos permite convertir un vector de 4 palabras en una frase, decidiendo que caracter queremos que vaya entre palabra con el argumento collapse =.Si queremos pegar los elementos de la cadena de texto sin ningún tipo de caracter, existe una forma más abreviada y limpia de ejecutar la orden paste(mi_nombre, collapse = \"\"), usando la función paste0()Esta función es muy útil si queremos definir variables de texto que compartan por ejemplo un prefijo (variable_1, variable_2, …) Otra forma más intuitiva de trabajar con textos y variables numéricas es usar el paquete glue, que nos permite pegar cadenas de texto variables numéricas de forma simbólica.También podemos hacer uso de dicha función sin tener los valores numéricos previamente guardados en variables.Ya sabemos trabajar con textos :)¿Y si queremos pasar todo mayúscula? ¿O todo minúscula? ¿Y si queremos sustituir un caracter (por ejemplo .) por otro en todos los elementos? R también nos proporciona algunas funciones muy sencillas (del paquete {base}) de usar para dichas tareas. Aquí un ejemplo de algunas de ellas.El paquete {base} también nos permite buscar y reemplazar patrones concretos en cadenas de texta (por ejemplo, sustituir toda letra «o» por el caracter «*»).Dentro del entorno de paquetes tidyverse, el paquete stringr permite un manejo más complejo de cadenas de texo (como el uso de expresiones regulares).\nImagen/gráfica 3.1: Paquete stringr para manejar cadenas de texto más complejas\nTabla 3.1: Paquetes mencionados hasta ahora","code":"\nmi_nombre <- c(\"Mi\", \"nombre\", \"es\", \"Javier\")\nmi_nombre## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste(mi_nombre, collapse = \"\") # todo junto## [1] \"MinombreesJavier\"\npaste(mi_nombre, collapse = \" \") # separados por un espacio## [1] \"Mi nombre es Javier\"\npaste(mi_nombre, collapse = \".\") # separados por un punto .## [1] \"Mi.nombre.es.Javier\"\npaste0(mi_nombre) # todo junto sin nada separando## [1] \"Mi\"     \"nombre\" \"es\"     \"Javier\"\npaste0(\"variable\", 1:7) # a la palabra «variable» le pegamos los números del 1 al 7## [1] \"variable1\" \"variable2\" \"variable3\" \"variable4\" \"variable5\" \"variable6\"\n## [7] \"variable7\"\npaste(\"variable\", 1:7, sep = \"_\") # separado por una barra baja## [1] \"variable_1\" \"variable_2\" \"variable_3\" \"variable_4\" \"variable_5\"\n## [6] \"variable_6\" \"variable_7\"\ninstall.packages(\"glue\")\nlibrary(glue)\nedad <- 10:15 # edades\nglue(\"La edad es de {edad} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\n## La edad es de 14 años\n## La edad es de 15 años\n# Otra forma sin definir variables a priori\nglue(\"La edad es de {10:15} años\")## La edad es de 10 años\n## La edad es de 11 años\n## La edad es de 12 años\n## La edad es de 13 años\n## La edad es de 14 años\n## La edad es de 15 años\ntexto <- c(\"Hola.\", \"qué\", \"ase?\", \"todo\", \"bien.\", \"y yo\",\n           \"que\", \"ME\", \"ALEGRO\")\ntoupper(texto) # todo a mayúscula## [1] \"HOLA.\"  \"QUÉ\"    \"ASE?\"   \"TODO\"   \"BIEN.\"  \"Y YO\"   \"QUE\"    \"ME\"    \n## [9] \"ALEGRO\"\ntolower(texto) # todo a minúscula## [1] \"hola.\"  \"qué\"    \"ase?\"   \"todo\"   \"bien.\"  \"y yo\"   \"que\"    \"me\"    \n## [9] \"alegro\"\ngsub(\"o\", \"*\", texto) # toda \"o\" en el texto será sustituida por *## [1] \"H*la.\"  \"qué\"    \"ase?\"   \"t*d*\"   \"bien.\"  \"y y*\"   \"que\"    \"ME\"    \n## [9] \"ALEGRO\""},{"path":"tipos-de-datos-i-vectores.html","id":"vectores-lógicos-truefalse","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.6 Vectores lógicos (TRUE/FALSE)","text":"[X] Variables numéricas (individuales)[X] Vectores de números[X] Vectores de caracteres[ ] Vectores lógicosVeamos un último tipo de vectores importante en todo lenguaje de programación: los vectores lógicos. Un valor lógico puede tomar tres valores:TRUE (guardado internamente como un 1).FALSE (guardado internamente como un 0).NA (dato ausente, son las siglas de available).Estos valores son resultado de evaluar condiciones lógicas. Por ejemplo, imaginemos que definimos un vector de números x <- c(1.5, -1, 2, 4, 3, -4). ¿Qué numeros del vector son menores que 2? Basta con que ejecutemos la orden x < 2, que nos devolverá TRUE/FALSE en cada hueco, en función de si cumple (TRUE) o (FALSE) la condición pedida.El primer, segundo y sexto elemento del vector son los únicos elementos (estrictamente) menores que 2, de ahí que en el primer, segundo y sexto elemento aparezca un TRUE y en el resto un FALSE. Es importante recordar que al evaluar una condición lógica sobre un vector de longitud n, la salida sigue siendo un vector de longitud n pero con valores lógicos.Dicha condición lógica puede hacerse con otros operadores como <=, > o >=. También podemos comparar si es igual otro elemento, para lo que usaremos el operador ==, pudiendo usar también su opuesto != («distinto de»).Las condiciones pueden ser combinadas, principalmente de dos maneras:Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Intersección: todas las condiciones concatenadas se deben cumplir (conjunción y, operador &) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Unión: basta con que una de las condiciones concatenadas se cumpla (conjunción o, operador |) para devolver un TRUE.Por ejemplo, vamos calcular qué elementos del vector c(1.5, -1, 2, 4, 3, -4) sean menores que 3 pero (y) mayores que 0, y los elementos menores que 2 o mayores que 3.Como hemos comentado anteriormente, los valores lógicos TRUE/FALSE son guardados internamente como 0/1 por lo que podemos usar operaciones aritméticas con ellos. Por ejemplo, si queremos averiguar el número de elementos de un vector que cumplen una condición lógica < 2, los que lo hagan tendrán asignado un 1 y los que un 0, por lo que basta con sumar el vector lógico para obtener el número de elementos bajo dicha condición.","code":"\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 2## [1]  TRUE  TRUE FALSE FALSE FALSE  TRUE\nx <= 2## [1]  TRUE  TRUE  TRUE FALSE FALSE  TRUE\nx > 2## [1] FALSE FALSE FALSE  TRUE  TRUE FALSE\nx >= 2## [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE\nx == 2## [1] FALSE FALSE  TRUE FALSE FALSE FALSE\nx != 2## [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\nx <- c(1.5, -1, 2, 4, 3, -4)\nx < 3 & x > 0 # Solo los que cumplen ambas condiciones## [1]  TRUE FALSE  TRUE FALSE FALSE FALSE\nx < 2 | x > 3 # Los cumplen al menos una de ellas## [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE\nsum(x < 2) # sumamos el vector de TRUE/FALSE --> número de TRUE## [1] 3"},{"path":"tipos-de-datos-i-vectores.html","id":"ausentes","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.7 Datos ausentes: NA y NaN","text":"La vida siempre es perfecta así que en muchas ocasiones nos encontraremos con lo que llamamos en estadística un dato ausente o missing value, un valor que tenemos en nuestra variable, y un ejemplo práctico lo tenemos con los datos de vacunación de covid del Ministerio de Sanidad. Cada día se publicaba un PDF (ya…mal) con los datos de vacunación PERO…se publican datos los fines de semana: en dichas fechas hay datos que tenemos, y en R se representan por NA (significa available). Vamos crear un vector de números con datos ausentes con la orden x <- c(1, NA, 3, NA, NA, 5, 6): el vector tendrá longitud 7 pero en el segundo, cuarto y quinto elemento tendremos un dato faltante, un lugar que tenemos relleno (pero que eliminamos).¿Puedes aventurar que sucede cuando multiplicamos ese vector por 2 por ejemplo?Un dato que tenemos, multiplicado por 2, sigue siendo un dato ausente. Es muy importante para evitar resultados erróneos que entendamos que un dato ausente computa en una operación aritmética, es un hueco vacío. Si hacemos la suma del vector, estamos sumando números más datos ausentes, por lo que el resultado final será también un dato ausente. Si tenemos algún dato ausente en nuestro vector, la suma final está su vez ausente, ¡podemos saber cuánto vale!Para evitar que un dato ausente en nuestros datos nos impida hacer ciertas operaciones, en muchas funciones de R podemos añadir el argumento na.rm = TRUE: primero elimina los datos ausentes, y luego ejecuta la función.Una manera de localizar que elementos están ausentes en nuestras variables es con la función .na(), una función que nos devuelve un vector de valores lógico: TRUE si el elemento está ausente y FALSE si lo está.Dichos datos ausentes se pueden eliminar (sin necesidad de sumarlos) con la función na.omit() (aunque veces lo que nos interesa es que sea ausente, introduciendo el punto medio entre su valor anterior y su valor posterior, por ejemplo).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6) # Vector numérico con datos faltante\nlength(x) # longitud del vector## [1] 7\nx## [1]  1 NA  3 NA NA  5  6\n2 * x # operación aritmética con un vector con NA## [1]  2 NA  6 NA NA 10 12\nsum(x) # suma de un vector que contiene NA## [1] NA\nsum(x, na.rm = TRUE) # eliminando datos ausentes## [1] 15\nis.na(x) # TRUE si está ausente (NA), FALSE si no lo está.## [1] FALSE  TRUE FALSE  TRUE  TRUE FALSE FALSE\nna.omit(x)## [1] 1 3 5 6\n## attr(,\"na.action\")\n## [1] 2 4 5\n## attr(,\"class\")\n## [1] \"omit\""},{"path":"tipos-de-datos-i-vectores.html","id":"nan-not-a-number","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.7.1 NaN: not a number","text":"Hay un tipo de dato muy particular, como resultado de operaciones permitidas o cuyo resultado es indeterminado, que en R lo veremos como NaN: number, un resultado fruto de una indeterminación, como por ejemplo la operación 0/0 (cuyo límite está definido). Importante saber que también existe una forma de denotar al infinito como Inf, siendo el resultado de algunas operaciones como 1/0.De la misma manera que podemos localizar valores NA, tenemos nuestra disposición las funciones .infinte() y .nan() para detectar que elementos de nuestro vector son Inf o NaN, respectivamente.","code":"\n1/0## [1] Inf\n0/0## [1] NaN\nx <- c(1, NA, 3, 4, Inf, 6, 7, Inf, NaN, NA)\nis.na(x)##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE\nis.nan(x)##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\nis.infinite(x)##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE"},{"path":"tipos-de-datos-i-vectores.html","id":"seleccionar-elementos-de-un-vector","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.8 Seleccionar elementos de un vector","text":"Ya sabemos definir variables que sean vectores (recuerda: colección de valores del mismo tipo). ¿Y si del vector original queremos EXTRAER UN SUBCONJUNTO del mismo, por ejemplo, los primeros 10 elementos?R tiene varias formas de hacer esto pero la más sencilla es entendiendo que si yo quiero acceder al elemento de un vector, deberé usar el operador de selección []. Veamos un ejemploDado que hemos visto que un número es más que un vector de longitud uno, esta operación también la podemos aplicar usando un vector de índices seleccionar, de forma que le podemos indicar simultaneamente que valores que queremosOtras veces querremos seleccionar un elemento en concreto sino filtrar algunos elementos en concreto y extraerlos, para lo cual deberemos repetir la misma operación pero con el signo - delante: el operador [-] selecciona el elemento -ésimo del vector sino que lo elimina en nuestro filtro. Sin embargo, lo habitual es que dicho filtro lo hagamos en base una condición lógica. Supongamos que x <- c(7, 20, 18, 3, 19, 9, 13, 3, 45) y y <- c(17, 21, 58, 33, 15, 59, 13, 1, 45) son las edades de dos grupos de personas y que queremos quedarnos solo con los mayores edad. ¿Tenemos que andar averiguando en que posición se encuentran para luego seleccionarlos? , vamos seleccionar los elementos que cumplen una condición dada.Lo que hemos hecho ha sido pasarlo como índices un vector lógico TRUE/FALSE, de forma que solo filtrará los que tengan un TRUE asignado, aquellos que cumplen la condición lógica introducida. Esto también nos puede servir para limpiar de datos ausentes, combinando la función .na(), que nos localiza el lugar que ocupan los ausentes, con el operador !, que lo que hace es negar lo que venga detrás. También podemos probar combinar condiciones lógicas para nuestra selección.Como ves si un valor es NA, la evaluación de una condición lógica sobre él (mayor o menor de 18 años) nos seguirá devolviendo NA. Por último, R nos permite dar significado léxico nuestros valores (significan algo, solo números), pudiendo poner nombres los elementos de un vector, permitiendo su selección por dichos nombres.Con la función names() además podemos, solo consultar los nombres de una variable, sino cambiarlos nuestro gusto.CONSEJO: , anyExisten dos funciones muy útiles en R para saber si TODOS o ALGUNO de los elementos de un vector cumple una condición. Las funciones () y () nos devolverá un único valor lógico. Estas funciones son muy útiles al final de los códigos para comprobar que las condiciones que tienen que verificar los datos se cumplen, y asegurarnos que el proceso se ha ejecutado correctamente (por ejemplo, que todos los datos sean positivos o haya datos ausentes).","code":"\nx <- 1:100 # Vector de longitud 100 (del 1 al 100)\ny <- x[37] # Solo me interesa el elemento que ocupa el lugar 37\ny## [1] 37\nx[c(1, 4, 51, 77)] # Solo queremos acceder a los elementos en la posición 1, 4, 51, y 77## [1]  1  4 51 77\ny <- c(\"hola\", \"qué\", \"tal\", \"todo\", \"ok\", \"?\")\ny[1:2] # Solo queremos acceder a los elementos en la posición 1 y 2## [1] \"hola\" \"qué\"\nc(1:2, length(y))## [1] 1 2 6\ny[c(1:2, length(y))] # Solo accedemos a los elementos en la posición 1, 2 y además el que ocupa la última posición (recuerda: length(y) nos da la longitud total del vector)## [1] \"hola\" \"qué\"  \"?\"\ny## [1] \"hola\" \"qué\"  \"tal\"  \"todo\" \"ok\"   \"?\"\nz <- y[-2] # Nos muestra todo y salvo el elemento que ocupa la segunda posición\nz## [1] \"hola\" \"tal\"  \"todo\" \"ok\"   \"?\"\nx <- c(7, 20, 18, 3, 19, 9, 13, 3, 45)\ny <- c(17, 21, 58, 33, 15, 59, 13, 1, 45)\nx[x >= 18] # mayores de 18 años del conjunto x## [1] 20 18 19 45\ny[x >= 18] # mayores de 18 años del conjunto y## [1] 21 58 15 45\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[x >= 18] # mayores de 18 años del conjunto x## [1] NA 20 19 21 25 80 NA\nx[is.na(x)] # solo valores ausentes## [1] NA NA\nx[!is.na(x)] # sin valores ausentes: ! es el símbolo de la negación## [1]  7 20  3 19 21 25 80\n!(x >= 18) # niega los mayores de 18 años, todo lo que no cumpla esa condición## [1]  TRUE    NA FALSE  TRUE FALSE FALSE FALSE FALSE    NA\nx[x >= 18 & x <= 25] # los valores que cumplen ambas (&): entre 18 y 25 años## [1] NA 20 19 21 25 NA\nx <- c(\"edad\" = 31, \"tlf\" = 613910687, \"cp\" = 33007) # cada número tiene un significado distinto\nx##      edad       tlf        cp \n##        31 613910687     33007\nx[c(\"edad\", \"cp\")] # seleccionamos los elementos que tienen ese nombre asignado##  edad    cp \n##    31 33007\nnames(x) # Consultamos nombres## [1] \"edad\" \"tlf\"  \"cp\"\nnames(x) <- c(\"años\", \"móvil\", \"dirección\") # Cambiamos nombres\nnames(x) # Consultamos nuevos nombres## [1] \"años\"      \"móvil\"     \"dirección\"\nx##      años     móvil dirección \n##        31 613910687     33007\nx <- c(1, 2, 3, 4, 5, NA, 7)\nall(x < 3)## [1] FALSE\nany(x < 3)## [1] TRUE\nall(x > 0)## [1] NA\nall(na.omit(x) > 0)## [1] TRUE\nall(is.na(x))## [1] FALSE\nany(is.na(x))## [1] TRUE"},{"path":"tipos-de-datos-i-vectores.html","id":"which","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.8.1 which","text":"Hemos visto como seleccionar elementos de un vector que cumplen una condición, para veces queremos el elemento en sí, sino el lugar que ocupa: ¿qué valores de un vector cumplen una condición lógica, qué lugar ocupan? Para obtener dicho índice tenemos nuestro disposición la función (), que nos devuelve el elemento en sí sino su lugar.Esta función es muy útil especialmente cuando queremos averiguar el valor que ocupa el máximo/mínimo de una colección de valores, con las funciones .max() y .min().","code":"\nx <- c(7, NA, 20, 3, 19, 21, 25, 80, NA)\nx[x >= 18] # Accedemos a los elementos que cumplen la condición## [1] NA 20 19 21 25 80 NA\nwhich(x >= 18) # Obtenemos los lugares que ocupan los elementos que cumplen la condición## [1] 3 5 6 7 8\nmax(x, na.rm = TRUE) # máximo de x (si no eliminamos NA, nos devolverá NA)## [1] 80\nmin(x, na.rm = TRUE) # mínimo de x (si no eliminamos NA, nos devolverá NA)## [1] 3\nwhich.max(x) # Lugar que ocupa el máximo## [1] 8\nx[which.max(x)]## [1] 80\nwhich.min(x) # Lugar que ocupa el mínimo## [1] 4\nx[which.min(x)]## [1] 3"},{"path":"tipos-de-datos-i-vectores.html","id":"null","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.8.2 NULL","text":"veces veremos que además de NA y NaN, R nos muestra un dato llamado NULL. Cuando tenemos NA en alguna variable, el registro existe, pero está relleno. Sin embargo, cuando tenemos un NULL significa que ese registro ni siquiera existe: es un dato guardado pero cuyo valor desconocemos, es un dato que ni siquiera existe (por ejemplo, si guardamos datos de 7 personas, el dato de la octava persona es NA, es que hay octava persona directamente).","code":"\nx <- c(1, NA, 3, NA, NA, 5, 6)\nx[2] # NA: el registro existe pero sin dato## [1] NA\nnames(x) # No hemos definido el nombre de las variables, así que devuelve NULL## NULL"},{"path":"tipos-de-datos-i-vectores.html","id":"ordenar-vectores","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.9 Ordenar vectores","text":"Una acción habitual al trabajar con datos es saber ordenarlos: de menor mayor edad, datos más recientes vs antiguos, etc. Para ello tenemos la función sort(), que podemos usar directamente para ordenar de menor mayor, o con el argumento decreasing = TRUE, para ordenar de mayor menor.Otra forma de ordenar un vector es que R nos devuelva los índices de los elementos ordenados, y luego usar dichos índices para reorganizar los elementos, con la función order().","code":"\nx <- c(1, -3, 0, 10, 5, 2, 7, -13)\nsort(x) # orden de menor a mayor## [1] -13  -3   0   1   2   5   7  10\nsort(x, decreasing = FALSE) # orden de mayor a menor## [1] -13  -3   0   1   2   5   7  10\norder(x) # el elemento más pequeño es el octavo, luego el segundo, luego el tercero, luego el primero, luego el sexto, etc.## [1] 8 2 3 1 6 5 7 4\nx[order(x)] # accedemos a los índices ordenados, equivalente al sort(x)## [1] -13  -3   0   1   2   5   7  10"},{"path":"tipos-de-datos-i-vectores.html","id":"fechas","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.10 Fechas","text":"numeric: variables de tipo numéricas (algunas veces vendrán indicados como int o integer para enteros, y dbl o double para números con decimales).character: variables de tipo caracter.Date: variables de tipo fecha.Hay un tipo muy especial de datos que son los datos tipo fecha. Una fecha podría ser priori una simple cadena de texto \"2021-04-21\" pero podemos usar la función .Date() para que R entienda que esa cadena de texto representa un instante temporal. Fíjate la diferencia entre una fecha en texto y una fecha con .Date().En el momento en que convertimos la cadena de texto fecha, aunque se visualice como tal, internamente es un número, por lo que podemos restar fechas (días entre ambas), podemos sumar números fechas (fecha días después), etc. Dentro del entorno tidyverse, el paquete lubridate tiene implementadas múltiples funciones para poder operar con fechas de forma sencilla e intuitiva.Tabla 3.2: Paquetes mencionados hasta ahoraCONSEJO: argumentos por defectoLa función sort() es un buen ejemplo de que las funciones traen definidos argumentos por defecto (aunque los veamos priori). La orden sort(x) en realidad está ejecutando sort(x, decreasing = TRUE), pero como es su valor por defecto, nos podemos ahorrar incluirlo. Escribe ? help sort() en la consola y verás como en la cabecera de la función ya hay preasignado un decreasing = TRUE.Convertir tipos de datosA veces la lectura de variables numéricas de nuestros archivos puede hacer que un número, por ejemplo 1, sea leído como la cadena de texto \"1\", con la que podemos operar como un número. Las funciones .numeric(), .character() y .logical() nos permiten convertir una variable en tipo numérico, caracter o lógico, respectivamente.CONSEJO: optimizar nuestro códigoAunque parezca un tema menor, si tu código tarda 1 milisegundo más de lo que podría tardar de otra forma, si esa orden se repite muchas veces, ese milisegundo extra puede ser 5, 10 o 20 minutos más que tu código tardará en ejecutarse. Hay un paquete muy útil en R para medir tiempos de distintas órdenes que hacen lo mismo (el paquete microbenchmark), vamos instalarlo.Este paquete contiene una orden para comparar el tiempo de dos órdenes: necesita como primeros argumentos las dos órdenes cuyos tiempos vamos comparar, y un argumento times en el que le indicamos el número de veces que ejecutará cada orden para realizar los tiempos medios. Vamos comparar los comandos de ordenación order() y sort().Sí, estás viendo bien: aunque priori parezca contraintuitivo, es más corto obtener los índices ordenados de un vector, y luego reordenarlo en base esos índices, que la ordenación directa través del comando sort() (ya que usan algoritmos de ordenación distintos).Tabla 3.3: Paquetes mencionados hasta ahora","code":"\nfecha_char <- \"2021-04-21\"\nfecha_date <- as.Date(fecha_char, format = \"%Y-%m-%d\")\nfecha_char + 1## Error in fecha_char + 1: argumento no-numérico para operador binario\nfecha_date + 1## [1] \"2021-04-22\"\n\"1\" + 1## Error in \"1\" + 1: argumento no-numérico para operador binario\nas.numeric(\"1\") + 1## [1] 2\nas.character(1)## [1] \"1\"\nas.logical(c(0, 1))## [1] FALSE  TRUE\ninstall.packages(\"microbenchmark\")\nlibrary(microbenchmark)\nx <- rnorm(1e3) # 1000 elementos aleatorias de una normal N(0, 1)\nmicrobenchmark(sort(x), # primera forma\n               x[order(x)], # segunda forma\n               times = 1e3) # se repetirá 1000 veces## Unit: microseconds\n##         expr    min      lq     mean  median      uq      max neval cld\n##      sort(x) 43.121 49.0095 63.43935 52.3275 67.8190  456.070  1000   b\n##  x[order(x)] 30.078 35.3965 48.33256 37.1710 46.2485 4125.593  1000  a"},{"path":"tipos-de-datos-i-vectores.html","id":"ejercicios-1","chapter":"Capítulo 3 Tipos de datos I: vectores","heading":"3.11 📝 Ejercicios","text":"📝Ejercicio 1: define un vector que contenga los números 1, 10, -1 y 2, y guárdalo en una variable llamada vector_num. Tras definirlo, calcula su suma (haz click en la flecha para la solución propuesta). Solución: 📝Ejercicio 2: calcula la versión ordenada del vector anterior vector_num (haz click en la flecha para la solución propuesta). Solución: 📝Ejercicio 3: encuentra del vector vector_num original el lugar (el índice) que ocupa su mínimo y su máximo (haz click en la flecha para la solución propuesta). Solución: 📝Ejercicio 4: encuentra del vector vector_num los elementos mayores que 1 y menores que 7. Encuentra una forma de averiguar si todos los elementos son o positivos (haz click en la flecha para la solución propuesta). Solución: 📝Ejercicio 5: crea un vector con las palabras “Hola”, “”, “llamo” (y tu nombre y apellidos), y pega luego sus elementos de forma que la frase esté correctamente escrita en castellano. Tras hacerlo, añade “y tengo 30 años” (haz click en la flecha para la solución propuesta). Solución: 📝Ejercicio 6: obten la fecha de hoy, define la fecha de tu cumpleaños, y calcula la diferencia de días (haz click en la flecha para la solución propuesta).Solución:","code":"\n# Vector de números\nvector_num <- c(1, 10, -1, 2)\n\n# Suma\nsum(vector_num)## [1] 12\n# Ordenamos el vector + 1 (con sort)\nsort(vector_num + 1)## [1]  0  2  3 11\n# Ordenamos el vector + 1 (con order)\nvector_num2 <- vector_num + 1\nvector_num2[order(vector_num2)]## [1]  0  2  3 11\nvector_num <- c(1, 10, -1, 2)\n\n# Encontrando el lugar que ocupa el máximo y mínimo\nwhich.max(vector_num)## [1] 2\nwhich.min(vector_num)## [1] 3\n# Vector lógico: mayores que 1 y menores que 7\nvector_num > 1 & vector_num < 7## [1] FALSE FALSE FALSE  TRUE\n# ¿Son todos positivos?\nall(vector_num > 0)## [1] FALSE\n# Vector lógico: mayores que 1 y menores que 7\nvector_num > 1 & vector_num < 7## [1] FALSE FALSE FALSE  TRUE\n# ¿Son todos positivos?\nall(vector_num > 0)## [1] FALSE\n# Definiendo el vector\nvector_char <- c(\"Hola\", \"me\", \"llamo\", \"Javier\",\n                 \"Álvarez\", \"Liébana\")\n\n# Pegamos\npaste(vector_char, collapse = \" \")## [1] \"Hola me llamo Javier Álvarez Liébana\"\n# Añadimos frase\npaste0(paste(vector_char, collapse = \" \"), \" y tengo 30 años.\")## [1] \"Hola me llamo Javier Álvarez Liébana y tengo 30 años.\"\n# Hoy\nhoy <- Sys.Date()\n\n# Cumple (diferentes formatos)\ncumple <- as.Date(\"1989-09-10\")\ncumple <- as.Date(\"10-09-1989\", \"%d-%m-%Y\")\n\n# Diferencia\nhoy - cumple## Time difference of 11702 days"},{"path":"flujo-de-trabajo-proyecto.html","id":"flujo-de-trabajo-proyecto","chapter":"Capítulo 4 Flujo de trabajo: proyecto","heading":"Capítulo 4 Flujo de trabajo: proyecto","text":"Tabla 4.1: Paquetes mencionados hasta ahoraCONSEJO: cambiar la notación exponencialPor defecto, R muestra los números en formato de notación exponencial. Por ejemplo, el número 1000000 nos lo mostrará por defecto como 1e+06. veces podemos querer que se muestre con todas sus cifras (por ejemplo, en el título o leyenda de una gráfica): para anular la notación exponencial, escribe al inicio del código options(\"scipen\" = 10).CONSEJO: limpiar consolaPodemos limpiar la consola clickando en al escoba que tenemos en la parte superior derecha de la misma. Esta acción nos elimina ninguna variable, simplemente nos limpia la consola de mensajes.Estamos listos/para crear nuestro primer proyecto de R :)Cuando se empieza programar para un trabajo concreto de R es recomendable crearnos lo que se conoce como un proyecto de R: en lugar de ir abriendo ventanas sueltas para programar (los scripts, los archivos con extensión .R), podemos agruparlos en distintos proyectos, de forma que podamos acceder ellos de forma ordenada (algo así como crear carpetas en nuestro disco duro).","code":""},{"path":"flujo-de-trabajo-proyecto.html","id":"crear-proyecto","chapter":"Capítulo 4 Flujo de trabajo: proyecto","heading":"4.1 Crear proyecto","text":"Para crear nuestro proyecto deberemos de ir al menú superior File << New Project (ver 4.1)\nImagen/gráfica 4.1: Crear un nuevo proyecto en R.\nSe nos abrirá una ventana con 3 opciones:New directory: crear un proyecto desde el inicio (opción recomendable).New directory: crear un proyecto desde el inicio (opción recomendable).Existing directory: crear un proyecto con los códigos que tienes ya guardados en una carpeta.Existing directory: crear un proyecto con los códigos que tienes ya guardados en una carpeta.Version control: para importar el proyecto de algún repositorio y vincularlo él.Version control: para importar el proyecto de algún repositorio y vincularlo él.\nImagen/gráfica 4.2: Opciones de creación.\n\nImagen/gráfica 4.3: Clickar en «New project».\nDeberemos elegir el directorio de nuestro ordenador donde queremos que se guarde (una carpeta que contendrá todos los códigos y datos de ese proyecto), así como el nombre del proyecto (que será su vez el nombre de la subcarpeta que se os creará en el ordenador).\nImagen/gráfica 4.4: Nombre del proyecto.\nUna vez que el proyecto está creado, abriremos nuestro primer script de R (donde escribiremos el código), escribiremos una descripción del proyecto en la primera línea y guardaremos el archivo (archivo de extensión .R).\nImagen/gráfica 4.5: Abrir nuestro primer script de R.\n\nImagen/gráfica 4.6: Descripción al inicio del código.\n\nImagen/gráfica 4.7: Guardamos el código.\n\nImagen/gráfica 4.8: Guardamos el código.\nEste será nuestro código principal (puedes ponerle el nombre que quieras, normalmente se le llama main.R para diferenciarlo del resto), desde el que iremos construyendo nuestro código e iremos llamando otros archivos si es necesario. Recuerda que programar es como escribir: cuanto más limpio y estructurado, mejor se entenderá. La ventaja de tener los códigos agrupados por proyectos es que si estamos trabajando en varios la vez podemos saltar de uno otro, visualizando solo los códigos de un proyecto, y los 100 archivos sin_titulo131.R que vayamos creando.\nImagen/gráfica 4.9: Saltar de proyecto en proyecto.\n","code":""},{"path":"flujo-de-trabajo-proyecto.html","id":"directorios-de-trabajo-y-cabecera","chapter":"Capítulo 4 Flujo de trabajo: proyecto","heading":"4.2 Directorios de trabajo y cabecera","text":"Como luego veremos en la Sección 6, es altamente recomendable que todos los archivos (códigos, datos, imágenes, recursos, etc) los tengamos dentro de la misma carpeta del proyecto (aunque podamos crear subdirectorios), para que trabajar en el proyecto sea más sencillo e intuitivo. Vamos crearnos dentro de la carpeta del proyecto, una subcarpeta que se llame DATOS, en donde debemos descargar todos los ficheros que hay en https://github.com/dadosdelaplace/cursoR_intro/tree/main/DATOS, y otra llamada CODIGOS, donde guardar nuestros archivos .R (por eso de ser ordenadicos.)\nImagen/gráfica 4.10: Subcarpeta «CODIGOS».\nEn esa carpeta de códigos vamos crear de prueba el código llamado variables.R donde vamos definir algunas variables que luego usaremos en el código principal (suele suceder con variables que van ser fijas como nombres, fechas o codificaciones de variables).\nImagen/gráfica 4.11: Escribimos una serie de variables fijas para luego ser usadas.\nes obligatorio pero es altamente recomendable tener muy estructurado nuestros códigos, de forma que el archivo .R haga una tarea concreta y definida (uno carga archivos, otro preprocesa, otro hace un modelo, otro hace las gráficas), y sea el código principal el que haga una llamada limpia todos ellos, para que en caso de error, la detección del mismo sea más sencilla.Así que eso haremos: desde nuestro archivo principal main.R llamaremos ese archivo variables.R, para luego usar las variables definidas en él.¿Cómo indicarle R donde está nuestro fichero?En R, como en todo lenguaje de programación, podemos consultar lo que el ordenador llama directorio de trabajo: la carpeta «base» desde donde está ejecutando tu código. Dicha ruta de directorio se puede consultar con la función getwd(), pudiendo ver los archivos y carpetas que hay dentro del mismo con el comando dir()\nImagen/gráfica 4.12: Consultar directorio de trabajo predeterminado y archivos contenidos en él.\nLo ideal es empezar el código fijando como directorio de trabajo el directorio donde tengamos nuestro archivo principal main.R y para ello usaremos la función setwd(), cuyo argumento será la ruta donde queremos fijarlo. Para hacerlo de forma automática (y que el código pueda ser abierto por ti pero también por otros que tengan tu misma estructura de carpetas), obtendremos de forma automática la ruta del archivo main.R o del proyecto con la orden rstudioapi::getSourceEditorContext()$path, y después usaremos dirname() para quedarnos solo con la ruta de carpetas (eliminando el nombre del fichero al final). Esa será la ruta que le pasaremos setwd(), quedando nuestro directorio de trabajo automáticamente fijado, sin preocuparnos de la ruta\nImagen/gráfica 4.13: Fijamos de forma automático el directorio de trabajo.\nUna vez que hemos fijado nuestro directorio, para cargar código .R, basta que usemos la función source(), cuyo argumento será la ruta del archivo. Como tenemos de directorio base el directorio en el que tenemos nuestro archivo principal (./), bastará que empecemos escribir source(\"./\"), presionar el tabulador, y se nos abrirá el menú de archivos de nuestro directorio de trabajo, pudiendo ir seleccionando de forma sencilla la ruta de nuestro archivo.\nImagen/gráfica 4.14: Cargar archivos de nuestro directorio de trabajo.\n\nImagen/gráfica 4.15: Cargar archivos de nuestro directorio de trabajo.\n","code":"\n# Descripción: script de prueba con variables\n\n# Variables\nx <- c(1, 2, 0, -1, 71) # Vector de números\ny <- c(\"hola\", \"me\", \"llamo\", \"Javier\") # Vector de caracteres\napellido <- \"Álvarez\"\n\n# Fechas\nhoy <- as.Date(Sys.time()) # Convertir a tipo fecha la fecha de hoy\nfecha_origen <- as.Date(\"2021-01-01\") # Inicio de año\ngetwd()\ndir()\n# Fijamos directorio de trabajo automáticamente\nsetwd(dirname(rstudioapi::getSourceEditorContext()$path))\n# Cargamos fichero variable.R\nsource(\"./CODIGOS/variables.R\")"},{"path":"flujo-de-trabajo-proyecto.html","id":"ejecución","chapter":"Capítulo 4 Flujo de trabajo: proyecto","heading":"4.3 Ejecución","text":"Ese archivo que hemos incluido en el código principal nos cargará las variables que hemos definido en él, pudiendo usarlas en el código. Vamos ejecutar lo que tenemos de momento, y para ello tenemos 2 opciones: o copiar el código del script en la consola y pulsar ENTER, o bien, activando la casilla source save y guardando el script (solo se guardará sino que se ejecutará).\nImagen/gráfica 4.16: Guardamos con la casilla «source save» activada para que además de guardar se ejecute el código.\nComo vemos en la imagen 4.16, una vez ejecutado, tenemos en nuestro panel de entorno (parte superior derecha) las variables ya cargadas que teníamos definidas en nuestro fichero variables.R.Prueba escribir algunas funciones que hemos aprendido con dichas variables y vuelve hacer click en «guardar» con source save activado.La función cat() nos muestra por consola el texto que le pasemos de argumento (función especial para mensajes de alerta por consola)\nImagen/gráfica 4.17: Cálculos con la variables definidas: suma, concatenación de texto y diferencia de fechas.\nYa hemos ejecutado nuestro primer proyecto en .R :)CONSEJO: comentarios en los códigosEs crucial que intentes documentar al máximo tu código y que te acostumbres ello desde el principio, dejando explícito que haces en cada paso, tanto para ti como para otra persona que pueda leer tu código y lo entienda. Para ello usaremos # comentario cuando queramos dejar comentarios en el código. Dichas partes, amén de estar en otro color, son leídas por R ni ejecutadas: son comentarios que el programa «ve», solo son para nosotros.Guardar los scriptsLos scripts que tengas sin guardar tendrán un asterisco * al final del nombre en la pestaña superior de la ventana.CONSEJO: extraer fecha y hora de hoyLa función Sys.time() accede al sistema de nuestro ordenador para decirnos la fecha y hora del momento de la ejecución de dicha función.","code":"\n# Sumamos 3 a cada elemento de x\nz <- x + 3\nz## [1]  4  5  3  2 74\n# Imprimimos por pantalla la frase unida, y a dicha frase\n# le pegamos nuestro apellido\ncat(paste(paste(y, collapse = \" \"), apellido))## hola me llamo Javier Álvarez\n# Días que han pasado desde el inicio de año\ndias <- hoy - fecha_origen\ndias## Time difference of 266 days\nSys.time()## [1] \"2021-09-24 11:06:06 CEST\""},{"path":"control.html","id":"control","chapter":"Capítulo 5 Estructuras de control","heading":"Capítulo 5 Estructuras de control","text":"Aunque la mayoría de veces son sustituibles por otras expresiones más legibles y eficientes, es importante que conozcamos como se usan las expresiones de control más típicas.","code":""},{"path":"control.html","id":"ifelse","chapter":"Capítulo 5 Estructuras de control","heading":"5.1 if…else","text":"Como en cualquier lenguaje de programación, las estructuras ...else... nos permiten ejecutar partes de nuestro código solo cuando se cumple la condición o condiciones lógicas que queremos. Cuando ejecutamos un estamos diciendoif…elseSI las condiciones impuestas se cumplen (TRUE), ejecuta las órdenes que tengamos dentro de las llaves. Si elif devuelve FALSE, sucederá nada SALVO que tengamos además un else: lo que sucede cuando se cumple, como en el ejemplo que tenemos debajo.Las órdenes dentro del primer se ejecutarán si todas las personas son mayores de edad. En caso de cumplirse (como es el caso), se ejecutará lo que hay entre llaves tras el else (filtra solo los mayores de edad e imprime un mensaje de control).Dicha estructura puede anidarse, de forma que vayamos concatenando estructuras ifelse, como en el ejemplo que tenemos debajo.Esta estructura condicional puede ser vectorizada, de forma que podamos reunir en una sola fila un número elevado de estructuras de comparación. Por ejemplo, vamos definir un vector de números y vamos comprobar si son números pares o impares (para ello, usamos el operador %%, que nos calcula el resto de cada número al dividirlo por una cifra).Para nuestro objetivo aplicaremos la función ifelse(), cuyos argumentos de entrada serán la condición evaluar, lo que sucede cuando se cumple y lo que , que aplicará cada elemento del vector de entrada.Esta función ifelse() es muy util para codificar variables o averiguar cuales cumplen una condición, sin necesidad de hacer un bucle que recorra todos los valores.CONSEJORecuerda: di (por lo general) los bucles en R.","code":"\nedades <- c(14, 24, 56, 31, 20, 87, 73)\nmayores_de_edad <- FALSE \n\nif (all(edades >= 18)) { # Si todas las personas son mayores de edad\n  \n  mayores_de_edad <- TRUE\n  print(\"todos mayores de edad\")\n  \n} else { # si la condición no se cumple: filtramos solo los mayores\n\n  edades <- edades[edades >= 18]  \n  print(\"algún menor de edad se ha eliminado\")\n  \n}## [1] \"algún menor de edad se ha eliminado\"\nedades <- c(14, 14, 16, 11, 2, 17, 13)\n\nif (all(edades >= 18)) { # Si todas las personas son mayores de edad\n  \n  mayores_de_edad <- TRUE\n  print(\"todos mayores de edad\")\n  \n} else if (any(edades >= 18)) { # si alguna es mayor de edad\n\n  edades_18 <- edades[edades >= 18]  \n  print(\"algún menor de edad se ha eliminado\")\n  \n} else { # ninguna persona mayor de edad\n  \n  print(\"todas las personas son menores de edad\")\n  \n}## [1] \"todas las personas son menores de edad\"\n1 %% 2## [1] 1\n2 %% 2## [1] 0\n3 %% 2## [1] 1\n5 %% 3## [1] 2\nnumeros <- 1:10\nifelse((numeros %% 2) == 0, \"par\", \"impar\") # Los pares al dividir entre 2 tienen resto 0##  [1] \"impar\" \"par\"   \"impar\" \"par\"   \"impar\" \"par\"   \"impar\" \"par\"   \"impar\"\n## [10] \"par\""},{"path":"control.html","id":"forwhile","chapter":"Capítulo 5 Estructuras de control","heading":"5.2 for/while","text":"Aunque el 99% de las veces (porcentaje inventado) los bucles pueden ser sustituidos por códigos de forma vectorial mucho más eficientes, veces nos quedará más remedio que usarlos por lo que nunca viene mal conocer su estructura.Un bucle {} es una estructura que nos permite ejecutar un conjunto de órdenes un número repetido (finito y conocido) de veces: dado un conjunto de índices, el bucle irá recorriendo cada elemento de dicho conjunto, y para cada uno de ellos ejecutará lo que tenga dentro de las llaves.Aunque normalmente el conjunto que recorre el bucle suelen ser índices numéricos, podemos recorrer cualquier tipo de objeto.::: {.rmdimportant}CONSEJO: evita buclesEvita al máximo los bucles en R: suele existir una forma más eficiente de programarlo. Veamos un ejemplo muy sencillo: dado un vector de índices idx, queremos calcular su cuadrado y guardarlo. Vamos comparar como sería con un sencillo bucle y de forma vectorial, repitiéndolo 1000 veces para sacar tiempos medios, haciendo uso del paquete microbenchmark.Una tarea tan sencilla, programada en un bucle (segunda fila), tarda 40 veces más que hacerlo de forma vectorial (primera fila) (elevando cada elemento al cuadrado, iterando internamente, sin necesidad de implementar un bucle). Otra manera de diseñar un bucle es con la estructura {}, que ejecutará el bucle un número de veces priori desconocido hasta que la condición impuesta deje de ser TRUE.¿Y qué sucede cuando la condición nunca llega ser FALSE? Compruébalo tú mismo/.","code":"\nvariable <- NULL # vector donde guardaremos los pasos del bucle\nfor (i in 1:10) { \n  \n  variable[i] <- i # R es silenciosos: salvo que hagamos un print dentro del bucle no nos imprimirá nada por pantalla\n}\nvariable##  [1]  1  2  3  4  5  6  7  8  9 10\nfor (i in 1:10) { \n  \n  print(i^3) # imprimimos el índice al cubo\n}## [1] 1\n## [1] 8\n## [1] 27\n## [1] 64\n## [1] 125\n## [1] 216\n## [1] 343\n## [1] 512\n## [1] 729\n## [1] 1000\ndias_semana <- c(\"lunes\", \"martes\", \"miércoles\", \"jueves\",\n                 \"viernes\", \"sábado\", \"domingo\")\nnombre_mayuscula <- NULL\nfor (dias in dias_semana) { # dias recorre los días de la semana tomando sus valores\n  \n  print(toupper(dias))\n}## [1] \"LUNES\"\n## [1] \"MARTES\"\n## [1] \"MIÉRCOLES\"\n## [1] \"JUEVES\"\n## [1] \"VIERNES\"\n## [1] \"SÁBADO\"\n## [1] \"DOMINGO\"\nidx <- 1:10000\nx <- y <- rep(0, length(idx))\nmicrobenchmark::microbenchmark(x <- idx^2, \n                               for (i in idx) {  y[i] <- idx[i]^2},\n                               times = 1e3)## Unit: microseconds\n##                                     expr      min        lq       mean\n##                               x <- idx^2   18.154   49.6155   57.71767\n##  for (i in idx) {     y[i] <- idx[i]^2 } 1850.248 2039.0805 2336.66239\n##     median       uq      max neval cld\n##    56.4525   64.065  171.816  1000  a \n##  2188.6630 2475.333 8596.517  1000   b\nmax_ciclos <- 10\nciclos <- 1\n\n# Mientras el número de ciclos sea inferior 10, imprime\nwhile(ciclos <= max_ciclos) {\n  \n  print(paste(\"Todavía no, vamos por el ciclo \", ciclos)) # Pegamos la frase al número de ciclo por el que vayamos con paste\n  ciclos <- ciclos + 1\n  \n}## [1] \"Todavía no, vamos por el ciclo  1\"\n## [1] \"Todavía no, vamos por el ciclo  2\"\n## [1] \"Todavía no, vamos por el ciclo  3\"\n## [1] \"Todavía no, vamos por el ciclo  4\"\n## [1] \"Todavía no, vamos por el ciclo  5\"\n## [1] \"Todavía no, vamos por el ciclo  6\"\n## [1] \"Todavía no, vamos por el ciclo  7\"\n## [1] \"Todavía no, vamos por el ciclo  8\"\n## [1] \"Todavía no, vamos por el ciclo  9\"\n## [1] \"Todavía no, vamos por el ciclo  10\"\nwhile (1 > 0) { # Nunca va a dejar de ser cierto\n  \n  print(\"Presiona ESC para salir del bucle\")\n  \n}"},{"path":"control.html","id":"breaknext","chapter":"Capítulo 5 Estructuras de control","heading":"5.2.1 BREAK/NEXT","text":"En R tenemos dos comandos reservados para poder abortar un bucle o avanzar forzosamente un bucle: dichas palabras son break y next. La primera nos habilita para parar un bucle aunque haya llegado al final de su conjunto de índices recorrer (o se siga cumpliendo la condición del {}).Mientras que la segunda obliga al bucle avanzar la siguiente interacción, abortando la iteración actual en la que se encuentra.","code":"\nfor(i in 1:10) {\n  if (i == 7) {\n    \n    break # si i es 7, el bucle frena aquí (nunca llegará a imprimir el 7 ni los sucesivos)\n    \n  }\n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\nfor(i in 1:10) {\n  if (i == 7) {\n    \n    next # si i es 7, la iteración frenará aquí y pasará a la siguiente por lo que imprimirá todos menos el 7\n    \n  }\n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 8\n## [1] 9\n## [1] 10"},{"path":"control.html","id":"repeat","chapter":"Capítulo 5 Estructuras de control","heading":"5.2.2 REPEAT","text":"Aunque es una opción muy poco usada, existe una estructura de control llamada repeat{} que nos ejecuta un bucle de forma infinita hasta que le ordenemos parar con un break.Cuidado con los bucles infinitosLas estucturas {} y repeat{} son de las menos usadas por su peligrosidad, ya que si incluimos un break o la condición nunca llega ser TRUE, el bucle seguirá ejecutándose de forma infinita y solo podrá ser detenido abortando la ejecución con la tecla ESC.CONSEJO: minimiza estructuras de control en el códigoPuedes minimizar las estructuras de control pulsando en la flecha que aparece la izquierda de ellas.","code":"\nconteo <- 0\nrepeat { \n  \n  conteo <- conteo + 1\n  if (conteo >= 100) { break }\n  \n}\nconteo## [1] 100"},{"path":"datos.html","id":"datos","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"Capítulo 6 Datos estructurados: matrices y tablas","text":"Acceso las funciones de los paquetesA veces puede que queramos cargar todo un paquete sino solo una función del mismo, para lo que es suficiente nombre_paquete::nombre_funcion.Sabemos un poco de la gramática y ortografía de nuestro lenguaje, y sabemos las funcionalidades básicas de nuestro Word. Vamos encontrar la mejor trama para la novela: hablemos de estructuras de datos.","code":""},{"path":"datos.html","id":"matrices","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"6.1 Matrices","text":"Hasta ahora hemos visto solo datos en una dimensión: una variable, que tiene n valores numéricos, n valores lógicos o n valores de tipo texto. Una sola variable (de n elementos).Pero cuando analizamos datos solemos tener varias variables distintas. Cuando tenemos distintas variables numéricas de igual longitud, un formato de dato muy habitual de trabajar es lo que conocemos como matrices: una «tabla» de números, con filas y columnas.Vamos definir las edades, teléfonos y códigos postales de una serie de individuos.Hasta ahora, cada variable la hemos definido por separado, pero ahora vamos juntarlas: vamos crear nuestro primer conjunto de datos juntado todas ellas en una matriz, un conjunto de números organizado en 3 columnas (una por variable) y 7 filas o registros (una por persona). Para ello usaremos la función cbind(), que nos concatena vectores de igual longitud en formato columna.Lo que tenemos es una columna por variable y una fila por registro. También podemos construir la matriz por filas con el comando rbind() (aunque lo habitual es tener cada variable en una columna).Como ves, ahora nuestros datos están tabulados, tienen dos dimensiones. ¿Cómo saber las dimensiones que tiene una matriz? Prueba ejecutar la función dim().Fíjate que dim() devuelve un vector de 2 elementos, por lo que para acceder las filas deberemos ejecutar dim(x)[1] (y dim(x)[2] para las columnas).También tenemos nuestra disposición las funciones nrow() y ncol(), que nos devuelven directamente el número de filas y columnas.Bien, ya sabemos definir una matriz partir de variables. Igual que veces es útil generar un vector de elementos repetidos, también podemos definir una matriz de números repetidos (por ejemplo, de ceros), con la función matrix(), indicándole el número de filas y columnas.También podemos definir una matriz partir de un vector numérico, reorganizando los valores en forma de matriz (con una dimensión tal que filas * columnas = longitud del vector), sabiendo que los elementos se van colocando por columnas (primeros valores en la primera columna, de arriba abajo). Dada una matriz x podemos darle vuelta (lo que se conoce como matriz transpuesta, donde filas pasan ser columnas y viceversa) con la función t().","code":"\nedades <- c(14, 24, 56, 31, 20, 87, 73) # vector numérico de longitud 7\ntlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)\ncp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)\nx <- cbind(edades, tlf, cp) # Construimos la matriz por columnas\nx##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\ny <- rbind(edades, tlf, cp) # Construimos la matriz por filas\ny##         [,1]      [,2]      [,3]      [,4]  [,5]      [,6]  [,7]\n## edades    14        24        56        31    20        87    73\n## tlf       NA 683839390 621539732 618211286    NA 914727164    NA\n## cp     33007     28019     37005     18003 33091     25073 17140\ndim(x)## [1] 7 3\ndim(y)## [1] 3 7\ndim(x)[1]## [1] 7\ndim(x)[2]## [1] 3\nnrow(x)## [1] 7\nncol(x)## [1] 3\nnrow(x)## [1] 7\nncol(x)## [1] 3\nmatrix(0, nrow = 5, ncol = 3) # 5 filas, 3 columnas, todo 0's##      [,1] [,2] [,3]\n## [1,]    0    0    0\n## [2,]    0    0    0\n## [3,]    0    0    0\n## [4,]    0    0    0\n## [5,]    0    0    0\nz <- matrix(1:15, ncol = 5) # Matriz con el vector 1:5 con 5 columnas (ergo 3 filas)\nz##      [,1] [,2] [,3] [,4] [,5]\n## [1,]    1    4    7   10   13\n## [2,]    2    5    8   11   14\n## [3,]    3    6    9   12   15\nclass(z) # Clase de la variable## [1] \"matrix\"\nx##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\nt(x) # Matriz transpuesta##         [,1]      [,2]      [,3]      [,4]  [,5]      [,6]  [,7]\n## edades    14        24        56        31    20        87    73\n## tlf       NA 683839390 621539732 618211286    NA 914727164    NA\n## cp     33007     28019     37005     18003 33091     25073 17140"},{"path":"datos.html","id":"apply-vs-bucles","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"6.2 Apply vs bucles","text":"Si programado en algún otro lenguaje, estarás echando en falta elementos como un (blabla) {...} else {...} (que los usaremos veces) o bucles y . Si es la primera que programas en algún lenguaje, dichas estructuras te las encontrarás programes en lo que programes:(condición) { código } else { código B }: si condición (por ejemplo, x == 1) es cierta, se ejecuta código ; si es falsa, se ejecuta código B.: bucle que permite repetir el mismo código un número fijo de veces (normalmente en función de un índice).: bucle que permite repetir el mismo código un número priori indeterminado de veces (solo pararía cuando la condición del se cumpliese).Si eres un programador avezado te estarás preguntando: ¿existen los bucles en R? Sí, sí existen. aquí un ejemplo: tras definir un vector de 0’s, para cada valor , se guardará en el lugar -ésimo el valor ^2.La razón por la que hemos usado aún bucles, e intentaremos evitarlos lo máximo posible, es porque en R son muy ineficientes en tiempo de ejecución. Vamos poner un ejemplo. Supongamos que de la matriz x queremos calcular la suma de cada fila (es decir, 7 valores) o la suma de cada columna (3 valores). Con bucles sería así.En el código anterior puedes ver como para acceder la fila -ésima de la matriz se usa el operador [, ] (dejando libre el índice de la columna), mientras que para acceder la columna j-ésima de la matriz se usa el operador [, j]. Para acceder al elemento (, j) se usa el operador [, j]. También habrás observado que, si escribes los bucles en tu script, tienen una flecha la izquierda para ser minimizados.La pregunta es: ¿hay una forma más eficiente de hacerlo?La respuesta: sí. La función apply() nos permite ejecutar una función por filas o por columnas.Como puedes observar, necesitas tres argmentos y otros opcionales: la matriz, el índice por el que operar (MARGIN = 1 por filas, MARGIN = 2 por columnas) y la función aplicar, amén de otros argumentos extras que pudiera necesitar la función.Veamos qué es más eficiente con el ya conocido paquete microbenchmark.¡El bucle nos tarda 50 veces más que el apply!CONSEJODi los bucles: casi siempre hay una forma mejor de hacerlo.","code":"\nv <- rep(0, 20) # Vector de 20 ceros\nfor (i in 1:20) { # Bucle en base a un índice i que va de 1 a 20\n\n  v[i] <- i^2 # En cada iteración guardamos el valor de i al cuadrado en el elemento i del vector v\n    \n}\nv##  [1]   1   4   9  16  25  36  49  64  81 100 121 144 169 196 225 256 289 324 361\n## [20] 400\nx##      edades       tlf    cp\n## [1,]     14        NA 33007\n## [2,]     24 683839390 28019\n## [3,]     56 621539732 37005\n## [4,]     31 618211286 18003\n## [5,]     20        NA 33091\n## [6,]     87 914727164 25073\n## [7,]     73        NA 17140\nsuma_por_filas <- rep(0, dim(x)[1]) # dim(x)[1] número de filas\nsuma_por_cols <- rep(0, dim(x)[2]) # dim(x)[2] número de columnas\nfor (i in 1:dim(x)[1]) { # Bucle recorriendo filas\n\n  suma_por_filas[i] <- sum(x[i, ], na.rm = TRUE) # Suma de la fila i, eliminando NA\n    \n}\nsuma_por_filas## [1]     33021 683867433 621576793 618229320     33111 914752324     17213\nfor (j in 1:dim(x)[2]) { # Bucle recorriendo filas\n\n  suma_por_cols[j] <- sum(x[, j], na.rm = TRUE) # Suma de la columna j, eliminando NA\n    \n}\nsuma_por_cols## [1]        305 2838317572     191338\n# Suma por filas (MARGIN = 1) quitando NA\nsuma_por_filas <- apply(x, MARGIN = 1, FUN = \"sum\", na.rm = TRUE)\nsuma_por_filas ## [1]     33021 683867433 621576793 618229320     33111 914752324     17213\n# Una función cualquiera por filas\noperacion_por_filas <- apply(x, MARGIN = 1, FUN = function(x) { sum(sqrt(2) - 2) })\noperacion_por_filas## [1] -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864 -0.5857864\n# Suma por columnas (MARGIN = 2) quitando NA\nsuma_por_cols <- apply(x, MARGIN = 2, FUN = \"sum\", na.rm = TRUE)\nsuma_por_cols##     edades        tlf         cp \n##        305 2838317572     191338\nmicrobenchmark::microbenchmark(for (i in 1:dim(x)[1]) {\n  suma_por_filas[i] <- sum(x[i, ], na.rm = TRUE)}, apply(x, MARGIN = 1, FUN = \"sum\", na.rm = TRUE), times = 1e2) # Comparamos tiempos de ejecución de ambas formas, y lo repetimos 100 veces para sacar tiempos medios## Unit: microseconds\n##                                                                           expr\n##  for (i in 1:dim(x)[1]) {     suma_por_filas[i] <- sum(x[i, ], na.rm = TRUE) }\n##                                apply(x, MARGIN = 1, FUN = \"sum\", na.rm = TRUE)\n##       min       lq       mean    median        uq      max neval cld\n##  1736.489 1876.028 2249.27925 2095.7445 2528.1610 5387.443   100   b\n##    21.926   27.016   39.18468   37.7845   47.7145  166.304   100  a"},{"path":"datos.html","id":"tablas-data.frames","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"6.3 Tablas: data.frames","text":"Además del nombre de las columnas que ha heredado la matriz x de la concatenación de las columnas que hemos realizado, podemos poner nombre los registros, por ejemplo, el nombre de las personas las que pertenece cada dato, definiendo una nueva variable con los nombres y concatenándola.¿visto lo que ha sucedido?Como una matriz SOLO puede tener un tipo de dato, al añadir una variable de tipo textos, ha convertido los números también texto poniéndole comillas: hemos roto la integridad de nuestro dato. Una forma de añadir nombre los registros, sin incluirlo como variable, es usando la función row.names(). ¿Qué sucede si realmente queremos añadir variables cuyos tipos sean distintos (¡ojo, pero con la misma longitud!)?Vamos crear nuevas variables de texto nombres y apellidos, un valor lógico casado y una fecha fecha_creacion (fecha de entrada en el sistema) para cada persona.Seguimos teniendo 7 registros, uno por persona pero ahora tenemos un popurrí de variables, de la misma longitud pero de tipos distintos:(edades, tlf, cp) son variables numéricas.(nombres, apellidos) son variables de texto.casado es una variable lógica.fecha_creacion de tipo fecha.¿Qué sucedería si yo intento mezclar todo en una matriz?Efectivamente: como en una matriz solo puede haber datos de un tipo, los números los convierte texto, las variables lógicas las convierte texto (TRUE es un valor lógico, \"TRUE\" es un texto, como \"Pepito\", sin significado lógico - booleano - de verdadero/falso) y las fechas las ha convertido texto (aunque las veas igual, ya son de tipo de fecha, son texto y podemos operar con ellas). aquí LA pregunta: ¿cómo juntar variables de distinto tipo, sin cambiar su naturaleza, como cuando juntamos datos en una tabla de excel?El formato de tabla de datos en R que vamos empezar usar se llama data.frame: una colección de variables de igual longitud pero cada una de un tipo distinto. Para crear un objeto de este tipo basta con usar la función data.frame(), pasándole como argumentos (separados por comas) las variables que queremos reunir, indicando en texto \"...\" el nombre de las columnas.¡TENEMOS NUESTRO PRIMER CONJUNTO DE DATOS!","code":"\nnombres <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\ncbind(nombres, x)##      nombres  edades tlf         cp     \n## [1,] \"Sonia\"  \"14\"   NA          \"33007\"\n## [2,] \"Carla\"  \"24\"   \"683839390\" \"28019\"\n## [3,] \"Pepito\" \"56\"   \"621539732\" \"37005\"\n## [4,] \"Carlos\" \"31\"   \"618211286\" \"18003\"\n## [5,] \"Lara\"   \"20\"   NA          \"33091\"\n## [6,] \"Sandra\" \"87\"   \"914727164\" \"25073\"\n## [7,] \"Javi\"   \"73\"   NA          \"17140\"\nrow.names(x) <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\nx##        edades       tlf    cp\n## Sonia      14        NA 33007\n## Carla      24 683839390 28019\n## Pepito     56 621539732 37005\n## Carlos     31 618211286 18003\n## Lara       20        NA 33091\n## Sandra     87 914727164 25073\n## Javi       73        NA 17140\n# Nombres\nnombres <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\n\n# Apellidos\napellidos <- c(\"Pérez\", \"González\", \"Fernández\", \"Martínez\", \"Liébana\", \"García\", \"Ortiz\")\n\n# Estado civil (no lo sabemos de una persona)\ncasado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)\n\n# Fecha de creación (fecha en el que esa persona entra en el sistema)\n# lo convertimos a tipo fecha\nfecha_creacion <- as.Date(c(\"2021-03-04\", \"2020-10-12\", \"1990-04-05\",\n                            \"2019-09-10\", \"2017-03-21\", \"2020-07-07\",\n                            \"2000-01-28\"))\n# Juntamos todo en una matriz (juntamos por columnas)\nx <- cbind(nombres, apellidos, edades, tlf, cp, casado, fecha_creacion)\nx##      nombres  apellidos   edades tlf         cp      casado  fecha_creacion\n## [1,] \"Sonia\"  \"Pérez\"     \"14\"   NA          \"33007\" \"TRUE\"  \"18690\"       \n## [2,] \"Carla\"  \"González\"  \"24\"   \"683839390\" \"28019\" \"FALSE\" \"18547\"       \n## [3,] \"Pepito\" \"Fernández\" \"56\"   \"621539732\" \"37005\" \"FALSE\" \"7399\"        \n## [4,] \"Carlos\" \"Martínez\"  \"31\"   \"618211286\" \"18003\" NA      \"18149\"       \n## [5,] \"Lara\"   \"Liébana\"   \"20\"   NA          \"33091\" \"TRUE\"  \"17246\"       \n## [6,] \"Sandra\" \"García\"    \"87\"   \"914727164\" \"25073\" \"FALSE\" \"18450\"       \n## [7,] \"Javi\"   \"Ortiz\"     \"73\"   NA          \"17140\" \"FALSE\" \"10984\"\n# Días entre la primera y el segundo elemento de fecha de creación\nfecha_creacion[1] - fecha_creacion[2]## Time difference of 143 days\n# Días entre primera y segunda fecha de creación pero tomándolo de nuestra matriz (columna 7, fila 1 y 2)\nx[1, 7] - x[2, 7]## Error in x[1, 7] - x[2, 7]: argumento no-numérico para operador binario\n# Creamos nuestro primer data.frame\ntabla <- data.frame(\"Nombre\" = nombres, \"Apellido\" = apellidos,\n                    \"Edad\" = edades, \"Teléfono\" = tlf,\n                    \"Código Postal\" = cp, \"Casado\" = casado,\n                    \"Fecha_de_creación\" = fecha_creacion)\ntabla##   Nombre  Apellido Edad  Teléfono Código.Postal Casado Fecha_de_creación\n## 1  Sonia     Pérez   14        NA         33007   TRUE        2021-03-04\n## 2  Carla  González   24 683839390         28019  FALSE        2020-10-12\n## 3 Pepito Fernández   56 621539732         37005  FALSE        1990-04-05\n## 4 Carlos  Martínez   31 618211286         18003     NA        2019-09-10\n## 5   Lara   Liébana   20        NA         33091   TRUE        2017-03-21\n## 6 Sandra    García   87 914727164         25073  FALSE        2020-07-07\n## 7   Javi     Ortiz   73        NA         17140  FALSE        2000-01-28"},{"path":"datos.html","id":"data.frames-selección-manual-de-columnas-y-filas","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"6.3.1 Data.frames: selección manual de columnas y filas","text":"Si tenemos un data.frame ya creado y queremos añadir una columna es tan simple como usar la función data.frame() que ya hemos visto para concatenar la columna. Si queremos acceder una columna, fila o elemento en concreto, los data.frame tienes las mismas ventajas que una matriz, así basta con usar los mismos operadores.Un data.frame solo tiene las ventajas de una matriz sino que también tiene las ventajas de una tabla de datos. Por ejemplo, podemos aceder las variables por el índice de columna que ocupan pero también por su nombre, poniendo el nombre de la tabla, el símbolo $ y con el tabulador nos aparecerá un menú de columnas elegir.\nImagen/gráfica 6.1: Menú desplegable de variables (columnas) de un data.frame.\nVolvamos nuestro script.Vamos crear un script nuevo en la caprta CODIGOS de nuestro proyecto que se llame primer_data_frame.R. En él vamos definir las variables que habíamos lanzado en consola, y vamos construir el mismo data.frame llamado tabla que teníamos pero en nuestro script.\nImagen/gráfica 6.2: Creando nuestro primer data.frame en el script.\n\nImagen/gráfica 6.3: Llamando nuestro script desde nuestro código principal.\nAdemás de dicho conjunto de datos, vamos instalar (sino lo hemos hecho nunca en este ordenador) un paquete muy útil en R llamado {datasets}. Los paquetes que vayamos necesitando los instalaremos y llamaremos al inicio del código principal.\nImagen/gráfica 6.4: Instalamos y cargamos los paquetes necesarios al principio de nuestro main.R.\nTras ello llamaremos nuestro script primer_data_frame.R desde nuestro código principal main.R y guardaremos el script con el source save activado para que se ejecute. Además de que ahora tenemos nuestro conjunto de datos tabla en nuestro panel de entorno, si escribimos datasets:: y pulsamos tabulador, se nos abre un desplegable con distintos conjuntos de datos para ser usados: el paquete datasets nos proporciona data.frames de prueba para que podamos usarlos en nuestros códigos según vamos aprendiendo.\nImagen/gráfica 6.5: Menú desplegable con los data.frame de prueba en datasets\nUna de las ventajas de los data.frame es que podemos visualizarlos como si fuera una tabla de Excel dentro de nuestro R con la función View(). Vamos visualizar solo el conjunto de datos tabla sino también el conjunto iris del paquete datasets: los data.frame nos permiten trabajar con ellos como bases de datos o como matrices, con las ventajas de ambos.\nImagen/gráfica 6.6: Menú desplegable con los data.frame de prueba en datasets\n En el caso de los data.frame tenemos además nuestro disposición una herramienta muy potente: la función subset() Dicha función nos va permitir seleccionar filas y columnas automáticamente, tomando de entrada los siguientes argumentosx: una tabla de entrada, un data.frame de entrada.subset: la condición lógica que queramos usar para seleccionar registros (filas).select: un vector que contenga el nombre de las columnas que queremos seleccionar (lo mejor solo queremos filtrar por filas pero quizás también por columnas).Por ejemplo, vamos seleccionar solo los nombres y apellidos de aquellas personas mayores de edad de nuestro conjunto de datos tabla, y del conjunto iris vamos extraer todos los registros en los que el largo del sépalo es mayor que 7.1, seleccionando solo las columnas de longitud de sépalo y la especie de la planta.Tabla 6.1: Paquetes mencionados hasta ahoraPaquete {tibble}En dicho paquete tienes más funciones para una gestión más ágil, eficiente y coherente de los data.frame. Las tablas en formato tibble (su clase será tbl_df) tiene 4 ventajas principales frente los ya vistos data.frame:Permite imprimir por consola la tabla con mayor información de las variables.Los datos de tipo caracter (cadenas de texto) son guardados como tal (y como factores, un tipo de dato que veremos más adelante).Los nombres de las columnas permanecen intactos.La función tibble() construye las variables secuencialmente, pudiendo hacer uso en la propia definición de variables recién definidas en dicha definición.Puedes consultar más funcionalidades en https://tibble.tidyverse.org/.Nombre de variablesLa función names() solo sirve para consultar los nombres de las variables de un data.frame sino también para cambiarlos nuestro gusto.","code":"\n# Añadimos una nueva columna con nº de hermanos/as\nhermanos <- c(0, 0, 1, 5, 2, 3, 0)\ntabla <- data.frame(tabla, hermanos)\ntabla##   Nombre  Apellido Edad  Teléfono Código.Postal Casado Fecha_de_creación\n## 1  Sonia     Pérez   14        NA         33007   TRUE        2021-03-04\n## 2  Carla  González   24 683839390         28019  FALSE        2020-10-12\n## 3 Pepito Fernández   56 621539732         37005  FALSE        1990-04-05\n## 4 Carlos  Martínez   31 618211286         18003     NA        2019-09-10\n## 5   Lara   Liébana   20        NA         33091   TRUE        2017-03-21\n## 6 Sandra    García   87 914727164         25073  FALSE        2020-07-07\n## 7   Javi     Ortiz   73        NA         17140  FALSE        2000-01-28\n##   hermanos\n## 1        0\n## 2        0\n## 3        1\n## 4        5\n## 5        2\n## 6        3\n## 7        0\n# Accedemos a la tercera columna\ntabla[, 3]## [1] 14 24 56 31 20 87 73\n# Accedemos a la quinta fila\ntabla[5, ]##   Nombre Apellido Edad Teléfono Código.Postal Casado Fecha_de_creación hermanos\n## 5   Lara  Liébana   20       NA         33091   TRUE        2017-03-21        2\n# Accedemos a la tercera variable del quinto registro\ntabla[5, 3]## [1] 20\n# Descripción: creación de nuestros primeros data.frame\n\n# Variables\nedades <- c(14, 24, 56, 31, 20, 87, 73) # vector numérico de longitud 7\ntlf <- c(NA, 683839390, 621539732, 618211286, NA, 914727164, NA)\ncp <- c(33007, 28019, 37005, 18003, 33091, 25073, 17140)\nnombres <- c(\"Sonia\", \"Carla\", \"Pepito\", \"Carlos\", \"Lara\", \"Sandra\", \"Javi\")\napellidos <- c(\"Pérez\", \"González\", \"Fernández\", \"Martínez\", \"Liébana\", \"García\", \"Ortiz\")\ncasado <- c(TRUE, FALSE, FALSE, NA, TRUE, FALSE, FALSE)\nfecha_creacion <-\n  as.Date(c(\"2021-03-04\", \"2020-10-12\", \"1990-04-05\", \"2019-09-10\",\n            \"2017-03-21\", \"2020-07-07\", \"2000-01-28\"))\nhermanos <- c(0, 0, 1, 5, 2, 3, 0)\n\n# Creamos el data.frame\ntabla <- data.frame(\"Nombre\" = nombres, \"Apellido\" = apellidos,\n                    \"Edad\" = edades, \"Teléfono\" = tlf, \"Código Postal\" = cp,\n                    \"Casado\" = casado, \"Fecha_de_creación\" = fecha_creacion)\ntabla <- data.frame(tabla, hermanos)\ntabla##   Nombre  Apellido Edad  Teléfono Código.Postal Casado Fecha_de_creación\n## 1  Sonia     Pérez   14        NA         33007   TRUE        2021-03-04\n## 2  Carla  González   24 683839390         28019  FALSE        2020-10-12\n## 3 Pepito Fernández   56 621539732         37005  FALSE        1990-04-05\n## 4 Carlos  Martínez   31 618211286         18003     NA        2019-09-10\n## 5   Lara   Liébana   20        NA         33091   TRUE        2017-03-21\n## 6 Sandra    García   87 914727164         25073  FALSE        2020-07-07\n## 7   Javi     Ortiz   73        NA         17140  FALSE        2000-01-28\n##   hermanos\n## 1        0\n## 2        0\n## 3        1\n## 4        5\n## 5        2\n## 6        3\n## 7        0\n# Paquetes necesarios\n# install.packages(\"datasets\") # Descomentar si nunca se ha instalado\nlibrary(datasets)\nView(iris)\nView(tabla)\nsubset(tabla, subset = Edad > 18, select = c(\"Nombre\", \"Apellido\"))##   Nombre  Apellido\n## 2  Carla  González\n## 3 Pepito Fernández\n## 4 Carlos  Martínez\n## 5   Lara   Liébana\n## 6 Sandra    García\n## 7   Javi     Ortiz\nsubset(iris, subset = Sepal.Length > 7.1, select = c(\"Sepal.Length\", \"Species\"))##     Sepal.Length   Species\n## 106          7.6 virginica\n## 108          7.3 virginica\n## 110          7.2 virginica\n## 118          7.7 virginica\n## 119          7.7 virginica\n## 123          7.7 virginica\n## 126          7.2 virginica\n## 130          7.2 virginica\n## 131          7.4 virginica\n## 132          7.9 virginica\n## 136          7.7 virginica\n# Consultamos nombres\nnames(tabla)## [1] \"Nombre\"            \"Apellido\"          \"Edad\"             \n## [4] \"Teléfono\"          \"Código.Postal\"     \"Casado\"           \n## [7] \"Fecha_de_creación\" \"hermanos\"\n# Cambiamos nombres\nnames(tabla) <- c(\"nombre_persona\", \"apellido_persona\", \"edad\", \"tlf\",\n                  \"cp\", \"casado\", \"f_creacion\")\ntabla##   nombre_persona apellido_persona edad       tlf    cp casado f_creacion NA\n## 1          Sonia            Pérez   14        NA 33007   TRUE 2021-03-04  0\n## 2          Carla         González   24 683839390 28019  FALSE 2020-10-12  0\n## 3         Pepito        Fernández   56 621539732 37005  FALSE 1990-04-05  1\n## 4         Carlos         Martínez   31 618211286 18003     NA 2019-09-10  5\n## 5           Lara          Liébana   20        NA 33091   TRUE 2017-03-21  2\n## 6         Sandra           García   87 914727164 25073  FALSE 2020-07-07  3\n## 7           Javi            Ortiz   73        NA 17140  FALSE 2000-01-28  0"},{"path":"datos.html","id":"ejercicios-2","chapter":"Capítulo 6 Datos estructurados: matrices y tablas","heading":"6.4 📝 Ejercicios","text":"Ejercicio 1: define una matriz x de ceros de 3 filas y 7 columnas.Solución: Ejercicio 2: tras definir la matriz x calcula su transpuesta y obtén sus dimensionesSolución: Ejercicio 3: calcula la suma de cada fila de la matriz matrix(1:12, nrow = 4) usando un bucle. Haz lo mismo evitando usar bucles.Solución: Ejercicio 4: del conjunto iris del paquete {datasets} obtén el nombre de las variables, y selecciona aquellas filas cuya variable Petal.Width sea distinta de 0.2, y quédate solo con las variables Sepal.Length, Sepal.Width y Species.Solución: Ejercicio 5: calcula el número de filas borradas del ejercicio anterior. Tras hacer todo ello, traduce castellano el nombre de las columnas del data.frame filtrado.Solución:","code":"\n# Matriz\nx <- matrix(0, nrow = 3, ncol = 7)\nx##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n## [1,]    0    0    0    0    0    0    0\n## [2,]    0    0    0    0    0    0    0\n## [3,]    0    0    0    0    0    0    0\n# Transpuesta\nt(x)##      [,1] [,2] [,3]\n## [1,]    0    0    0\n## [2,]    0    0    0\n## [3,]    0    0    0\n## [4,]    0    0    0\n## [5,]    0    0    0\n## [6,]    0    0    0\n## [7,]    0    0    0\n# Dimensiones transpuesta: pasa de ser 3x7 a 7x3\ndim(t(x))## [1] 7 3\nncol(t(x))## [1] 3\nnrow(t(x))## [1] 7\n# Matriz\nmatriz <- matrix(1:12, nrow = 4)\n\n# Con bucle (recorremos sus filas)\nsuma <- rep(0, nrow(matriz)) # Definimos un vector de 0's con tantos elementos como filas, donde iremos metiendo los valores de la suma\nfor (i in 1:nrow(matriz)) {\n  \n  suma[i] <- sum(matriz[i, ]) # Sumamos la fila i\n}\nsuma## [1] 15 18 21 24\n# Sin bucle (MARGIN = 1 ya que es una operación por filas)\nsuma <- apply(matriz, MARGIN = 1, FUN = \"sum\")\nsuma## [1] 15 18 21 24\n# Nombres de variables\nnames(iris)## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"\n# Filtramos filas\nfiltro_fila <- subset(iris, subset = Petal.Width != 0.2)\n\n# Filtramos columnas\nfiltro_col <- subset(filtro_fila,  select = c(\"Sepal.Length\", \"Sepal.Width\", \"Species\"))\n\n# Todo de una vez\nfiltro <- subset(iris, subset = Petal.Width != 0.2, select = c(\"Sepal.Length\", \"Sepal.Width\", \"Species\"))\nfiltro##     Sepal.Length Sepal.Width    Species\n## 6            5.4         3.9     setosa\n## 7            4.6         3.4     setosa\n## 10           4.9         3.1     setosa\n## 13           4.8         3.0     setosa\n## 14           4.3         3.0     setosa\n## 16           5.7         4.4     setosa\n## 17           5.4         3.9     setosa\n## 18           5.1         3.5     setosa\n## 19           5.7         3.8     setosa\n## 20           5.1         3.8     setosa\n## 22           5.1         3.7     setosa\n## 24           5.1         3.3     setosa\n## 27           5.0         3.4     setosa\n## 32           5.4         3.4     setosa\n## 33           5.2         4.1     setosa\n## 38           4.9         3.6     setosa\n## 41           5.0         3.5     setosa\n## 42           4.5         2.3     setosa\n## 44           5.0         3.5     setosa\n## 45           5.1         3.8     setosa\n## 46           4.8         3.0     setosa\n## 51           7.0         3.2 versicolor\n## 52           6.4         3.2 versicolor\n## 53           6.9         3.1 versicolor\n## 54           5.5         2.3 versicolor\n## 55           6.5         2.8 versicolor\n## 56           5.7         2.8 versicolor\n## 57           6.3         3.3 versicolor\n## 58           4.9         2.4 versicolor\n## 59           6.6         2.9 versicolor\n## 60           5.2         2.7 versicolor\n## 61           5.0         2.0 versicolor\n## 62           5.9         3.0 versicolor\n## 63           6.0         2.2 versicolor\n## 64           6.1         2.9 versicolor\n## 65           5.6         2.9 versicolor\n## 66           6.7         3.1 versicolor\n## 67           5.6         3.0 versicolor\n## 68           5.8         2.7 versicolor\n## 69           6.2         2.2 versicolor\n## 70           5.6         2.5 versicolor\n## 71           5.9         3.2 versicolor\n## 72           6.1         2.8 versicolor\n## 73           6.3         2.5 versicolor\n## 74           6.1         2.8 versicolor\n## 75           6.4         2.9 versicolor\n## 76           6.6         3.0 versicolor\n## 77           6.8         2.8 versicolor\n## 78           6.7         3.0 versicolor\n## 79           6.0         2.9 versicolor\n## 80           5.7         2.6 versicolor\n## 81           5.5         2.4 versicolor\n## 82           5.5         2.4 versicolor\n## 83           5.8         2.7 versicolor\n## 84           6.0         2.7 versicolor\n## 85           5.4         3.0 versicolor\n## 86           6.0         3.4 versicolor\n## 87           6.7         3.1 versicolor\n## 88           6.3         2.3 versicolor\n## 89           5.6         3.0 versicolor\n## 90           5.5         2.5 versicolor\n## 91           5.5         2.6 versicolor\n## 92           6.1         3.0 versicolor\n## 93           5.8         2.6 versicolor\n## 94           5.0         2.3 versicolor\n## 95           5.6         2.7 versicolor\n## 96           5.7         3.0 versicolor\n## 97           5.7         2.9 versicolor\n## 98           6.2         2.9 versicolor\n## 99           5.1         2.5 versicolor\n## 100          5.7         2.8 versicolor\n## 101          6.3         3.3  virginica\n## 102          5.8         2.7  virginica\n## 103          7.1         3.0  virginica\n## 104          6.3         2.9  virginica\n## 105          6.5         3.0  virginica\n## 106          7.6         3.0  virginica\n## 107          4.9         2.5  virginica\n## 108          7.3         2.9  virginica\n## 109          6.7         2.5  virginica\n## 110          7.2         3.6  virginica\n## 111          6.5         3.2  virginica\n## 112          6.4         2.7  virginica\n## 113          6.8         3.0  virginica\n## 114          5.7         2.5  virginica\n## 115          5.8         2.8  virginica\n## 116          6.4         3.2  virginica\n## 117          6.5         3.0  virginica\n## 118          7.7         3.8  virginica\n## 119          7.7         2.6  virginica\n## 120          6.0         2.2  virginica\n## 121          6.9         3.2  virginica\n## 122          5.6         2.8  virginica\n## 123          7.7         2.8  virginica\n## 124          6.3         2.7  virginica\n## 125          6.7         3.3  virginica\n## 126          7.2         3.2  virginica\n## 127          6.2         2.8  virginica\n## 128          6.1         3.0  virginica\n## 129          6.4         2.8  virginica\n## 130          7.2         3.0  virginica\n## 131          7.4         2.8  virginica\n## 132          7.9         3.8  virginica\n## 133          6.4         2.8  virginica\n## 134          6.3         2.8  virginica\n## 135          6.1         2.6  virginica\n## 136          7.7         3.0  virginica\n## 137          6.3         3.4  virginica\n## 138          6.4         3.1  virginica\n## 139          6.0         3.0  virginica\n## 140          6.9         3.1  virginica\n## 141          6.7         3.1  virginica\n## 142          6.9         3.1  virginica\n## 143          5.8         2.7  virginica\n## 144          6.8         3.2  virginica\n## 145          6.7         3.3  virginica\n## 146          6.7         3.0  virginica\n## 147          6.3         2.5  virginica\n## 148          6.5         3.0  virginica\n## 149          6.2         3.4  virginica\n## 150          5.9         3.0  virginica\n# Filas borradas\nnrow(iris) - nrow(filtro)## [1] 29\n# Cambiamos nombres a castellano del conjunto filtrado\nnames(filtro) <- c(\"longitud_sepalo\", \"anchura_sepalo\", \"especies\")"},{"path":"importar_exportar.html","id":"importar_exportar","chapter":"Capítulo 7 Importando/exportando","heading":"Capítulo 7 Importando/exportando","text":"Hemos aprendido crear nuestros propios datos pero la mayoría de veces los cargaremos de distintos archivos, fuentes, etc. Vamos ver las 4 formas más comunes de importar (cargar) datos","code":""},{"path":"importar_exportar.html","id":"importación-de-datos","chapter":"Capítulo 7 Importando/exportando","heading":"7.1 Importación de datos","text":"Las 4 formas más comunes de importar (cargar) datos son:desde un archivo propio de R (extensión .RData).desde un archivo separado por comas (un archivo .csv).desde un excel (archivo .xlsx).desde un enlace de internet.","code":""},{"path":"importar_exportar.html","id":"archivo-.rdata","chapter":"Capítulo 7 Importando/exportando","heading":"7.1.1 Archivo .RData","text":"La forma más sencilla de guardar datos y variables en R, y que además ocupa menos espacio en nuestro disco duro, es guardarlo en archivos propios que tiene R como son los archivos con extensiones .rda y .RData.Es recomendable tener los datos en la misma carpeta del proyecto pero una carpeta separada, ya que podemos tener muchos archivos y así mezclamos dichos ficheros con los códigos que escirbamos. En la carpeta DATOS del proyecto tenemos 4 archivos .RData: coches.RData, panel_vacunas_ccaa.RData, panel_vacunas_fecha.RData y panel_variables.RData. ¿Cómo cargar archivos .RData?Muy sencillo: como son ficheros nativos de R, basta con usar la función de carga load(), y dentro la ruta de los archivos.\nImagen/gráfica 7.1: Importación de ficheros de extensión .RData.\nComo ves en la imagen 7.1, en el panel de entorno de la parte superior derecha ahora tendremos 4 data.frames que antes teníamos. Un función muy útil es head(), con argumento el nombre de un data.frame, que nos permite visualizar las primeras columnas.","code":"\n# Al fijar directorio de trabajo, no necesitamos toda la ruta, solo \"./\" y la ruta dentro de la carpeta del proyecto\nload(\"./DATOS/coches.RData\") \nload(\"./DATOS/panel_vacunas_ccaa.RData\")\nload(\"./DATOS/panel_vacunas_fecha.RData\")\nload(\"./DATOS/panel_variables.RData\")\n# Ver las primeras filas de la tabla que guarda distintos modelos de coche y características\nhead(coches)##                    consumo cilindrada     peso  potencia   tiempo\n## Mazda RX4         11.20069   2621.936 1188.411 111.52570 40.91298\n## Mazda RX4 Wag     11.20069   2621.936 1304.077 111.52570 42.30491\n## Datsun 710        10.31643   1769.807 1052.333  94.28991 46.25702\n## Hornet 4 Drive    10.99134   4227.872 1458.298 111.52570 48.32006\n## Hornet Sportabout 12.57832   5899.356 1560.356 177.42725 42.30491\n## Valiant           12.99528   3687.097 1569.428 106.45635 50.25883\n##                                motor transmision ncyl ncarb ngear\n## Mazda RX4             cilindros en V      Manual    6     4     4\n## Mazda RX4 Wag         cilindros en V      Manual    6     4     4\n## Datsun 710        cilindros en serie      Manual    4     1     4\n## Hornet 4 Drive    cilindros en serie  Automática    6     1     3\n## Hornet Sportabout     cilindros en V  Automática    8     2     3\n## Valiant           cilindros en serie  Automática    6     1     3"},{"path":"importar_exportar.html","id":"archivo-.csv","chapter":"Capítulo 7 Importando/exportando","heading":"7.1.2 Archivo .csv","text":"Otra opción de importación habitual son los archivos .csv (comma separated values): son archivos separados por comas (u otro caracter como puntos, puntos y comas, o tabuladores). En apariencia cuando los abrimos en el ordenador son como un Excel (ya que los abre el Excel), pero ocupan mucho menos que un Excel y su lectura es universal (independiente de tener instalado o el Excel) ya que son archivos de texto sin formato.Para leer un archivo .csv basta con usar la función read_csv() del paquete readr y la mayoría de las veces basta indicarle la ruta del archivo para su lectura (argumento file).Tabla 7.1: Paquetes mencionados hasta ahora\nImagen/gráfica 7.2: Paquete readr.\nYa tenemos nuestro archivo .csv cargado y además en formato tibble. Como hemos mentado anteriormente, las tablas en formato tibble son una especie particular de tablas data.frame con una gestión más eficiente.","code":"\ninstall.packages(\"readr\")\nlibrary(readr)\nvacunas_esp <- read_csv(file = \"./DATOS/datos_ES.csv\")\nhead(vacunas_esp)## # A tibble: 6 × 71\n##   fechas     ISO   poblacion porc_pobl_total poblacion_mayor_… porc_pobl_total_…\n##   <date>     <chr>     <dbl>           <dbl>             <dbl>             <dbl>\n## 1 2021-01-05 ES     47450795             100          40129822               100\n## 2 2021-01-06 ES     47450795             100          40129822               100\n## 3 2021-01-07 ES     47450795             100          40129822               100\n## 4 2021-01-08 ES     47450795             100          40129822               100\n## 5 2021-01-09 ES     47450795             100          40129822               100\n## 6 2021-01-10 ES     47450795             100          40129822               100\n## # … with 65 more variables: dosis_entrega_pfizer <dbl>,\n## #   dosis_entrega_astra <dbl>, dosis_entrega_moderna <dbl>,\n## #   dosis_entrega_janssen <dbl>, dosis_entrega <dbl>,\n## #   dosis_entrega_100hab <dbl>, porc_entregadas_sobre_total <dbl>,\n## #   dosis_diarias_entrega_pfizer <dbl>, dosis_diarias_entrega_astra <dbl>,\n## #   dosis_diarias_entrega_moderna <dbl>, dosis_diarias_entrega <dbl>,\n## #   dosis_7D_entrega_pfizer <dbl>, dosis_7D_entrega_astra <dbl>, …\nvacunas_esp[1:5, 1:7] # Primeras filas y columnas## # A tibble: 5 × 7\n##   fechas     ISO   poblacion porc_pobl_total poblacion_mayor_… porc_pobl_total_…\n##   <date>     <chr>     <dbl>           <dbl>             <dbl>             <dbl>\n## 1 2021-01-05 ES     47450795             100          40129822               100\n## 2 2021-01-06 ES     47450795             100          40129822               100\n## 3 2021-01-07 ES     47450795             100          40129822               100\n## 4 2021-01-08 ES     47450795             100          40129822               100\n## 5 2021-01-09 ES     47450795             100          40129822               100\n## # … with 1 more variable: dosis_entrega_pfizer <dbl>"},{"path":"importar_exportar.html","id":"archivo-.xlsx","chapter":"Capítulo 7 Importando/exportando","heading":"7.1.3 Archivo .xlsx","text":"Muchas veces tendremos un .csv (por desgracia) y nos tocará leer desde un excel. Para ello deberemos instalar (la primera vez) y cargar el paquete readxl que nos permitirá usar funciones para cargar archivos .xls (la función read_xls()) y archivos .xlsx (la función read_xlsx()). Además del argumento path con la ruta del archivo, podemos en el argumento sheet indicarle la hoja de Excel leer (en caso de tener varias).CONSEJO: entorno tidyverseUna de las herramientas más potentes en R es el conjunto de paquetes tidyverse: un entorno de paquetes que nos permite una gestión ágil y eficiente de nuestros conjuntos de datos. Aunque su uso profundo corresponde un futuro curso, veamos una función muy útil del paquete dplyr (incluido en tidyverse) para visualizar un resumen de nuestros datos.Tabla 7.2: Paquetes mencionados hasta ahora","code":"\ninstall.packages(\"readxl\")\nlibrary(readxl)\nboston <- read_xlsx(path = \"./DATOS/Boston.xlsx\")\nhead(boston)## # A tibble: 6 × 14\n##      crim    zn indus  chas   nox    rm   age   dis   rad   tax ptratio black\n##     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>   <dbl> <dbl>\n## 1 0.00632    18  2.31     0 0.538  6.58  65.2  4.09     1   296    15.3  397.\n## 2 0.0273      0  7.07     0 0.469  6.42  78.9  4.97     2   242    17.8  397.\n## 3 0.0273      0  7.07     0 0.469  7.18  61.1  4.97     2   242    17.8  393.\n## 4 0.0324      0  2.18     0 0.458  7.00  45.8  6.06     3   222    18.7  395.\n## 5 0.0690      0  2.18     0 0.458  7.15  54.2  6.06     3   222    18.7  397.\n## 6 0.0298      0  2.18     0 0.458  6.43  58.7  6.06     3   222    18.7  394.\n## # … with 2 more variables: lstat <dbl>, medv <dbl>\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\nglimpse(boston)# Resumen por columnas## Rows: 506\n## Columns: 14\n## $ crim    <dbl> 0.00632, 0.02731, 0.02729, 0.03237, 0.06905, 0.02985, 0.08829,…\n## $ zn      <dbl> 18.0, 0.0, 0.0, 0.0, 0.0, 0.0, 12.5, 12.5, 12.5, 12.5, 12.5, 1…\n## $ indus   <dbl> 2.31, 7.07, 7.07, 2.18, 2.18, 2.18, 7.87, 7.87, 7.87, 7.87, 7.…\n## $ chas    <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n## $ nox     <dbl> 0.538, 0.469, 0.469, 0.458, 0.458, 0.458, 0.524, 0.524, 0.524,…\n## $ rm      <dbl> 6.575, 6.421, 7.185, 6.998, 7.147, 6.430, 6.012, 6.172, 5.631,…\n## $ age     <dbl> 65.2, 78.9, 61.1, 45.8, 54.2, 58.7, 66.6, 96.1, 100.0, 85.9, 9…\n## $ dis     <dbl> 4.0900, 4.9671, 4.9671, 6.0622, 6.0622, 6.0622, 5.5605, 5.9505…\n## $ rad     <dbl> 1, 2, 2, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,…\n## $ tax     <dbl> 296, 242, 242, 222, 222, 222, 311, 311, 311, 311, 311, 311, 31…\n## $ ptratio <dbl> 15.3, 17.8, 17.8, 18.7, 18.7, 18.7, 15.2, 15.2, 15.2, 15.2, 15…\n## $ black   <dbl> 396.90, 396.90, 392.83, 394.63, 396.90, 394.12, 395.60, 396.90…\n## $ lstat   <dbl> 4.98, 9.14, 4.03, 2.94, 5.33, 5.21, 12.43, 19.15, 29.93, 17.10…\n## $ medv    <dbl> 24.0, 21.6, 34.7, 33.4, 36.2, 28.7, 22.9, 27.1, 16.5, 18.9, 15…"},{"path":"importar_exportar.html","id":"desde-web","chapter":"Capítulo 7 Importando/exportando","heading":"7.1.4 Desde web","text":"Por último, muchas veces querremos cargar archivos colgados en la web que, aunque al descargarlos son .csv o .xlsx, son archivos dinámicos que sabemos que van ir cambiando, como por ejemplo los datos de casos covid, hospitalizados, ingresos UCI y fallecidos, de la página del ISCIII https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos.\nImagen/gráfica 7.3: Archivos de la pandemia en el ISCIII.\nEsos archivos cambian cada día, por lo que para visualizarlos, analizarlos o guardarlos cada día, tendríamos que, cada día, entrar de forma manual la página y bajarnos el archivo. O …R nos permite leer archivos subidos en una web, dándole la función de lectura el enlace del archivo en lugar de la ruta local de nuestro ordenador (para averiguar el enlace, basta con clickar botón derecho en la web y seleccionar «copiar dirección de enlace»)Mientras el enlace web cambie, cada vez que ejecutemos esa orden en nuestro código tendremos en datos_ISCIII el último archivo actualizado que haya, sea el que sea, sin tener que descargarlo de forma manual, ¡y sin necesidad de guardarlo en nuestro local, solo en la memoria virtual de nuestra sesión de R!","code":"\ndatos_ISCIII <- read_csv(file = \"https://cnecovid.isciii.es/covid19/resources/casos_hosp_uci_def_sexo_edad_provres.csv\")\nhead(datos_ISCIII)## # A tibble: 6 × 8\n##   provincia_iso sexo  grupo_edad fecha      num_casos num_hosp num_uci num_def\n##   <chr>         <chr> <chr>      <date>         <dbl>    <dbl>   <dbl>   <dbl>\n## 1 A             H     0-9        2020-01-01         0        0       0       0\n## 2 A             H     10-19      2020-01-01         0        0       0       0\n## 3 A             H     20-29      2020-01-01         0        0       0       0\n## 4 A             H     30-39      2020-01-01         0        0       0       0\n## 5 A             H     40-49      2020-01-01         0        0       0       0\n## 6 A             H     50-59      2020-01-01         0        0       0       0"},{"path":"importar_exportar.html","id":"exportación-de-datos","chapter":"Capítulo 7 Importando/exportando","heading":"7.2 Exportación de datos","text":"Aunque se puede exportar en cualquier formato que puedas importar, vamos ver las dos formas más útiles y eficientes de exportar datos en R:fichero .RData.fichero .csv (obviaremos la exportación Excel porque un .csv ya es posible abrirlo con dicho engendro del demonio).","code":""},{"path":"importar_exportar.html","id":"guardar-en-.rdata","chapter":"Capítulo 7 Importando/exportando","heading":"7.2.1 Guardar en .RData","text":"La exportación en fichero .RData es la opción más recomendable si tú o tu equipo solo trabajáis con R, es la opción nativa de fichero, para que su importación sea tan sencilla como una función load(). Para exportar en R.Data basta con uses la función save(), indícandole lo que quieres guardar y la ruta donde quieres guardarlo.Es importante entender que la principal ventaja de exportar un fichero .RData es que se está portando una tabla, o un fichero tabulado con un formato de filas y columnas: estás exportando cualquier cosa, cualquier variable de R, con la naturaleza de esa variable intacta, sin necesidad de pasarlo otro formato.Para tenerlo organizado, la orden anterior está hecha habiendo creado en nuestra carpeta del proyecto una carpeta EXPORTAR para guardar lo que vayamos exportando. Ese fichero solo podrá ser abierto por R, pero cuando lo cargemos, tendremos la variable nombres tal cual la hemos guardado.","code":"\n# Exportamos en .RData la variable nombres \nsave(nombres, file = \"./EXPORTAR/nombres.RData\")"},{"path":"importar_exportar.html","id":"guardar-en-.csv","chapter":"Capítulo 7 Importando/exportando","heading":"7.2.2 Guardar en .csv","text":"siempre trabajamos en R y veces necesitamos una exportación de un data.frame o una tabla que podamos abrir en nuestra ordenador, ya sea para explicársela alguien o para enviársela otra persona. Para ello exportaremos en .csv, un fichero sin formato, y que es capaz de ser abierto por todo tipo de hojas de cálculo: basta que usemos la función write.csv() del paquete readr.Paquete rvestEn dicho paquete tienes más funciones para una lectura directamente de una página web (desde un documento, desde la propia página web, como si estuvieras navegando en ella). Ver https://github.com/tidyverse/rvest.Tabla 7.3: Paquetes mencionados hasta ahoraCONSEJO: secciones en el códigoLos comentarios solo sirven para documentar el código sino que además pueden servirnos para construir secciones de código. Prueba escribir un comentario con varias ###############: ¿ves la flecha que te aparece en la parte izquierda? Sirve para minimizar o maximizar trozos de código, de forma que tu código aún más limpio.\nImagen/gráfica 7.4: Secciones en el código.\nLíneas de código en los erroresDado que los errores del código nos vendrán referenciados en la consola por el número de línea donde fueron detectados, puede sernos muy útil mostrar dichos números en la barra lateral izquierda, yendo Tools << Global Options << Code << Display << Show line numbers\nImagen/gráfica 7.5: Líneas de código.\nCONSEJO: Margen derecho en la ventana de scriptsAunque afecte nuestro código escribir todo en una línea sin saltos de línea, somos bárbaros/. ¿Por qué cuadno escribes en un Word lo haces en formato vertical pero cuando programas pones todas las órdenes seguidas? Recuerda que la legibilidad de tu código solo te ahorrará tiempo sino que te hará programar mejor. ¿Cómo podemos fijar un margen imaginario para nosotros ser quienes demos al ENTER? Yendo Tools << Global Options << Code << Display << Show margin (es un margen imaginario para ser nosotros quienes lo hagamos efectivo, R le da igual)\nImagen/gráfica 7.6: Margen derecho.\n","code":"\n# Exportamos en .csv el data.frame tabla\nwrite_csv(tabla, file = \"./EXPORTAR/tabla.csv\")"},{"path":"otros_datos.html","id":"otros_datos","chapter":"Capítulo 8 Listas y factores","heading":"Capítulo 8 Listas y factores","text":"Veamos dos tipos de datos muy particulares más allá de vectores, matrices y data.frames.","code":""},{"path":"otros_datos.html","id":"listas","chapter":"Capítulo 8 Listas y factores","heading":"8.1 Listas","text":"Probablemente las listas sea uno de los tipos de datos más importantes en R ya que permiten almacenar colecciones de variables de diferente tipo (ya lo hacían los data.frames) pero también de diferente longitud, y con estructuras totalmente heterógeneas, de ahí que sea el formato de salida de muchísimas funciones de R que te devuelven la vez un cadena de texto, un vector de números o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro su vez otra lista).Tabla 8.1: Tipos de datos mencionados hasta ahoraVamos crear nuestra primera lista.Hemos creado una lista de 4 elementos:nacimiento: una fecha.notas_insti: un data.frame.teléfonos: vector de números.nombre_padres: vector de texto.Una lista es una varible que en un primer nivel solo tiene una dimensión por lo que si quieres saber cuantos elementos tiene debes ejecutar la función length().Para acceder un elemento de la lista tenemos dos opciones:Acceder por índice: con el operador [[]] accedemos al elemento -ésimo de la lista.Acceder por índice: con el operador [[]] accedemos al elemento -ésimo de la lista.Acceder por nombre: con el operador $nombre_elemento accedemos al elemento cuyo nombre sea nombre_elemento.Acceder por nombre: con el operador $nombre_elemento accedemos al elemento cuyo nombre sea nombre_elemento.Si queremos acceder varios elementos la vez de la lista deberemos usar el operador [].Como hemos comentado, también podemos aplicar la recursividad y hacer listas con otras listas dentro, de forma que para acceder cada nivel deberemos usar el operador [[]].Un ejemplo de la utilidad de las listas la tenemos en los archivos R.Data de vacunas que hemos cargado en nuestro script. Con names(panel_vacunas) podemos ver que elementos contiene en el primer nivel.Cada elemento de la lista es un data.frame de una comunidad autonónoma, que su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): ¡nos permite guardar «datos tridimensionales»!.El acceso lo podemos realizar por orden que ocupa en la lista pero también de forma intuitiva con $ y el código ISO de la comunidad autónoma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, está guardada la información de cada variable (columna) y cada comunidad (fila).Operaciones aritméticas con listasUna lista se puede vectorizar de forma inmediata, por lo cualquier operación aritmética aplicada una lista dará error (para ello está disponible la función lapply(), cuyo uso corresponde otros cursos más avanzados).","code":"\n# Fecha de nacimiento\nfecha_nacimiento <- as.Date(\"1989-09-10\")\n\n# Notas de asignaturas en primer y segundo parcial\nnotas <- data.frame(\"biología\" = c(5, 7), \"física\" = c(4, 5),\n                    \"matemáticas\" = c(8, 9.5))\nrow.names(notas) <- # Nombre a las filas\n  c(\"primer_parcial\", \"segundo_parcial\")\n\n# Números de teléfono\ntlf <- c(\"914719567\", \"617920765\", \"716505013\")\n\n# Nombres\npadres <- c(\"Juan\", \"Julia\")\n\n# Guardamos TODO en una lista (con nombres de cada elemento)\ndatos <- list(\"nacimiento\" = fecha_nacimiento,\n              \"notas_insti\" = notas, \"teléfonos\" = tlf,\n              \"nombre_padres\" = padres)\ndatos## $nacimiento\n## [1] \"1989-09-10\"\n## \n## $notas_insti\n##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\n## \n## $teléfonos\n## [1] \"914719567\" \"617920765\" \"716505013\"\n## \n## $nombre_padres\n## [1] \"Juan\"  \"Julia\"\nnames(datos)## [1] \"nacimiento\"    \"notas_insti\"   \"teléfonos\"     \"nombre_padres\"\ndim(datos) # devolverá NULL al no tener dos dimensiones## NULL\nlength(datos)## [1] 4\nclass(datos) # de tipo lista## [1] \"list\"\ndatos[[1]]## [1] \"1989-09-10\"\ndatos$nacimiento## [1] \"1989-09-10\"\ndatos[[2]]##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\ndatos$notas_insti##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\ndatos[1:2]## $nacimiento\n## [1] \"1989-09-10\"\n## \n## $notas_insti\n##                 biología física matemáticas\n## primer_parcial         5      4         8.0\n## segundo_parcial        7      5         9.5\nlista_de_listas <- list(\"lista_1\" = datos[3:4], \"lista_2\" = datos[1:2])\nnames(lista_de_listas) # Nombres de los elementos del primer nivel## [1] \"lista_1\" \"lista_2\"\nnames(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista## [1] \"teléfonos\"     \"nombre_padres\"\nlista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior## [1] \"914719567\" \"617920765\" \"716505013\"\nnames(panel_vacunas)##  [1] \"AN\"   \"AR\"   \"AS\"   \"IB\"   \"CN\"   \"CB\"   \"CL\"   \"CM\"   \"CT\"   \"VC\"  \n## [11] \"EX\"   \"GA\"   \"RI\"   \"MD\"   \"MC\"   \"NC\"   \"PV\"   \"CE\"   \"ML\"   \"FFAA\"\n## [21] \"ES\"\nclass(panel_vacunas$ES)## [1] \"data.frame\"\nnames(panel_vacunas$ES)##  [1] \"fechas\"                              \n##  [2] \"ISO\"                                 \n##  [3] \"poblacion\"                           \n##  [4] \"porc_pobl_total\"                     \n##  [5] \"poblacion_mayor_16a\"                 \n##  [6] \"porc_pobl_total_mayor_16a\"           \n##  [7] \"dosis_entrega_pfizer\"                \n##  [8] \"dosis_entrega_astra\"                 \n##  [9] \"dosis_entrega_moderna\"               \n## [10] \"dosis_entrega_janssen\"               \n## [11] \"dosis_entrega\"                       \n## [12] \"dosis_entrega_100hab\"                \n## [13] \"porc_entregadas_sobre_total\"         \n## [14] \"dosis_diarias_entrega_pfizer\"        \n## [15] \"dosis_diarias_entrega_astra\"         \n## [16] \"dosis_diarias_entrega_moderna\"       \n## [17] \"dosis_diarias_entrega\"               \n## [18] \"dosis_7D_entrega_pfizer\"             \n## [19] \"dosis_7D_entrega_astra\"              \n## [20] \"dosis_7D_entrega_moderna\"            \n## [21] \"dosis_7D_entrega\"                    \n## [22] \"dosis_7D_entrega_100hab\"             \n## [23] \"dosis_admin\"                         \n## [24] \"dosis_primera\"                       \n## [25] \"dosis_pauta_completa\"                \n## [26] \"dosis_admin_100hab\"                  \n## [27] \"porc_admin_sobre_ccaa\"               \n## [28] \"porc_admin_vs_total\"                 \n## [29] \"dosis_diarias_admin\"                 \n## [30] \"dosis_diarias_admin_100hab\"          \n## [31] \"crec_diario_dosis_admin\"             \n## [32] \"dosis_diarias_primera\"               \n## [33] \"dosis_diarias_segunda\"               \n## [34] \"dosis_7D_admin\"                      \n## [35] \"dosis_7D_admin_100hab\"               \n## [36] \"crec_7D_dosis_admin\"                 \n## [37] \"porc_admin_vs_total_7D\"              \n## [38] \"personas_vacunadas\"                  \n## [39] \"personas_pauta_completa\"             \n## [40] \"personas_1dosis\"                     \n## [41] \"porc_personas_vacunadas\"             \n## [42] \"porc_personas_pauta_completa\"        \n## [43] \"porc_personas_vacunadas_16a\"         \n## [44] \"porc_personas_pauta_completa_16a\"    \n## [45] \"personas_vacunadas_diarias\"          \n## [46] \"personas_pauta_completa_diarias\"     \n## [47] \"porc_personas_vacunadas_diarias\"     \n## [48] \"porc_personas_pauta_completa_diarias\"\n## [49] \"personas_vacunadas_7D\"               \n## [50] \"personas_pauta_completa_7D\"          \n## [51] \"porc_personas_vacunadas_7D\"          \n## [52] \"porc_personas_pauta_completa_7D\"     \n## [53] \"porc_personas_vacunadas_16a_7D\"      \n## [54] \"porc_personas_pauta_completa_16a_7D\" \n## [55] \"crec_diario_personas_vacunadas\"      \n## [56] \"crec_7D_personas_vacunadas\"          \n## [57] \"crec_diario_personas_pauta_completa\" \n## [58] \"crec_7D_personas_pauta_completa\"     \n## [59] \"desv_porc_admin_vs_total\"            \n## [60] \"desv_dosis_entrega\"                  \n## [61] \"desv_porc_personas_vacunadas\"        \n## [62] \"desv_porc_personas_pauta_completa\"   \n## [63] \"fecha_30vacunados_ritmo7D\"           \n## [64] \"fecha_50vacunados_ritmo7D\"           \n## [65] \"fecha_70vacunados_ritmo7D\"           \n## [66] \"fecha_30inmunizados_ritmo7D\"         \n## [67] \"fecha_50inmunizados_ritmo7D\"         \n## [68] \"fecha_70inmunizados_ritmo7D\"         \n## [69] \"fecha_30inmunizados_16a_ritmo7D\"     \n## [70] \"fecha_50inmunizados_16a_ritmo7D\"     \n## [71] \"fecha_70inmunizados_16a_ritmo7D\"\nhead(panel_vacunas$ES[, 1:5])##        fechas ISO poblacion porc_pobl_total poblacion_mayor_16a\n## 1  2021-01-05  ES  47450795             100            40129822\n## 2  2021-01-06  ES  47450795             100            40129822\n## 21 2021-01-07  ES  47450795             100            40129822\n## 3  2021-01-08  ES  47450795             100            40129822\n## 11 2021-01-09  ES  47450795             100            40129822\n## 12 2021-01-10  ES  47450795             100            40129822\nnames(panel_vacunas_fecha)##   [1] \"2021-01-05\" \"2021-01-06\" \"2021-01-07\" \"2021-01-08\" \"2021-01-09\"\n##   [6] \"2021-01-10\" \"2021-01-11\" \"2021-01-12\" \"2021-01-13\" \"2021-01-14\"\n##  [11] \"2021-01-15\" \"2021-01-16\" \"2021-01-17\" \"2021-01-18\" \"2021-01-19\"\n##  [16] \"2021-01-20\" \"2021-01-21\" \"2021-01-22\" \"2021-01-23\" \"2021-01-24\"\n##  [21] \"2021-01-25\" \"2021-01-26\" \"2021-01-27\" \"2021-01-28\" \"2021-01-29\"\n##  [26] \"2021-01-30\" \"2021-01-31\" \"2021-02-01\" \"2021-02-02\" \"2021-02-03\"\n##  [31] \"2021-02-04\" \"2021-02-05\" \"2021-02-06\" \"2021-02-07\" \"2021-02-08\"\n##  [36] \"2021-02-09\" \"2021-02-10\" \"2021-02-11\" \"2021-02-12\" \"2021-02-13\"\n##  [41] \"2021-02-14\" \"2021-02-15\" \"2021-02-16\" \"2021-02-17\" \"2021-02-18\"\n##  [46] \"2021-02-19\" \"2021-02-20\" \"2021-02-21\" \"2021-02-22\" \"2021-02-23\"\n##  [51] \"2021-02-24\" \"2021-02-25\" \"2021-02-26\" \"2021-02-27\" \"2021-02-28\"\n##  [56] \"2021-03-01\" \"2021-03-02\" \"2021-03-03\" \"2021-03-04\" \"2021-03-05\"\n##  [61] \"2021-03-06\" \"2021-03-07\" \"2021-03-08\" \"2021-03-09\" \"2021-03-10\"\n##  [66] \"2021-03-11\" \"2021-03-12\" \"2021-03-13\" \"2021-03-14\" \"2021-03-15\"\n##  [71] \"2021-03-16\" \"2021-03-17\" \"2021-03-18\" \"2021-03-19\" \"2021-03-20\"\n##  [76] \"2021-03-21\" \"2021-03-22\" \"2021-03-23\" \"2021-03-24\" \"2021-03-25\"\n##  [81] \"2021-03-26\" \"2021-03-27\" \"2021-03-28\" \"2021-03-29\" \"2021-03-30\"\n##  [86] \"2021-03-31\" \"2021-04-01\" \"2021-04-02\" \"2021-04-03\" \"2021-04-04\"\n##  [91] \"2021-04-05\" \"2021-04-06\" \"2021-04-07\" \"2021-04-08\" \"2021-04-09\"\n##  [96] \"2021-04-10\" \"2021-04-11\" \"2021-04-12\" \"2021-04-13\" \"2021-04-14\"\n## [101] \"2021-04-15\" \"2021-04-16\" \"2021-04-17\" \"2021-04-18\" \"2021-04-19\"\n## [106] \"2021-04-20\" \"2021-04-21\" \"2021-04-22\" \"2021-04-23\"\nnames(panel_vacunas_fecha$`2021-04-23`)##  [1] \"ccaa\"                                \n##  [2] \"fechas\"                              \n##  [3] \"ISO\"                                 \n##  [4] \"poblacion\"                           \n##  [5] \"porc_pobl_total\"                     \n##  [6] \"poblacion_mayor_16a\"                 \n##  [7] \"porc_pobl_total_mayor_16a\"           \n##  [8] \"dosis_entrega_pfizer\"                \n##  [9] \"dosis_entrega_astra\"                 \n## [10] \"dosis_entrega_moderna\"               \n## [11] \"dosis_entrega_janssen\"               \n## [12] \"dosis_entrega\"                       \n## [13] \"dosis_entrega_100hab\"                \n## [14] \"porc_entregadas_sobre_total\"         \n## [15] \"dosis_diarias_entrega_pfizer\"        \n## [16] \"dosis_diarias_entrega_astra\"         \n## [17] \"dosis_diarias_entrega_moderna\"       \n## [18] \"dosis_diarias_entrega\"               \n## [19] \"dosis_7D_entrega_pfizer\"             \n## [20] \"dosis_7D_entrega_astra\"              \n## [21] \"dosis_7D_entrega_moderna\"            \n## [22] \"dosis_7D_entrega\"                    \n## [23] \"dosis_7D_entrega_100hab\"             \n## [24] \"dosis_admin\"                         \n## [25] \"dosis_primera\"                       \n## [26] \"dosis_pauta_completa\"                \n## [27] \"dosis_admin_100hab\"                  \n## [28] \"porc_admin_sobre_ccaa\"               \n## [29] \"porc_admin_vs_total\"                 \n## [30] \"dosis_diarias_admin\"                 \n## [31] \"dosis_diarias_admin_100hab\"          \n## [32] \"crec_diario_dosis_admin\"             \n## [33] \"dosis_diarias_primera\"               \n## [34] \"dosis_diarias_segunda\"               \n## [35] \"dosis_7D_admin\"                      \n## [36] \"dosis_7D_admin_100hab\"               \n## [37] \"crec_7D_dosis_admin\"                 \n## [38] \"porc_admin_vs_total_7D\"              \n## [39] \"personas_vacunadas\"                  \n## [40] \"personas_pauta_completa\"             \n## [41] \"personas_1dosis\"                     \n## [42] \"porc_personas_vacunadas\"             \n## [43] \"porc_personas_pauta_completa\"        \n## [44] \"porc_personas_vacunadas_16a\"         \n## [45] \"porc_personas_pauta_completa_16a\"    \n## [46] \"personas_vacunadas_diarias\"          \n## [47] \"personas_pauta_completa_diarias\"     \n## [48] \"porc_personas_vacunadas_diarias\"     \n## [49] \"porc_personas_pauta_completa_diarias\"\n## [50] \"personas_vacunadas_7D\"               \n## [51] \"personas_pauta_completa_7D\"          \n## [52] \"porc_personas_vacunadas_7D\"          \n## [53] \"porc_personas_pauta_completa_7D\"     \n## [54] \"porc_personas_vacunadas_16a_7D\"      \n## [55] \"porc_personas_pauta_completa_16a_7D\" \n## [56] \"crec_diario_personas_vacunadas\"      \n## [57] \"crec_7D_personas_vacunadas\"          \n## [58] \"crec_diario_personas_pauta_completa\" \n## [59] \"crec_7D_personas_pauta_completa\"     \n## [60] \"desv_porc_admin_vs_total\"            \n## [61] \"desv_dosis_entrega\"                  \n## [62] \"desv_porc_personas_vacunadas\"        \n## [63] \"desv_porc_personas_pauta_completa\"   \n## [64] \"fecha_30vacunados_ritmo7D\"           \n## [65] \"fecha_50vacunados_ritmo7D\"           \n## [66] \"fecha_70vacunados_ritmo7D\"           \n## [67] \"fecha_30inmunizados_ritmo7D\"         \n## [68] \"fecha_50inmunizados_ritmo7D\"         \n## [69] \"fecha_70inmunizados_ritmo7D\"         \n## [70] \"fecha_30inmunizados_16a_ritmo7D\"     \n## [71] \"fecha_50inmunizados_16a_ritmo7D\"     \n## [72] \"fecha_70inmunizados_16a_ritmo7D\"\nhead(panel_vacunas_fecha$`2021-04-23`[, 1:7])##     ccaa     fechas ISO poblacion porc_pobl_total poblacion_mayor_16a\n## 77    AN 2021-04-23  AN   8464411          17.838             7062213\n## 771   AR 2021-04-23  AR   1329391           2.802             1132764\n## 772   AS 2021-04-23  AS   1018784           2.147              901209\n## 773   IB 2021-04-23  IB   1171543           2.469              986279\n## 774   CN 2021-04-23  CN   2175952           4.586             1871033\n## 775   CB 2021-04-23  CB    582905           1.228              501384\n##     porc_pobl_total_mayor_16a\n## 77                     17.598\n## 771                     2.823\n## 772                     2.246\n## 773                     2.458\n## 774                     4.662\n## 775                     1.249\ndatos / 2## Error in datos/2: argumento no-numérico para operador binario"},{"path":"otros_datos.html","id":"factores","chapter":"Capítulo 8 Listas y factores","heading":"8.2 Factores","text":"Los factores son el tipo de dato que tiene R para definir variables categóricas, variables que aunque puedan ser números, en realidad representa categorías (categoría 1, 2, 3…). Internamente los factores se guardan como variable numéricas enteras (enumerando las categorías) pero se nos mostarán con el nombre asignada dicha categoría. Para convertir una variable factor basta con ejecutar la función factor(), que nos convierte cada valor diferente en una categoría (para ver valores diferentes de un vector, usar la función unique()).Un factor es una CATEGORÍAEs importante entender que un factor es una CATEGORÍA, como rojo/blanco/negro, por lo que desde el momento en el que lo convertimos en factor, ya podemos hacer operaciones aritméticas (podemos sumar categorías, solo números).Como puedes observar, al tenerlo en factor, además de la variable en sí se nos muestra debajo los levels, los nombres de las categorías. Si le indicamos que nombres queremos, nos convierte los valores texto y lo toma como nombre de categoría. Con el argumento labels podemos configurarlo nuestro gusto. Con la función levels podemos reasignarle nombres tras su generación.Aunque sirve también para variables numéricas, la función table() nos calcula las frecuencias de cada una de las categorías, las veces que se repiten en nuestro conjunto (es una forma eficiente de guardar categorías ya que solo se guardan los valores únicos y el número de veces que se repiten, así como su lugar).Una ventaja de los factores es que le podemos indicar que considere que las categorías son ordinales: tiene una jerarquía de orden, con el argumento ordered = TRUE.Para pasar de factor variable numérica (y poder operar con ellos), basta usar la función .numeric().También podemos convertir variables continuas (o discretas) factores indicando los rangos de las categorías que queremos asignar con la función cut(). Por ejemplo, supongamos que tenemos notas numéricas de clase y queremos asignar una nota categórica. En el argumento breaks debemos indicarle los cortes que queremos en los datos, teniendo n+1 valores, siendo n el número de categorías. Con right = FALSE le vamos indicar que los intervalos son abiertos por la derecha.Además, la función cut() identifica los datos de tipo fecha, pudiendo hacer cortes por unidades temporales.Paquete forcatsEn dicho paquete tienes muchas funcionalidades para trabajar con factores. Ver https://forcats.tidyverse.org/.\nImagen/gráfica 8.1: Paquete lubridate.\n","code":"\ndatos <- c(1, 2, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1)\nunique(datos)## [1] 1 2 3\ndatos##  [1] 1 2 2 3 1 2 3 3 1 2 3 3 1\ndatos_factor <- factor(datos) # Convertimos a factor\ndatos_factor ##  [1] 1 2 2 3 1 2 3 3 1 2 3 3 1\n## Levels: 1 2 3\ndatos + 1##  [1] 2 3 3 4 2 3 4 4 2 3 4 4 2\ndatos_factor + 1##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA\ndatos_factor <- factor(datos, labels = paste(\"Categoría\", sort(unique(datos)))) # damos nombre de categoría 1, 2, 3...\ndatos_factor ##  [1] Categoría 1 Categoría 2 Categoría 2 Categoría 3 Categoría 1 Categoría 2\n##  [7] Categoría 3 Categoría 3 Categoría 1 Categoría 2 Categoría 3 Categoría 3\n## [13] Categoría 1\n## Levels: Categoría 1 Categoría 2 Categoría 3\nlevels(datos_factor) <- c(\"C1\", \"C2\", \"C3\")\ndatos_factor##  [1] C1 C2 C2 C3 C1 C2 C3 C3 C1 C2 C3 C3 C1\n## Levels: C1 C2 C3\ntable(datos_factor)## datos_factor\n## C1 C2 C3 \n##  4  4  5\nnotas <- c(7, 2, 10, 5, 7, 8, 10, 8, 2, 2, 5, 5, 5, 10) # notas de clase: tienen un orden\nnotas_factor <- factor(notas)\nnotas_factor[1] < notas_factor[2]## [1] NA\nnotas_factor_ordenados <- factor(notas, ordered = TRUE)\nnotas_factor_ordenados[1] < notas_factor_ordenados[2] # nos dice que la categoría 7 no es menor que la categoría 2## [1] FALSE\nnotas_factor_ordenados##  [1] 7  2  10 5  7  8  10 8  2  2  5  5  5  10\n## Levels: 2 < 5 < 7 < 8 < 10\nnotas_factor_ordenados + 1##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA\nas.numeric(notas_factor_ordenados) + 1##  [1] 4 2 6 3 4 5 6 5 2 2 3 3 3 6\nmean(as.numeric(notas_factor_ordenados))## [1] 2.857143\nnotas <- c(7.4, 1.1, 2.9, 10, 5.2, 7.7, 8.9, 10, 8.1, 2.6, 2.4, 5.5, 5, 5, 10, 6.3, 9.4) # notas de clase\nnotas_categoricas <- cut(notas, breaks = c(0, 5, 7, 9, 10, 10.1), labels = c(\"suspenso\", \"aprobado\", \"notable\", \"sobresaliente\", \"mh\"), right = FALSE)\nnotas_categoricas##  [1] notable       suspenso      suspenso      mh            aprobado     \n##  [6] notable       notable       mh            notable       suspenso     \n## [11] suspenso      aprobado      aprobado      aprobado      mh           \n## [16] aprobado      sobresaliente\n## Levels: suspenso aprobado notable sobresaliente mh\nfechas <- as.Date(c(\"2021-04-10\", \"2021-03-10\", \"2021-01-01\", \"2020-01-15\", \"2020-09-10\", \"2020-09-15\", \"2020-07-08\"))\nfechas_cortes <- cut(fechas, breaks = \"year\")\nlevels(fechas_cortes) <- c(\"2020\", \"2021\")\nfechas_cortes## [1] 2021 2021 2021 2020 2020 2020 2020\n## Levels: 2020 2021"},{"path":"otros_datos.html","id":"fechas-y-horas","chapter":"Capítulo 8 Listas y factores","heading":"8.3 Fechas y horas","text":"Como ya hemos dicho, las fechas y momentos temporales serán meras cadenas de caracter sino que tienen clases especiales asociadas y algunas funciones especiales que pueden sernos útiles: las fechas serán de tipo dates mientras que las horas será de tipo POSIXct o POSIXlt. En el primer caso, las fechas serán guardadas internamente como el número de días transcurridos desde el 1 de enero de 1970, y las horas como número de segundos desde el 1 de enero de 1970 (para la clase POSIXct) o una lista de segundos, minutos y horas (para la clase POSIXlt).¿Cómo obtener automáticamente la fecha de hoy, por ejemplo? La función Sys.Date() nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden.Para convertir una cadena de texto fecha, basta usar la función .Date() del paquete {base}, pasándole como argumento la fecha en formato \"yyyy-mm-dd\" por defecto.Si introducimos otro tipo de formato, debemos especificárselo en un segundo argumento, para R sepa el formato de fecha que le estamos pasandoSin pasar fecha se puede operarSi tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día).Fíjate la diferencia cuando lo convertimos en fechaAunque aparentemente parezca una cadena de texto, prueba ejecutar unclass(fecha) para comprobar que tiene internamente guardado.Paquete lubridateDentro del entorno tidyverse, el paquete lubridate nos permite una gestión mucho más intuitiva de las fechasEn dicho paquete tienes muchas funcionalidades para trabajar con fechas. Ver https://lubridate.tidyverse.org/.\nImagen/gráfica 8.2: Paquete lubridate.\nTabla 8.2: Paquetes mencionados hasta ahoraEl paquete lubridate nos proporciona herramientas para extraer la fecha y hora actuales con las funciones today() y now()Además tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el día de la semana, el mes o el cuatrimestre, con las funciones year(), months(), day() o wday() (día de la semana).Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos realizar comparaciones, por ejemplo, si el día actual es menor o mayor que otra fecha dada.","code":"\nfecha <- Sys.Date()\nfecha## [1] \"2021-09-24\"\nfecha - 7 # una semana antes## [1] \"2021-09-17\"\nclass(fecha) # de clase fecha## [1] \"Date\"\nas.Date(\"2021-03-10\") # formato por defecto## [1] \"2021-03-10\"\nas.Date(\"10-03-2020\", \"%d-%m-%Y\") # con día-mes-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"10-03-20\", \"%d-%m-%y\")  # con día-mes-año (2 cifras)## [1] \"2020-03-10\"\nas.Date(\"03-10-2020\", \"%m-%d-%Y\") # con mes-día-año (4 cifras)## [1] \"2020-03-10\"\nas.Date(\"Octubre 21, 1995 21:24\", \"%B %d, %Y %H:%M\") # fecha escrita## [1] NA\n\"2021-03-10\" - 1 # error## Error in \"2021-03-10\" - 1: argumento no-numérico para operador binario\nfecha <- as.Date(\"2021-03-10\") - 1 # día previo\nfecha## [1] \"2021-03-09\"\nunclass(fecha)## [1] 18695\nunclass(as.Date(\"1969-01-01\")) # un año antes de la referencia a partir de la cual cuenta días## [1] -365\ninstall.packages(\"lubridate\")\nlibrary(lubridate)\nymd_hms(\"2017-11-28T14:02:00\") # convertir a fecha una cadena año-mes-día + hora## [1] \"2017-11-28 14:02:00 UTC\"\nydm_hms(\"2017-22-12 10:00:00\") # convertir a fecha una cadena año-día-mes + hora## [1] \"2017-12-22 10:00:00 UTC\"\ndmy_hms(\"1 Jan 2017 23:59:59\") # convertir a fecha una cadena textual de fecha + hora## [1] \"2017-01-01 23:59:59 UTC\"\nmdy(\"July 4th, 2000\") # convertir a fecha una cadena textual de fecha## [1] \"2000-07-04\"\nymd(20170131)## [1] \"2017-01-31\"\ntoday()## [1] \"2021-09-24\"\nnow()## [1] \"2021-09-24 11:06:34 CEST\"\nfecha <- now()\nyear(fecha)## [1] 2021\nmonth(fecha)## [1] 9\nday(fecha)## [1] 24\nwday(fecha, week_start = 1) # Día de la semana (empezando por el lunes)## [1] 5\nhour(fecha)## [1] 11\nminute(fecha)## [1] 6\nsecond(fecha)## [1] 34.21263\nweek(fecha) # Número de semana (del año)## [1] 39\nfecha_actual <- now()\nfecha_actual > ymd(20170131) # Actual vs 2017-01-31## [1] TRUE\nfecha_actual > ymd(21000131) # Actual vs 2100-01-31## [1] FALSE"},{"path":"otros_datos.html","id":"ejercicios-3","chapter":"Capítulo 8 Listas y factores","heading":"8.4 📝 Ejercicios","text":"Ejercicio 1: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluiré uno que sea un data.frame para que veas que en una lista cabe de todo).Solución: Ejercicio 2: accede los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.Solución:Otra opción es acceder con los nombres Ejercicio 3: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato numérico) y si estás soltero/.Solución:","code":"\n# Ejemplo: lista con texto, numérico, lógico y un data.frame\nlista_ejemplo <- list(\"nombre\" = \"Javier\", \"cp\" = 28019,\n                      \"soltero\" = TRUE,\n                      \"notas\" = data.frame(\"mates\" = c(7.5, 8, 9),\n                                           \"lengua\" = c(10, 5, 6),\n                                           \"gimnasia\" = c(4, 8, 6)))\nlista_ejemplo## $nombre\n## [1] \"Javier\"\n## \n## $cp\n## [1] 28019\n## \n## $soltero\n## [1] TRUE\n## \n## $notas\n##   mates lengua gimnasia\n## 1   7.5     10        4\n## 2   8.0      5        8\n## 3   9.0      6        6\n# Longitud\nlength(lista_ejemplo)## [1] 4\n# Accedemos al elemento dos\nlista_ejemplo[[2]]## [1] 28019\n# Accedemos al 1 y al 4\nlista_ejemplo[c(1, 4)]## $nombre\n## [1] \"Javier\"\n## \n## $notas\n##   mates lengua gimnasia\n## 1   7.5     10        4\n## 2   8.0      5        8\n## 3   9.0      6        6\n# Accedemos al 1 y al 4\nlista_ejemplo$nombre## [1] \"Javier\"\nlista_ejemplo$notas##   mates lengua gimnasia\n## 1   7.5     10        4\n## 2   8.0      5        8\n## 3   9.0      6        6\nlibrary(lubridate)\n# Creamos lista: con lubridate calculamos la diferencia de años desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)\nlista_personal <- list(\"nombre\" = \"Javier\",\n                       \"apellidos\" = \"Álvarez Liébana\",\n                       \"edad\" = time_length(interval(ymd(\"1989-09-10\"), ymd(Sys.Date())), unit = \"years\"),\n                       \"soltero\" = TRUE)\nlista_personal## $nombre\n## [1] \"Javier\"\n## \n## $apellidos\n## [1] \"Álvarez Liébana\"\n## \n## $edad\n## [1] 32.03836\n## \n## $soltero\n## [1] TRUE\n# Otra opción: la edad calculada con floor (quita decimales y se queda con la parte entera)\nlista_personal <- list(\"nombre\" = \"Javier\",\n                       \"apellidos\" = \"Álvarez Liébana\",\n                       \"edad\" = floor(time_length(interval(ymd(\"1989-09-10\"), ymd(today())), unit = \"years\")),\n                       \"soltero\" = TRUE)\nlista_personal## $nombre\n## [1] \"Javier\"\n## \n## $apellidos\n## [1] \"Álvarez Liébana\"\n## \n## $edad\n## [1] 32\n## \n## $soltero\n## [1] TRUE"},{"path":"FUNCIONES.html","id":"FUNCIONES","chapter":"Capítulo 9 Creación de funciones","heading":"Capítulo 9 Creación de funciones","text":"En R solo podemos usar las funciones predeterminadas que vienen ya cargadas, o las de los paquetes que instalamos, sino que además podemos crear nuestras propias funciones, para automatizar tareas que vayamos repetir lo largo de nuestro código.¿Cómo crear nuestra propia función? Veamos su sintaxis básica. Para crear una función necesitamos un nombre_funcion (sin espacios ni caracteres extraños), al que le asignamos la orden function(). Dentro de function() tendríamos que definir los argumentos de entrada que vamos usar.argumento_1, argumento_2, …: serán los argumentos de entrada, los argumentos que toma la función para ejecutar el código que tiene dentrocódigo: líneas de código que queramos que ejecute la función. IMPORTANTE: todas las variables que definamos dentro de la función son variables locales, solo existirán dentro de la función salvo que especifiquemos lo contrario.return(variable_salida): dentro del comando return() se introducirá la salida de la función, que puede ser un número, un data.frame, una gráfica, una matriz… o todo junto en una lista.","code":"\nnombre_funcion <- function(argumento_1, argumento_2, ... ) {\n  \n  # Código que queramos ejecutar en la función\n  código\n  \n  # Salida\n  return(variable_salida)\n}"},{"path":"FUNCIONES.html","id":"primera-función","chapter":"Capítulo 9 Creación de funciones","heading":"9.1 Primera función","text":"Veamos un ejemplo muy simple de función para calcular el área de un rectángulo: dados dos lados lado_1 y lado_2, deberá devolver el área como su producto.También podemos hacer la definición directa sin almacenar variables.¿Cómo aplicar la función? Con el nombre y los valores de los argumentos.Imagina ahora que nos damos cuenta que el 90% de las veces el área que nos toca calcular es la de un cuadrado: R nos permite definir argumentos en la función con valores por defecto (tomarán dicho valor salvo que le asignemos otro). ¿Por qué asignar lado_2 = lado_1 por defecto, para ahorrar líneas de código y tiempo?Compliquemos un poco la función y añadamos en la salida los valores de cada lado etiquetados como primer lado y segundo lado.Veamos que nos devuelve ahoraFíjate que puedes guardar la salida de forma conjunta para luego acceder solo uno de los elementos de la lista de salida.Antes nos daba igual el orden de los argumentos pero ahora , ya que en la salida incluimos lado_1 y lado_2. Es altamente recomendable hacer la llamada la función indicando explícitamente los argumentos argumento_1 = valor_1 para mejorar la legibilidad e interpretabilidad de nuestro código (recuerda: programa como escribirías una novela).","code":"\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2) {\n  \n  # Cuerpo de la función\n  area <- lado_1 * lado_2\n  \n  # Resultado que devolvemos\n  return(area)\n  \n}\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2) {\n\n  # Resultado que devolvemos\n  return(lado_1 * lado_2)\n  \n}\n# Aplicación de la función con los parámetros por defecto\ncalcular_area(5, 3) # área de un rectángulo 5 x 3 ## [1] 15\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2 = lado_1) {\n  \n  # Cuerpo de la función\n  area <- lado_1 * lado_2\n  \n  # Resultado que devolvemos\n  return(area)\n  \n}\ncalcular_area(lado_1 = 5) # si no indicamos nada, lado_2 = lado_1## [1] 25\n# Definición del nombre de función y argumentos de entrada\ncalcular_area <- function(lado_1, lado_2 = lado_1) {\n  \n  # Cuerpo de la función\n  area <- lado_1 * lado_2\n  \n  # Resultado que devolvemos en modo lista ya que devolvemos\n  # varios argumentos a la vez (podemos dar a cada elemento \n  # de la lista con un nombre que nos permita identificarlo)\n  return(list(\"area\" = area, \"lado_1\" = lado_1, \"lado_2\" = lado_2))\n  \n}\ncalcular_area(5, 3)## $area\n## [1] 15\n## \n## $lado_1\n## [1] 5\n## \n## $lado_2\n## [1] 3\nx <- calcular_area(5, 3)\nx$area## [1] 15\nx$lado_1## [1] 5\nx$lado_2## [1] 3\ncalcular_area(lado_1 = 5, lado_2 = 3)## $area\n## [1] 15\n## \n## $lado_1\n## [1] 5\n## \n## $lado_2\n## [1] 3"},{"path":"FUNCIONES.html","id":"segunda-función","chapter":"Capítulo 9 Creación de funciones","heading":"9.2 Segunda función","text":"Vayamos con un ejemplo más complejo. Imaginemos que en nuestro código vamos tener calcular, para cada día, el número de vacunas diarias administradas, el número de vacunas administradas en los últimos 7 días y el número de vacunadas administradas en los últimos 14 días, usando tan solo el número de vacunadas acumuladas. Para ello vamos usar la función diff() que nos calcula las diferencias de un vector dado.¿Cuánto ocuparía realizar esta misma tarea para cada comunidad, y cada variable? ¿Por qué la automatizamos?Como vemos, los argumentos pueden ser cualquier tipo de variable, y nos permite además generalizar y automatizar una tarea para que pueda ser usada incluso en algún escenario para el que tuviéramos previsto (acumulados … 13 días, por ejemplo). Para que nuestra función sea realmente útil debemos intentar asignar nombres de funciones y argumentos lo más concisos posibles y evidentes en su interpretación.Fíjate que hemos devuelto solo el último acumulado (hemos dado la vuelta al vector resultante y nos hemos quedado con el primer elemento). Para hacer que la salida sea más interpretable, muchas de las funciones en R tienen como salida una lista, con unos nombres asignados.","code":"\nx <- c(1, 2, 3, 7, 10, 15, 20, 50, 100, 250, 600, 1200)\ndiff(x) # vector con [elemento2 - elemento1, elemento3 - elemento2, elemento4 - elemento3, ...]##  [1]   1   1   4   3   5   5  30  50 150 350 600\ndiff(x, 3) # vector con [elemento4 - elemento1, elemento5 - elemento2, elemento6 - elemento3, ...]## [1]    6    8   12   13   40   85  230  550 1100\ndiff(x, 7) # vector con [elemento8 - elemento1, elemento9 - elemento2, elemento10 - elemento3, ...]## [1]   49   98  247  593 1190\n# Para España\ncasos_diarios <- diff(panel_vacunas$ES$personas_vacunadas)\ncasos_7D <- diff(panel_vacunas$ES$personas_vacunadas, 7) # diferencias a 7 días\ncasos_14D <- diff(panel_vacunas$ES$personas_vacunadas, 14) # diferencias a 14 días\ndatos_acumulados <- function(variable_acumulada, dias_dif = c(1, 7, 14)) {\n  \n  # Dentro de las llaves el cuerpo de la función\n  acumulados_diferenciales <- NULL\n  for (i in dias_dif) { # Vamos calculando tantos acumulados diferenciales como le hayamos pasado por el argumento dias_dif\n    \n    # A lo que teníamos, le concatenamos por columnas uno nuevo\n    acumulados_diferenciales <- c(acumulados_diferenciales,\n                                  rev(diff(variable_acumulada, i))[1])\n  \n  }\n  \n  # La salida de la función\n  return(acumulados_diferenciales)\n}\ndatos_acumulados(panel_vacunas$ES$personas_vacunadas)## [1]  263914 1403809 3246147\ndatos_acumulados(panel_vacunas$AN$personas_vacunadas)## [1]  59583 235051 537727\ndatos_acumulados(panel_vacunas$ES$personas_vacunadas, dias_dif = c(1, 3, 13, 21))## [1]  263914  816950 3073866 4779568\ndatos_acumulados <- function(variable_acumulada) {\n  \n  # Datos\n  dato_diario <- diff(variable_acumulada)\n  dato_7D <- diff(variable_acumulada, 7)\n  dato_14D <- diff(variable_acumulada, 14)\n\n  # La salida de la función como una lista, con 3 vectores\n  return(list(\"diario\" = dato_diario, \"7D\" = dato_7D,\n              \"14D\" = dato_14D))\n}\ndatos_salida <- datos_acumulados(panel_vacunas$ES$personas_vacunadas)\nnames(datos_salida)## [1] \"diario\" \"7D\"     \"14D\"\ndatos_salida## $diario\n##   [1]  33992  33992  70653  42705  42705  42705  81950  93597  94548  92764\n##  [11]  42226  42225  42226  61129  53539  43950  43124  17175  17176  17175\n##  [21]  18624  15876  19464  19464   9682   9682   9682   3166  11265  13420\n##  [31]  26031   4458   4459   4458   9833  15107  33663  45331  22986  22985\n##  [41]  22986  36073  43687  66918 126790  42768  42769  42768  63596 106609\n##  [51] 140881 157476  68588  68589  68588  74417 130284 147861 208913  66537\n##  [61]  66537  66537 107709 105255 127181 100675  60566  60566  60566  62460\n##  [71]  38789  54080  26122  26123  26123  26122  41558  91262 103674 113995\n##  [81] 135234 135233 135234 125305 221541 231064  81155  81155  91719  91719\n##  [91] 227822 297306 375063 368637 172281 172282 172281 261006 313321 380661\n## [101] 370506 146544 146543 146544 147228 297290 255746 263914\n## \n## $`7D`\n##   [1]  348702  408307  468863  490974  490495  490015  489536  468715  428657\n##  [10]  378059  328419  303368  278319  253268  210763  173100  148614  124954\n##  [19]  117461  109967  102474   87016   82405   76361   82928   77704   72481\n##  [28]   67257   73924   77766   98009  117309  135837  154363  172891  199131\n##  [37]  227711  260966  342425  362207  381991  401773  429296  492218  566181\n##  [46]  596867  622687  648507  674327  685148  708823  715803  767240  765189\n##  [55]  763137  761086  794378  769349  748669  640431  634460  628489  622518\n##  [64]  577269  510803  437702  363149  328706  294263  259819  238917  291390\n##  [73]  340984  428857  537968  647078  756190  839937  970216 1097606 1064766\n##  [82] 1010687  967173  923658 1026175 1101940 1245939 1533421 1624547 1705110\n##  [91] 1785672 1818856 1834871 1840469 1842338 1816601 1790862 1765125 1651347\n## [100] 1635316 1510401 1403809\n## \n## $`14D`\n##  [1]  817417  836964  846922  819393  793863  768334  742804  679478  601757\n## [10]  526673  453373  420829  388286  355742  297779  255505  224975  207882\n## [19]  195165  182448  169731  160940  160171  174370  200237  213541  226844\n## [28]  240148  273055  305477  358975  459734  498044  536354  574664  628427\n## [37]  719929  827147  939292  984894 1030498 1076100 1114444 1201041 1281984\n## [46] 1364107 1387876 1411644 1435413 1479526 1478172 1464472 1407671 1399649\n## [55] 1391626 1383604 1371647 1280152 1186371 1003580  963166  922752  882337\n## [64]  816186  802193  778686  792006  866674  941341 1016009 1078854 1261606\n## [73] 1438590 1493623 1548655 1614251 1679848 1866112 2072156 2343545 2598187\n## [82] 2635234 2672283 2709330 2845031 2936811 3086408 3375759 3441148 3495972\n## [91] 3550797 3470203 3470187 3350870 3246147"},{"path":"FUNCIONES.html","id":"variables-localesglobales","chapter":"Capítulo 9 Creación de funciones","heading":"9.3 Variables locales/globales","text":"Hemos dicho que «lo local se queda en lo local», ¿pero qué sucede si nombramos una variable dentro de una función que se nos ha olvidado asignar un valor dentro de la misma? Debemos ser cautos al usar funciones en R, ya que debido la «regla lexicográfica», si una variable se define dentro de la función, R buscará dicha variable en el entorno de variable.Si una variable ya está definida fuera de la función (entorno global), y además es usada dentro de la misma cambiando su valor, el valor de dicha variable solo cambia dentro de la función pero en el entorno global.Si queremos que además de cambiar localmente lo haga globalmente deberemos usar la doble asignación (<<-).","code":"\nx <- 1\nfuncion_ejemplo <- function() {\n    \n  print(x) # No devuelve nada per se, solo realiza la acción de imprimir en consola\n}\nfuncion_ejemplo()## [1] 1\nx <- 1\nfuncion_ejemplo <- function() {\n    \n  x <- 2\n  print(x) # lo que vale dentro\n}\nfuncion_ejemplo() # lo que vale dentro## [1] 2\nprint(x) # lo que vale fuera## [1] 1\nx <- 1\ny <- 2\nfuncion_ejemplo <- function() {\n  \n  x <- 3 # no cambia globalmente, solo localmente\n  y <<- 0 # cambia globalmente\n  print(x)\n  print(y)\n}\n\nfuncion_ejemplo() # lo que vale dentro## [1] 3\n## [1] 0\nx # lo que vale fuera## [1] 1\ny # lo que vale fuera## [1] 0"},{"path":"FUNCIONES.html","id":"ejercicios-4","chapter":"Capítulo 9 Creación de funciones","heading":"9.4 📝 Ejercicios","text":"Ejercicio 1: define una función propia llamada pares que, dados dos números x e y, nos diga si la suma de ambos es par o .Solución:También se puede definir directamente como Ejercicio 2: define una función propia llamada proximo_par que, dados un número x, nos diga si es par y, en aso de serlo, nos devuelva el próximo número que si lo sea.Solución:","code":"\n# Definimos función\npares <- function(x, y) {\n  \n  # Sumamos\n  suma <- x + y\n  \n  # Comprobamos si es par calculando el resto al dividir entre 2: si al dividir suma entre 2 el resto es 0 ==> es par\n  \n  par <- suma %% 2 == 0\n  \n  # Devolvemos la salida\n  return(par)\n}\n\n# Aplicamos la función\npares(1, 3)## [1] TRUE\npares(1, 0)## [1] FALSE\npares(2, 6)## [1] TRUE\npares(2, 7)## [1] FALSE\n# Definimos función\npares <- function(x, y) {\n\n  # Devolvemos la salida\n  return((x + y) %% 2 == 0)\n}\n\npares(1, 3)## [1] TRUE\npares(1, 0)## [1] FALSE\npares(2, 6)## [1] TRUE\npares(2, 7)## [1] FALSE\n# Definimos función\nproximo_par <- function(x) {\n  \n  # ¿par? TRUE/FALSE\n  par <- (x %% 2) == 0\n  \n  # Si es par, devolvemos el propio número (era par), sino le sumamos uno\n  if (par) {\n    \n    return(list(\"par\" = par, \"proximo\" = x))\n    \n  } else { # Si no es par, devolvemos el siguiente (que será par) \n    \n    return(list(\"par\" = par, \"proximo\" = x + 1))\n  \n  }\n  # Devolvemos una lista de dos elementos: par (TRUE/FALSE) y proximo (si es par, el propio x, sino x + 1)\n}\n\n# Aplicamos la función\nproximo_par(7)## $par\n## [1] FALSE\n## \n## $proximo\n## [1] 8\nproximo_par(8)## $par\n## [1] TRUE\n## \n## $proximo\n## [1] 8"},{"path":"qué-sabemos-hacer.html","id":"qué-sabemos-hacer","chapter":"Capítulo 10 ¿Qué sabemos hacer?","heading":"Capítulo 10 ¿Qué sabemos hacer?","text":"Hasta aquí el aperitivo¿Qué datos hemos aprendido manejar?Tabla 10.1: Tipos de datos mencionados hasta ahora¿Qué paquetes hemos usado ya?Como ves, hemos podido hacer bastantes cosas ya en R con muy pocos paquetes, y ocupando el mínimo espacio y tiempo en nuestro ordenador.Tabla 10.2: Paquetes mencionados hasta ahoraQuizás creas que te queda un mundo por aprender:¿Cómo manejo datos de forma más profunda (filtrar, operar con ellos, etc)?¿Cómo realizo análisis estadísticos?¿Cómo visualizo datos?¿Cómo generar informes con los resultados (ver (Xie 2015))?¿Cómo crear webs interactivas para la visualización y análisis de datos?te voy mentir: tendrías días de tu vida para ir investigando todos los paquetes que hay hechos en R (ni tú ni nadie). Pero la idea de estos primeros capítulos era que fueses experto en R sino que vieses que, con pocas líneas de código y con cierta práctica, se puede empezar tener herramientas para comenzar nuestra andadura en el análisis estadístico través de este software. te obsesiones con saberte todos los comandos de todos los paquetes o acabarás loco/.\nImagen/gráfica 10.1: Cuando intentas aprenderte todos los paquetes.\nEstos primeros capítulos de un lenguaje de programación suelen ser un poco «aburridos»Si sabes programar, te habrán parecido triviales (más allá de conocer la sintaxis propia de R).Si sabías programar, han sido de repente un puñado de conceptos y cosas recordar, que hasta que nos los vayas practicando tendrás que acudir este manual (u otros recursos). te obsesiones con memorizar: yo consulto cada día cosas que aparecen en este tutorial porque se olvidan.Lo importante es entender, memorizar comandosPero aunque sean más aburridos estos primeros conceptos, son necesarios para empezar caminar: el inicio de aprender un idioma siempre es un poco meh, pero sin las reglas básicas de gramática y un mínimo de léxico nunca podrás empezar.","code":""},{"path":"qué-sabemos-hacer.html","id":"recursos","chapter":"Capítulo 10 ¿Qué sabemos hacer?","heading":"10.1 Recursos extras","text":"Ahora que ya sabes lo básico para poder empezar trabajar en un entorno amigable, aunque la idea es que este manual tenga más capítulos (¿los tiene?) para seguir avanzando, por si se olvida, te dejo una lista de recursos útiles para que puedas ir viendo el abanico de opciones que tienesCódigo de este manual: este manual está programado en sí mismo en R y los códigos pueden ser consultados libremente en el repositorio de GitHub (hablaremos más adelante de como gestionar versiones de nuestro código en dicha plataforma).Cursos y selección de paquetes: recopilatorio y selección de tutoriales y cursos de R en distintos campos.Cursos y selección de paquetes: recopilatorio y selección de tutoriales y cursos de R en distintos campos.Incursión los modelos de regresión en R: manual sobre el uso de distintos modelos predictivos basados los Modelos Lineales Generalizados (GLM).Incursión los modelos de regresión en R: manual sobre el uso de distintos modelos predictivos basados los Modelos Lineales Generalizados (GLM).Paquete para aprender R: el paquete swirl permite ir aprendiendo de forma sencilla (con preguntas tipo test) algunos conceptos básicos de R (muchos de ellos vistos en este manual). Puedes consultar la documentación en su página webPaquete para aprender R: el paquete swirl permite ir aprendiendo de forma sencilla (con preguntas tipo test) algunos conceptos básicos de R (muchos de ellos vistos en este manual). Puedes consultar la documentación en su página webManejo de datos: probablemente el conjunto de herramientas más usadas en R sean los paquetes agrupados en {tidyverse} (y que veremos en capítulos sucesivos si los hubiese), un conjunto de paquetes integrados para un manejo intuitivo de los datos, tanto en su preprocesamiento, como en la generación de estadísticas y gráficas.Manejo de datos: probablemente el conjunto de herramientas más usadas en R sean los paquetes agrupados en {tidyverse} (y que veremos en capítulos sucesivos si los hubiese), un conjunto de paquetes integrados para un manejo intuitivo de los datos, tanto en su preprocesamiento, como en la generación de estadísticas y gráficas.Tidyverse cookbookTidyverse skills data scienceTidyverse skills data scienceVisualización de datos en Twitter: una de las fortalezas de R es su versatilidad para la visualización de datos. Y al igual que un escritor necesita leer mucho para tomar ideas, hay dos recursos en Twitter que te recomiendo encarecidamente:\nEl hashtag #TidyTuesday es una etiqueta en la que cada semana se plantea el reto de proponer la mejor visualización para un conjunto de datos dado, donde solo puedes participar con la comunidad sino ver las visualizaciones de otros usuarios de R.\nAdemás elaborado una lista de Twitter de usuarios que se dedican la visualización de datos.\nEl hashtag #TidyTuesday es una etiqueta en la que cada semana se plantea el reto de proponer la mejor visualización para un conjunto de datos dado, donde solo puedes participar con la comunidad sino ver las visualizaciones de otros usuarios de R.Además elaborado una lista de Twitter de usuarios que se dedican la visualización de datos.Paquetes para la visualización de datos: los paquetes ggplot2 y plotly son probablemente los paquetes por excelencia en R para la visualización de datos. El primero es uno de los paquetes más potentes de R, dentro del entorno tidyverse, que solo nos permite crear gráficos muy limpios y elegantes con pocas líneas sino que su sintaxis es muy intuitiva respecto los datos visualizados. La idea inicial es poder aprender algo de ggplot2 en futuros capítulos pero puedes empezar si quieres echando un vistazo su web oficial. También te recomiendo el tutorial de Cédric Scherer. El segundo paquete, plotly puede llegar tener las mismas funcionalidades pero su programación es más tediosa. Su principal ventaja es que genera gráficos interactivos: gráficos HTML (como si fuera una página web) (una imagen estática) que permite al usuario interactuar con los datos pasando el ratón (incluso permite crear menús). Un ejemplo es la web de visualización covid de Asturias que elaboré durante la pandemia para el Gobierno de Asturias (la web en sí está elaborada con shiny, un paquete de R que permite crear aplicaciones web).Paquetes para la visualización de datos: los paquetes ggplot2 y plotly son probablemente los paquetes por excelencia en R para la visualización de datos. El primero es uno de los paquetes más potentes de R, dentro del entorno tidyverse, que solo nos permite crear gráficos muy limpios y elegantes con pocas líneas sino que su sintaxis es muy intuitiva respecto los datos visualizados. La idea inicial es poder aprender algo de ggplot2 en futuros capítulos pero puedes empezar si quieres echando un vistazo su web oficial. También te recomiendo el tutorial de Cédric Scherer. El segundo paquete, plotly puede llegar tener las mismas funcionalidades pero su programación es más tediosa. Su principal ventaja es que genera gráficos interactivos: gráficos HTML (como si fuera una página web) (una imagen estática) que permite al usuario interactuar con los datos pasando el ratón (incluso permite crear menús). Un ejemplo es la web de visualización covid de Asturias que elaboré durante la pandemia para el Gobierno de Asturias (la web en sí está elaborada con shiny, un paquete de R que permite crear aplicaciones web).Generación de informes desde R: el paquete rmarkdown permite generar directamente informes que mezclen texto, fórmulas matemáticas, gráficas y código R (como este mismo manual), sin necesidad de importarlos otras herramientas de Office.Generación de informes desde R: el paquete rmarkdown permite generar directamente informes que mezclen texto, fórmulas matemáticas, gráficas y código R (como este mismo manual), sin necesidad de importarlos otras herramientas de Office.Comunidad de R hispano: tenemos un grupo de Discord y grupo de Telegram varios usuarios de R en España para compartir recursos.Comunidad de R hispano: tenemos un grupo de Discord y grupo de Telegram varios usuarios de R en España para compartir recursos.","code":""},{"path":"aleatorio_1.html","id":"aleatorio_1","chapter":"Capítulo 11 Incursión aleatoria","heading":"Capítulo 11 Incursión aleatoria","text":"Antes de acabar esta breve introducción R merece la pena hablar de «lo aleatorio» y su generación en R.¿Cómo se define la aleatoriedad?Si alguna vez interactuado con matemáticos o estadísticos (Dios te libre), seguramente es una palabra que les hayas escuchado mentar: aleatoriedad. Existen múltiples definiciones, y este manual tampoco pretende ser un tratado de filosofía de la ciencia, pero podemos definir la aleatoriedad de la siguiente manera:AleatoriedadPropiedad de todo proceso cuyo resultado final se puede conocer con exactitud - nivel individual o particular - antes de que se realice, aunque las condiciones iniciales se mantengan constantes (ejemplo: lanzar un dado).¿Qué significa la palabra «aleatorio»?🛑 tiene que implicar algo caótico.\n🛑 significa que se pueda predecir nivel de conjunto.\n🛑 significa que carezca de un patrón de comportamiento.El ejemplo perfecto para entender las implicaciones de algo aleatorio es un dado, ya que podemos saber con exactitud cuál será la siguiente tirada, pero tiene un patrón: si tiramos un millón de veces, aproximadamente un sexto del total de tiradas serán un 1. En el análisis estadístico y en la programación en R nos vamos encontrar con múltiples situaciones en las que lo aleatorio juega un papel importante, y aunque este sea un tutorial muy básico e introductorio, creo que es interesante conocer algunas formas muy sencillas de generar números aleatorios (o…tanto, ahora llegamos la Sección 11.1).Empecemos por lo más simple: vamos simular tiradas de una moneda, asumiendo que solo tenemos dos opciones (eliminando la opción de caer de canto). Cuando tiramos una moneda es un experimento aleatorio, ya que sabemos el resultado exacto de la siguiente tirada, pero sí sabemos que la probabilidad teórica es de 50-50, y que las únicas opciones elegir son cara y cruz.Una forma de ver el experimento de lanzar una moneda es pensar que tenemos una urna con dos bolas (cara y cruz), y empezamos sacar bolas de la urna (permitiendo que al sacar una bola, se pueda devolver la urna de nuevo). Eso es precisamente lo que hace la función sample(), una función que nos seleccionará «aleatoriamente» elementos de una urna.x: los elementos distintos que tiene para elegir, que en nuestro caso serán \"cara\" y \"cruz\".size: el número de bolas que queremos sacar de la urna.replace: si tras extraer devolvemos la bola la urna (replace = TRUE) o si se queda fuera (replace = FALSE, valor por defecto).prob: la probabilidad que tiene cada elemento en caso de ser equiprobables (valor por defecto).Fíjate que hemos indicado explícitamente replace = TRUE para decirle que aunque solo tengamos dos opciones, vamos permitir que tras extraer una bola, la apuntemos, y la volvamos introducir (puede salir de nuevo). ¿Qué sucede si replace = FALSE (su valor por defecto)?Al tener solo dos opciones, y permitir que al extraer bolas vuelvan la urna, tras extraer las dos únicas bolas, el proceso puede continuar hasta los 20 lanzamientos.Como seguramente te hayas percatado, lanzar una moneda es un experimento dicotómico, y dichos experimentos tienen una gran ventaja en programación y es que podemos escribirlo en binario: 0 para lo que llamemos fracaso (cara, por ejemplo), 1 para lo que llamemos éxito (cruz).Generar experimentos dicotómicos de forma binario nos permite hacer cálculos sobre las tiradas de forma muy sencilla e intuitiva, ya que nos permite pasar de tener cadenas de texto números.El argumento prob = ... nos permite generar experimentos que sean dicotómicos pero que sean equiprobables, algo similar lanzar una moneda trucada (por ejemplo, 30% caras y 70% cruces). Nótese como dichas probabilidades deben ser introducidas como proporciones (divididas entre 100).📝Ejercicio: ¿cómo simularías 200 tiradas de un dado?Solución:","code":"\n# Tiramos 20 veces una moneda\nsample(x = c(\"cara\", \"cruz\"), size = 20, replace = TRUE)##  [1] \"cruz\" \"cara\" \"cara\" \"cruz\" \"cara\" \"cara\" \"cruz\" \"cruz\" \"cara\" \"cara\"\n## [11] \"cruz\" \"cara\" \"cruz\" \"cruz\" \"cruz\" \"cruz\" \"cara\" \"cruz\" \"cruz\" \"cruz\"\n# Tiramos 20 veces una moneda SIN reemplazamiento\nsample(x = c(\"cara\", \"cruz\"), size = 20)## Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n# Tiramos 50 veces una moneda: 0 es cara, 1 es cruz\nn_tiradas <- 50\ntiradas <- sample(x = 0:1, size = n_tiradas, replace = TRUE)\ntiradas##  [1] 0 0 0 1 1 1 0 1 1 1 0 1 0 1 0 0 0 1 0 0 0 1 1 0 1 0 0 0 1 1 1 1 1 1 1 0 0 0\n## [39] 1 1 0 0 1 1 0 1 0 1 1 1\n# Cantidad de cruces: sumamos los 1's\nsum(tiradas)## [1] 27\n# Cantidad de caras: lo que son cruces\nn_tiradas - sum(tiradas)## [1] 23\n# % de caras\ncat(paste0(100 * sum(tiradas) / n_tiradas, \"% de cruces\"))## 54% de cruces\n# Tiradas de una moneda trucada\ntiradas <- sample(x = 0:1, size = n_tiradas, replace = TRUE, prob = c(0.3, 0.7))\n\n# % de caras\ncat(paste0(100 * sum(tiradas) / n_tiradas, \"% de cruces\"))## 78% de cruces\n# Lo único que cambia son las opciones en la urna\nsample(x = 1:6, size = 200, replace = TRUE)##   [1] 6 4 1 3 6 6 4 5 6 5 6 5 3 5 4 1 2 2 1 6 6 4 5 6 4 2 1 6 6 4 2 5 3 1 1 2 2\n##  [38] 2 1 5 5 4 3 3 2 5 6 3 1 2 5 1 2 6 6 4 2 4 1 3 1 6 3 2 5 2 3 5 4 5 3 6 3 2\n##  [75] 4 3 2 1 2 2 6 2 3 4 3 3 2 3 5 6 2 1 2 2 4 3 6 4 2 4 4 3 2 2 6 2 6 2 1 1 2\n## [112] 6 6 4 5 6 6 6 6 4 3 5 4 6 3 6 4 6 2 6 2 6 4 5 2 4 4 3 5 6 4 5 1 3 1 4 5 6\n## [149] 4 4 4 2 6 2 2 3 2 3 1 4 4 4 4 3 4 5 6 5 5 3 5 3 4 2 1 2 6 2 5 2 3 3 4 1 5\n## [186] 1 5 5 4 5 3 2 4 5 6 5 3 4 1 6"},{"path":"aleatorio_1.html","id":"pseudoaleatorio","chapter":"Capítulo 11 Incursión aleatoria","heading":"11.1 Pseudoaleatoriedad","text":"Si hecho varias pruebas con los códigos de arriba quizás ya hayas visto que cada vez que lanzas el código, el resultado es distinto, algo similar lo que sucedería si lanzas una moneda. Prueba ejecutar este código varias veces.¿Y si quisiéramos generar toda la clase la misma tirada de moneda?Lo primero que quizás pienses es que es imposible, ya que al tirar una moneda en la vida real, nunca vamos tener forma de garantizar que salgan las mismas tiradas diferentes personas. Y efectivamente eso sería cierto si nuestros procesos generados hubiesen sido aleatorios, como en la vida real pero…lo son.Mientras esperamos que lleguen al mainstream los ordenadores cuánticos, TODO lo que hay en tu ordenador es determínistico, ya que cualquier proceso se reduce una secuencia de bits (0's y 1's) y un algoritmo (sin azar, cuyo resultado siempre será el mismo bajo las mismas condiciones iniciales). aquí la decepción de tu vida: un ordenador «normal» puede generar procesos aleatorios, sino procesos y números PSEUDOALEATORIOS, basados en cadenas pseudoaleatorias generadas por un algoritmo determinístico.Dichas secuencias aparentan ser aleatorias pero lo son, y de hecho muchas son periódicas: si generamos el número suficiente de elementos de la cadena pseudoaleatoria volveremos al inicio. Muchos de los algoritmos disponibles para generar números aleatorios dependen, entre otros factores, de un valor inicial llamada semilla (normalmente obtenida partir del reloj interno del ordenador): misma semilla, mismo resultado «aleatorio». Para fijar la semilla usaremos set.seed(), pasándole como argumento una secuencia de números (todos la misma).Siempre la misma tirada si la semilla inicial es la misma ya que las cadenas pseudoaleatorias que usa el ordenador para simular nuestras tiradas son idénticas.","code":"\nsample(0:1, size = 20, replace = TRUE)##  [1] 0 0 0 1 1 1 1 1 0 1 0 1 0 1 1 0 0 0 0 1\nsample(0:1, size = 20, replace = TRUE)##  [1] 1 1 0 1 1 0 0 1 0 0 1 0 1 1 1 0 1 0 1 0\nsample(0:1, size = 20, replace = TRUE)##  [1] 1 0 1 0 1 1 1 0 0 1 1 1 1 0 0 0 1 0 0 1\nset.seed(1234567)\nsample(0:1, size = 20, replace = TRUE)##  [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0\nset.seed(1234567)\nsample(0:1, size = 20, replace = TRUE)##  [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0\nset.seed(1234567)\nsample(0:1, size = 20, replace = TRUE)##  [1] 0 1 1 0 1 0 0 0 1 1 0 1 0 1 0 0 1 1 1 0"},{"path":"contribuye-al-proyecto.html","id":"contribuye-al-proyecto","chapter":"Capítulo 12 Contribuye al proyecto","heading":"Capítulo 12 Contribuye al proyecto","text":"\nImagen/gráfica 12.1: Holi.\nEspero que te haya servido de ayuda este manual, para ser un experto en R (ya que el manual pretendía dicho objetivo) sino ser capaz de ENTENDER cómo funciona R y quitarte el miedo empezar tus análisis.La idea es que haya otros manuales más avanzados, que partan de lo aprendido en este, pero si quieres (y te ha servido) puedes dejarme tu feedback y/o difundir dicho material por redes. Te dejo por aquí las mías:TwitterInstagramWebNewsletterSi además crees que este trabajo lo merece, así como mi divulgación en dichas redes, puedes dejar una pequeña contribución económica en el Patreon y poder interaccionar con la comunidad.Patreon","code":""},{"path":"bibliografía.html","id":"bibliografía","chapter":"Bibliografía","heading":"Bibliografía","text":"Xie, Yihui. 2015. Dynamic Documents R Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. http://yihui.org/knitr/.Ziemann, M., Y. Eren, . El-Osta. 2016. “Gene Name Errors Widespread Scientific Literature.” Genome Biology 17 (177).","code":""}]
