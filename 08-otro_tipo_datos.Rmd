```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Listas y funciones {-}

# Listas y factores {#otros-datos}

Veamos dos tipos de datos muy particulares más allá de vectores, matrices y `data.frames`.

## Listas

Probablemente las **listas** sea uno de los tipos de datos más importantes en `R` ya que permiten almacenar **colecciones de variables de diferente tipo (ya lo hacían los `data.frames`) pero también de diferente longitud**, y con estructuras totalmente heterógeneas, de ahí que sea el formato de salida de muchísimas funciones de `R` que te devuelven a la vez un cadena de texto, un vector de números o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro a su vez otra lista).

```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("tipo de dato" = c("x <- 1 (dato numérico)",
                                "x <- c(1, 2, 3) (vector de números)",
                                "x <- c('a', 'b', 'c') (vector de caracteres)",
                                "x <- matrix(1:6, nrow = 2)",
                                "x <- data.frame('a' = 1:3, 'b' = c('a', 'b', 'c'), 'c' = c(TRUE, TRUE, FALSE))",
                                "x <- list(1:3, c('a'), c(TRUE, FALSE))"),
             "descripción" = c("vector de longitud 1",
                               "vector (mismo tipo)",
                               "vector (mismo tipo)",
                               "matriz (mismo tipo, misma longitud)",
                               "data.frame (distinto tipo, misma longitud)",
                               "lista (distinto tipo, distinta longitud)"))
kable(paquetes, col.names = c("paquetes", "descripción"), align = "ll",
      caption = "Tipos de datos mencionados hasta ahora")
``` 

Vamos a crear nuestra primera lista.

```{r}
# Fecha de nacimiento
fecha_nacimiento <- as.Date("1989-09-10")

# Notas de asignaturas en primer y segundo parcial
notas <- data.frame("biología" = c(5, 7), "física" = c(4, 5),
                    "matemáticas" = c(8, 9.5))
row.names(notas) <- # Nombre a las filas
  c("primer_parcial", "segundo_parcial")

# Números de teléfono
tlf <- c("914719567", "617920765", "716505013")

# Nombres
padres <- c("Juan", "Julia")

# Guardamos TODO en una lista (con nombres de cada elemento)
datos <- list("nacimiento" = fecha_nacimiento,
              "notas_insti" = notas, "teléfonos" = tlf,
              "nombre_padres" = padres)
datos
names(datos)
``` 

Hemos creado una lista de 4 elementos:

* `nacimiento`: una fecha.
* `notas_insti`: un `data.frame`.
* `teléfonos`: vector de números.
* `nombre_padres`: vector de texto.

Una **lista es una varible que en un primer nivel solo tiene una dimensión** por lo que si quieres saber cuantos elementos tiene debes ejecutar la función `length()`.

```{r}
dim(datos) # devolverá NULL al no tener dos dimensiones
length(datos)
class(datos) # de tipo lista
```

Para acceder a un elemento de la lista tenemos dos opciones:

- Acceder por índice: con el operador `[[i]]` accedemos al elemento i-ésimo de la lista.

- Acceder por nombre: con el operador `$nombre_elemento` accedemos al elemento cuyo nombre sea `nombre_elemento`.

```{r}
datos[[1]]
datos$nacimiento

datos[[2]]
datos$notas_insti
```

Si queremos acceder a varios elementos a la vez de la lista deberemos usar el operador `[]`.

```{r}
datos[1:2]
```

Como hemos comentado, también podemos **aplicar la recursividad** y hacer **listas con otras listas dentro**, de forma que para acceder a cada nivel deberemos usar el operador `[[]]`.

```{r}

lista_de_listas <- list("lista_1" = datos[3:4], "lista_2" = datos[1:2])
names(lista_de_listas) # Nombres de los elementos del primer nivel
names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista
lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior
```


Un ejemplo de la utilidad de las listas la tenemos en los archivos `R.Data` de vacunas que hemos cargado en nuestro script. Con `names(panel_vacunas)` podemos ver que elementos contiene en el primer nivel.

```{r include = FALSE}
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
```

```{r}
names(panel_vacunas)
```

Cada elemento de la lista es un `data.frame` de una comunidad autonónoma, que a su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): **¡nos permite guardar «datos tridimensionales»!**.

```{r}
class(panel_vacunas$ES)
names(panel_vacunas$ES)
head(panel_vacunas$ES[, 1:5])
```

El acceso lo podemos realizar por orden que ocupa en la lista pero también de forma intuitiva con `$` y el código ISO de la comunidad autónoma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, está guardada la información de cada variable (columna) y cada comunidad (fila).

```{r}
names(panel_vacunas_fecha)
names(panel_vacunas_fecha$`2021-04-23`)
head(panel_vacunas_fecha$`2021-04-23`[, 1:7])
```


::: {.rmdcaution}

**`r colorize("Operaciones aritméticas con listas", "#dc3545")`**

Una **lista no se puede vectorizar de forma inmediata**, por lo cualquier operación aritmética aplicada a una lista dará error (para ello está disponible la función `lapply()`, cuyo uso corresponde a otros cursos más avanzados).

```{r error = TRUE}
datos / 2
``` 
:::


## Factores

Los **factores son el tipo de dato que tiene `R` para definir variables categóricas**, variables que aunque puedan ser números, en realidad representa **categorías (categoría 1, 2, 3...)**. Internamente los factores se guardan como variable numéricas enteras (enumerando las categorías) pero se nos mostarán con el nombre asignada a dicha categoría. Para convertir una variable a factor basta con ejecutar la función `factor()`, que nos convierte cada valor diferente en una categoría (para ver valores diferentes de un vector, usar la función `unique()`).


```{r}
datos <- c(1, 2, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1)
unique(datos)
datos
datos_factor <- factor(datos) # Convertimos a factor
datos_factor 
``` 

::: {.rmdwarning}

**`r colorize("Un factor es una CATEGORÍA", "#ffc107")`**

Es importante entender que un **factor es una CATEGORÍA**, como rojo/blanco/negro, por lo que desde el momento en el que lo convertimos en factor, ya no podemos hacer operaciones aritméticas (no podemos sumar categorías, solo números).


```{r error = TRUE}
datos + 1
datos_factor + 1
``` 
:::

Como puedes observar, al tenerlo en factor, además de la variable en sí se nos **muestra debajo los `levels`, los nombres de las categorías**. Si no le indicamos que nombres queremos, nos convierte los valores a texto y lo toma como nombre de categoría. Con el **argumento `labels` podemos configurarlo** a nuestro gusto. Con la función `levels` podemos reasignarle nombres tras su generación.

```{r}
datos_factor <- factor(datos, labels = paste("Categoría", sort(unique(datos)))) # damos nombre de categoría 1, 2, 3...
datos_factor 
levels(datos_factor) <- c("C1", "C2", "C3")
datos_factor
``` 

Aunque sirve también para variables numéricas, la función **`table()` nos calcula las frecuencias de cada una de las categorías**, las veces que se repiten en nuestro conjunto (es una forma eficiente de guardar categorías ya que solo se guardan los valores únicos y el número de veces que se repiten, así como su lugar).

```{r}
table(datos_factor)
``` 

Una ventaja de los factores es que le podemos **indicar que considere que las categorías son ordinales**: tiene una jerarquía de orden, con el argumento `ordered = TRUE`.

```{r}
notas <- c(7, 2, 10, 5, 7, 8, 10, 8, 2, 2, 5, 5, 5, 10) # notas de clase: tienen un orden
notas_factor <- factor(notas)
notas_factor[1] < notas_factor[2]

notas_factor_ordenados <- factor(notas, ordered = TRUE)
notas_factor_ordenados[1] < notas_factor_ordenados[2] # nos dice que la categoría 7 no es menor que la categoría 2
notas_factor_ordenados
``` 

Para pasar de factor a variable numérica (y poder operar con ellos), basta usar la función `as.numeric()`.

```{r error = TRUE}
notas_factor_ordenados + 1
as.numeric(notas_factor_ordenados) + 1
mean(as.numeric(notas_factor_ordenados))
``` 

También podemos **convertir variables continuas (o discretas) a factores indicando los rangos de las categorías** que queremos asignar con la función `cut()`. Por ejemplo, supongamos que tenemos notas numéricas de clase y queremos asignar una nota categórica. En el argumento `breaks` debemos indicarle los cortes que queremos en los datos, teniendo `n+1` valores, siendo `n` el número de categorías. Con `right = FALSE` le vamos a indicar que los intervalos son abiertos por la derecha.

```{r}
notas <- c(7.4, 1.1, 2.9, 10, 5.2, 7.7, 8.9, 10, 8.1, 2.6, 2.4, 5.5, 5, 5, 10, 6.3, 9.4) # notas de clase
notas_categoricas <- cut(notas, breaks = c(0, 5, 7, 9, 10, 10.1), labels = c("suspenso", "aprobado", "notable", "sobresaliente", "mh"), right = FALSE)
notas_categoricas
``` 

Además, la función `cut()` identifica los datos de tipo fecha, pudiendo hacer **cortes por unidades temporales**.


```{r}
fechas <- as.Date(c("2021-04-10", "2021-03-10", "2021-01-01", "2020-01-15", "2020-09-10", "2020-09-15", "2020-07-08"))
fechas_cortes <- cut(fechas, breaks = "year")
levels(fechas_cortes) <- c("2020", "2021")
fechas_cortes
``` 


::: {.rmdnote}

**`r colorize("Paquete forcats", "#4197D2")`**

En dicho paquete tienes muchas **funcionalidades para trabajar con factores**. Ver <https://forcats.tidyverse.org/>.

```{r forcats, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete lubridate."}
knitr::include_graphics("./img/forcats.png")
```
:::


## Fechas y horas

Como ya hemos dicho, **las fechas y momentos temporales no serán meras cadenas de caracter sino que tienen clases especiales asociadas** y algunas funciones especiales que pueden sernos útiles: las fechas serán de tipo `dates` mientras que las horas será de tipo `POSIXct` o `POSIXlt`. En el primer caso, las fechas serán guardadas internamente como el **número de días transcurridos desde el 1 de enero de 1970**, y las horas como **número de segundos desde el 1 de enero de 1970** (para la clase `POSIXct`) o una lista de segundos, minutos y horas (para la clase `POSIXlt`).

**¿Cómo obtener automáticamente la fecha de hoy, por ejemplo?** La función `Sys.Date()` nos devuelve directamente la fecha y hora en el momento de la ejecución de la orden.

```{r}
fecha <- Sys.Date()
fecha
fecha - 7 # una semana antes
class(fecha) # de clase fecha
``` 

Para **convertir una cadena de texto a fecha**, basta usar la función `as.Date()` del paquete `{base}`, pasándole como argumento la fecha en formato `"yyyy-mm-dd"` por defecto.

```{r}
as.Date("2021-03-10") # formato por defecto
```

Si **introducimos otro tipo de formato**, debemos especificárselo en un segundo argumento, para `R` sepa el formato de fecha que le estamos pasando

```{r}
as.Date("10-03-2020", "%d-%m-%Y") # con día-mes-año (4 cifras)
as.Date("10-03-20", "%d-%m-%y")  # con día-mes-año (2 cifras)
as.Date("03-10-2020", "%m-%d-%Y") # con mes-día-año (4 cifras)
as.Date("Octubre 21, 1995 21:24", "%B %d, %Y %H:%M") # fecha escrita
``` 

::: {.rmdcaution}

**`r colorize("Sin pasar a fecha no se puede operar", "#dc3545")`**

Si tenemos una fecha como caracter, nunca podremos hacer operaciones (por ejemplo, restarle una unidad temporal, en este caso un día).

```{r error = TRUE}
"2021-03-10" - 1 # error
```

Fíjate la diferencia cuando lo convertimos en fecha

```{r error = TRUE}
fecha <- as.Date("2021-03-10") - 1 # día previo
fecha
``` 

Aunque aparentemente parezca una cadena de texto, prueba a ejecutar `unclass(fecha)` para comprobar que tiene internamente guardado.

```{r}
unclass(fecha)
unclass(as.Date("1969-01-01")) # un año antes de la referencia a partir de la cual cuenta días
``` 
:::


::: {.rmdimportant}

**`r colorize("Paquete lubridate", "#20935E")`**

Dentro del entorno `{tidyverse}`, el paquete `{lubridate}` nos permite una gestión mucho más intuitiva de las fechas

```{r eval = FALSE}
install.packages("lubridate")
library(lubridate)
```

```{r include = FALSE}
library(lubridate)
```

```{r}
ymd_hms("2017-11-28T14:02:00") # convertir a fecha una cadena año-mes-día + hora
ydm_hms("2017-22-12 10:00:00") # convertir a fecha una cadena año-día-mes + hora
dmy_hms("1 Jan 2017 23:59:59") # convertir a fecha una cadena textual de fecha + hora
mdy("July 4th, 2000") # convertir a fecha una cadena textual de fecha
ymd(20170131)
```
:::

En dicho paquete tienes muchas **funcionalidades para trabajar con fechas**. Ver <https://lubridate.tidyverse.org/>.

```{r lubridate, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete lubridate."}
knitr::include_graphics("./img/lubridate.png")
```


```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("paquetes" = c("{base}", "{bookdown}", "{glue}",
                            "{stringr}", "{lubridate}", "{microbenchmark}",
                            "{tibble}", "{datasets}", "{readr}", "{tidyverse}",
                            "{readxl}", "{rvest}"),
             "descripción" = c("utilidades básicas",
                               "creación de libros, manuales e informes en R",
                               "manejo de texto literal",
                               "manejo complejo de cadenas de texto",
                               "manejo de fechas",
                               "comparativa de tiempos de ejecución",
                               "data.frames eficientes",
                               "conjuntos de datos",
                               "lectura de datos rectangulares (tablas)",
                               "entorno de paquetes para el manejo de datos",
                               "lectura de datos en formato excel",
                               "lectura de datos web"))
kable(paquetes, col.names = c("paquetes", "descripción"), align = "ll",
      caption = "Paquetes mencionados hasta ahora")
``` 


El paquete `{lubridate}` nos proporciona **herramientas para extraer la fecha y hora actuales** con las funciones `today()` y `now()`

```{r}
today()
now()
```


Además tenemos disponibles en dicho paquete funciones para extraer facilmente algunas variables temporales como el día de la semana, el mes o el cuatrimestre, con las funciones `year()`, `months()`, `day()` o `wday()` (día de la semana).


```{r}
fecha <- now()
year(fecha)
month(fecha)
day(fecha)
wday(fecha, week_start = 1) # Día de la semana (empezando por el lunes)
hour(fecha)
minute(fecha)
second(fecha)
week(fecha) # Número de semana (del año)
``` 

Al igual que podemos realizar operaciones aritméticas sencillas con las fechas, también podemos **realizar comparaciones**, por ejemplo, si el día actual es menor o mayor que otra fecha dada. 

```{r}
fecha_actual <- now()
fecha_actual > ymd(20170131) # Actual vs 2017-01-31
fecha_actual > ymd(21000131) # Actual vs 2100-01-31
``` 



## 📝 Ejercicios

<details>
  <summary><strong>Ejercicio 1</strong>: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluiré uno que sea un `data.frame` para que veas que en una lista cabe de todo).</summary>
  
  
<!-- toc -->
- Solución:

```{r}
# Ejemplo: lista con texto, numérico, lógico y un data.frame
lista_ejemplo <- list("nombre" = "Javier", "cp" = 28019,
                      "soltero" = TRUE,
                      "notas" = data.frame("mates" = c(7.5, 8, 9),
                                           "lengua" = c(10, 5, 6),
                                           "gimnasia" = c(4, 8, 6)))
lista_ejemplo

# Longitud
length(lista_ejemplo)

# Accedemos al elemento dos
lista_ejemplo[[2]]
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: accede a los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.</summary>
  
  
<!-- toc -->
- Solución:

```{r}
# Accedemos al 1 y al 4
lista_ejemplo[c(1, 4)]
```

Otra opción es acceder con los nombres

```{r}
# Accedemos al 1 y al 4
lista_ejemplo$nombre
lista_ejemplo$notas
```

</details>

&nbsp; 


<details>
  <summary><strong>Ejercicio 3</strong>: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato numérico) y si estás soltero/a.</summary>
  
  
<!-- toc -->
- Solución:

```{r}
library(lubridate)
# Creamos lista: con lubridate calculamos la diferencia de años desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "Álvarez Liébana",
                       "edad" = time_length(interval(ymd("1989-09-10"), ymd(Sys.Date())), unit = "years"),
                       "soltero" = TRUE)
lista_personal

# Otra opción: la edad calculada con floor (quita decimales y se queda con la parte entera)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "Álvarez Liébana",
                       "edad" = floor(time_length(interval(ymd("1989-09-10"), ymd(today())), unit = "years")),
                       "soltero" = TRUE)
lista_personal
```

</details>




