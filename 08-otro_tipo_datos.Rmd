```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```

# (PART) Listas y funciones {-}

# Listas y factores {#otros-datos}

Veamos dos tipos de datos muy particulares más allá de vectores, matrices y `data.frames`.

## Listas

Probablemente las **listas** sea uno de los tipos de datos más importantes en `R` ya que permiten almacenar **colecciones de variables de diferente tipo (ya lo hacían los `data.frames`) pero también de diferente longitud**, y con estructuras totalmente heterógeneas, de ahí que sea el formato de salida de muchísimas funciones de `R` que te devuelven a la vez un cadena de texto, un vector de números o una tabla, todo guardado en la misma variable (incluso una lista puede tener dentro a su vez otra lista).

```{r echo = FALSE}
library(knitr)
paquetes <-
  data.frame("tipo de dato" = c("x <- 1 (dato numérico)",
                                "x <- c(1, 2, 3) (vector de números)",
                                "x <- c('a', 'b', 'c') (vector de caracteres)",
                                "x <- matrix(1:6, nrow = 2)",
                                "x <- data.frame('a' = 1:3, 'b' = c('a', 'b', 'c'), 'c' = c(TRUE, TRUE, FALSE))",
                                "x <- list(1:3, c('a'), c(TRUE, FALSE))"),
             "descripción" = c("vector de longitud 1",
                               "vector (mismo tipo)",
                               "vector (mismo tipo)",
                               "matriz (mismo tipo, misma longitud)",
                               "data.frame (distinto tipo, misma longitud)",
                               "lista (distinto tipo, distinta longitud)"))
kable(paquetes, col.names = c("paquetes", "descripción"), align = "ll",
      caption = "Tipos de datos mencionados hasta ahora")
``` 

Vamos a crear nuestra primera lista.

```{r}
# Fecha de nacimiento
fecha_nacimiento <- as.Date("1989-09-10")

# Notas de asignaturas en primer y segundo parcial
notas <- data.frame("biología" = c(5, 7), "física" = c(4, 5),
                    "matemáticas" = c(8, 9.5))
row.names(notas) <- # Nombre a las filas
  c("primer_parcial", "segundo_parcial")

# Números de teléfono
tlf <- c("914719567", "617920765", "716505013")

# Nombres
padres <- c("Juan", "Julia")

# Guardamos TODO en una lista (con nombres de cada elemento)
datos <- list("nacimiento" = fecha_nacimiento,
              "notas_insti" = notas, "teléfonos" = tlf,
              "nombre_padres" = padres)
datos
names(datos)
``` 

Hemos creado una lista de 4 elementos:

* `nacimiento`: una fecha.
* `notas_insti`: un `data.frame`.
* `teléfonos`: vector de números.
* `nombre_padres`: vector de texto.

Una **lista es una varible que en un primer nivel solo tiene una dimensión** por lo que si quieres saber cuantos elementos tiene debes ejecutar la función `length()`.

```{r}
dim(datos) # devolverá NULL al no tener dos dimensiones
length(datos)
class(datos) # de tipo lista
```

Para acceder a un elemento de la lista tenemos dos opciones:

- Acceder por índice: con el operador `[[i]]` accedemos al elemento i-ésimo de la lista.

- Acceder por nombre: con el operador `$nombre_elemento` accedemos al elemento cuyo nombre sea `nombre_elemento`.

```{r}
datos[[1]]
datos$nacimiento

datos[[2]]
datos$notas_insti
```

Si queremos acceder a varios elementos a la vez de la lista deberemos usar el operador `[]`.

```{r}
datos[1:2]
```

Como hemos comentado, también podemos **aplicar la recursividad** y hacer **listas con otras listas dentro**, de forma que para acceder a cada nivel deberemos usar el operador `[[]]`.

```{r}

lista_de_listas <- list("lista_1" = datos[3:4], "lista_2" = datos[1:2])
names(lista_de_listas) # Nombres de los elementos del primer nivel
names(lista_de_listas[[1]]) # Nombres de los elementos guardados en el primer elemento, que es a su vez una lista
lista_de_listas[[1]][[1]] # Elemento 1 de la lista guardada como elemento 1 de la lista superior
```


Un ejemplo de la utilidad de las listas la tenemos en los archivos `R.Data` de vacunas que hemos cargado en nuestro script. Con `names(panel_vacunas)` podemos ver que elementos contiene en el primer nivel.

```{r include = FALSE}
load("./DATOS/panel_vacunas_ccaa.RData")
load("./DATOS/panel_vacunas_fecha.RData")
```

```{r}
names(panel_vacunas)
```

Cada elemento de la lista es un `data.frame` de una comunidad autonónoma, que a su vez contiene una serie de variables (columnas) para cada una de las fechas (filas): **¡nos permite guardar «datos tridimensionales»!**.

```{r}
class(panel_vacunas$ES)
names(panel_vacunas$ES)
head(panel_vacunas$ES[, 1:5])
```

El acceso lo podemos realizar por orden que ocupa en la lista pero también de forma intuitiva con `$` y el código ISO de la comunidad autónoma. Lo mismo podemos hacer con el panel de fechas, donde ahora cada elemento de la lista es una fecha, y en cada elemento de ella, está guardada la información de cada variable (columna) y cada comunidad (fila).

```{r}
names(panel_vacunas_fecha)
names(panel_vacunas_fecha$`2021-04-23`)
head(panel_vacunas_fecha$`2021-04-23`[, 1:7])
```

&nbsp;

**`r colorize("WARNING: operaciones aritméticas con listas", "#dc3545")`**

Una **lista no se puede vectorizar de forma inmediata**, por lo cualquier operación aritmética aplicada a una lista dará error (para ello está disponible la función `lapply()`, cuyo uso corresponde a otros cursos más avanzados).

```{r error = TRUE}
datos / 2
``` 
&nbsp;


## Factores

Los **factores son el tipo de dato que tiene `R` para definir variables categóricas**, variables que aunque puedan ser números, en realidad representa **categorías (categoría 1, 2, 3...)**. Internamente los factores se guardan como variable numéricas enteras (enumerando las categorías) pero se nos mostarán con el nombre asignada a dicha categoría. Para convertir una variable a factor basta con ejecutar la función `factor()`, que nos convierte cada valor diferente en una categoría (para ver valores diferentes de un vector, usar la función `unique()`).


```{r}
datos <- c(1, 2, 2, 3, 1, 2, 3, 3, 1, 2, 3, 3, 1)
unique(datos)
datos
datos_factor <- factor(datos) # Convertimos a factor
datos_factor 
``` 

&nbsp;

**`r colorize("WARNING: un factor es una CATEGORÍA", "#ffc107")`**

Es importante entender que un **factor es una CATEGORÍA**, como rojo/blanco/negro, por lo que desde el momento en el que lo convertimos en factor, ya no podemos hacer operaciones aritméticas (no podemos sumar categorías, solo números).


```{r error = TRUE}
datos + 1
datos_factor + 1
``` 
&nbsp;

Como puedes observar, al tenerlo en factor, además de la variable en sí se nos **muestra debajo los `levels`, los nombres de las categorías**. Si no le indicamos que nombres queremos, nos convierte los valores a texto y lo toma como nombre de categoría. Con el **argumento `labels` podemos configurarlo** a nuestro gusto. Con la función `levels` podemos reasignarle nombres tras su generación.

```{r}
datos_factor <- factor(datos, labels = paste("Categoría", sort(unique(datos)))) # damos nombre de categoría 1, 2, 3...
datos_factor 
levels(datos_factor) <- c("C1", "C2", "C3")
datos_factor
``` 

Aunque sirve también para variables numéricas, la función **`table()` nos calcula las frecuencias de cada una de las categorías**, las veces que se repiten en nuestro conjunto (es una forma eficiente de guardar categorías ya que solo se guardan los valores únicos y el número de veces que se repiten, así como su lugar).

```{r}
table(datos_factor)
``` 

Una ventaja de los factores es que le podemos **indicar que considere que las categorías son ordinales**: tiene una jerarquía de orden, con el argumento `ordered = TRUE`.

```{r}
notas <- c(7, 2, 10, 5, 7, 8, 10, 8, 2, 2, 5, 5, 5, 10) # notas de clase: tienen un orden
notas_factor <- factor(notas)
notas_factor[1] < notas_factor[2]

notas_factor_ordenados <- factor(notas, ordered = TRUE)
notas_factor_ordenados[1] < notas_factor_ordenados[2] # nos dice que la categoría 7 no es menor que la categoría 2
notas_factor_ordenados
``` 

Para pasar de factor a variable numérica (y poder operar con ellos), basta usar la función `as.numeric()`.

```{r error = TRUE}
notas_factor_ordenados + 1
as.numeric(notas_factor_ordenados) + 1
mean(as.numeric(notas_factor_ordenados))
``` 

También podemos **convertir variables continuas (o discretas) a factores indicando los rangos de las categorías** que queremos asignar con la función `cut()`. Por ejemplo, supongamos que tenemos notas numéricas de clase y queremos asignar una nota categórica. En el argumento `breaks` debemos indicarle los cortes que queremos en los datos, teniendo `n+1` valores, siendo `n` el número de categorías. Con `right = FALSE` le vamos a indicar que los intervalos son abiertos por la derecha.

```{r}
notas <- c(7.4, 1.1, 2.9, 10, 5.2, 7.7, 8.9, 10, 8.1, 2.6, 2.4, 5.5, 5, 5, 10, 6.3, 9.4) # notas de clase
notas_categoricas <- cut(notas, breaks = c(0, 5, 7, 9, 10, 10.1), labels = c("suspenso", "aprobado", "notable", "sobresaliente", "mh"), right = FALSE)
notas_categoricas
``` 

Además, la función `cut()` identifica los datos de tipo fecha, pudiendo hacer **cortes por unidades temporales**.


```{r}
fechas <- as.Date(c("2021-04-10", "2021-03-10", "2021-01-01", "2020-01-15", "2020-09-10", "2020-09-15", "2020-07-08"))
fechas_cortes <- cut(fechas, breaks = "year")
levels(fechas_cortes) <- c("2020", "2021")
fechas_cortes
``` 


&nbsp;

**`r colorize("CONSEJO: paquete forcats", "#4197D2")`**

En dicho paquete tienes muchas **funcionalidades para trabajar con factores**. Ver <https://forcats.tidyverse.org/>.

```{r forcats, echo = FALSE, out.width = "95%", fig.align = "center", fig.cap = "Paquete lubridate."}
knitr::include_graphics("./img/forcats.png")
```
&nbsp;




## 📝 Ejercicios

<details>
  <summary><strong>Ejercicio 1</strong>: define una lista de 4 elementos de tipos distintos y accede al segundo de ellos (yo incluiré uno que sea un `data.frame` para que veas que en una lista cabe de todo).</summary>
  
  
<!-- toc -->
- Solución:

```{r}
# Ejemplo: lista con texto, numérico, lógico y un data.frame
lista_ejemplo <- list("nombre" = "Javier", "cp" = 28019,
                      "soltero" = TRUE,
                      "notas" = data.frame("mates" = c(7.5, 8, 9),
                                           "lengua" = c(10, 5, 6),
                                           "gimnasia" = c(4, 8, 6)))
lista_ejemplo

# Longitud
length(lista_ejemplo)

# Accedemos al elemento dos
lista_ejemplo[[2]]
```

</details>

&nbsp; 

<details>
  <summary><strong>Ejercicio 2</strong>: accede a los elementos que ocupan los lugares 1 y 4 de la lista definida anteriormente.</summary>
  
  
<!-- toc -->
- Solución:

```{r}
# Accedemos al 1 y al 4
lista_ejemplo[c(1, 4)]
```

Otra opción es acceder con los nombres

```{r}
# Accedemos al 1 y al 4
lista_ejemplo$nombre
lista_ejemplo$notas
```

</details>

&nbsp; 


<details>
  <summary><strong>Ejercicio 3</strong>: define una lista de 4 elementos que contenga, en una sola variable, tu nombre, apellido, edad (como dato numérico) y si estás soltero/a.</summary>
  
  
<!-- toc -->
- Solución:

```{r}
library(lubridate)
# Creamos lista: con lubridate calculamos la diferencia de años desde la fecha de nuestro nacimiento hasta hoy (sea cuando sea hoy)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "Álvarez Liébana",
                       "edad" = time_length(interval(ymd("1989-09-10"), ymd(Sys.Date())), unit = "years"),
                       "soltero" = TRUE)
lista_personal

# Otra opción: la edad calculada con floor (quita decimales y se queda con la parte entera)
lista_personal <- list("nombre" = "Javier",
                       "apellidos" = "Álvarez Liébana",
                       "edad" = floor(time_length(interval(ymd("1989-09-10"), ymd(today())), unit = "years")),
                       "soltero" = TRUE)
lista_personal
```

</details>




