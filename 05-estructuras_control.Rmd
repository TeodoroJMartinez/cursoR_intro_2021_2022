```{r echo = FALSE}
library(knitr)

# Color text
colorize <- function(x, color) {
  
  if (knitr::is_latex_output()) {
    
    sprintf("\\textcolor{%s}{%s}", color, x)
    
  } else if (knitr::is_html_output()) {
    
    sprintf("<span style='color: %s;'>%s</span>", color, x)
    
  } else { x }
}
```


# Estructuras de control {#control}

Aunque la mayor√≠a de veces son sustituibles por otras expresiones m√°s legibles y eficientes, es importante que conozcamos como se usan las **expresiones de control m√°s t√≠picas**.

## if...else
 
 
Como en cualquier lenguaje de programaci√≥n, las **estructuras `if...else...` nos permiten ejecutar partes de nuestro c√≥digo solo cuando se cumple la condici√≥n o condiciones l√≥gicas** que queremos. Cuando ejecutamos un `if` estamos diciendo

::: {.rmdnote}

**`r colorize("if...else", "#4197D2")`**

SI las condiciones impuestas se cumplen (`TRUE`), ejecuta las √≥rdenes que tengamos dentro de las llaves. Si el`if` devuelve `FALSE`, no suceder√° nada **SALVO** que tengamos adem√°s un **`else`: lo que sucede cuando no se cumple**, como en el ejemplo que tenemos debajo.

:::


```{r}
edades <- c(14, 24, 56, 31, 20, 87, 73)
mayores_de_edad <- FALSE 

if (all(edades >= 18)) { # Si todas las personas son mayores de edad
  
  mayores_de_edad <- TRUE
  print("todos mayores de edad")
  
} else { # si la condici√≥n no se cumple: filtramos solo los mayores

  edades <- edades[edades >= 18]  
  print("alg√∫n menor de edad se ha eliminado")
  
}
```

Las √≥rdenes dentro del primer `if` se ejecutar√°n si todas las personas son mayores de edad. En caso de no cumplirse (como es el caso), se ejecutar√° lo que hay entre llaves tras el `else` (filtra solo los mayores de edad e imprime un mensaje de control).

Dicha estructura puede **anidarse**, de forma que vayamos concatenando estructuras `ifelse`, como en el ejemplo que tenemos debajo.

```{r}
edades <- c(14, 14, 16, 11, 2, 17, 13)

if (all(edades >= 18)) { # Si todas las personas son mayores de edad
  
  mayores_de_edad <- TRUE
  print("todos mayores de edad")
  
} else if (any(edades >= 18)) { # si alguna es mayor de edad

  edades_18 <- edades[edades >= 18]  
  print("alg√∫n menor de edad se ha eliminado")
  
} else { # ninguna persona mayor de edad
  
  print("todas las personas son menores de edad")
  
}
```


Esta **estructura condicional puede ser vectorizada**, de forma que podamos reunir en una **sola fila un n√∫mero elevado de estructuras de comparaci√≥n**. Por ejemplo, vamos a definir un vector de n√∫meros y vamos a comprobar si son n√∫meros pares o impares (para ello, usamos el operador `%%`, que nos calcula el resto de cada n√∫mero al dividirlo por una cifra).

```{r}
1 %% 2
2 %% 2
3 %% 2
5 %% 3
```

Para nuestro objetivo aplicaremos la funci√≥n `ifelse()`, cuyos argumentos de entrada ser√°n la condici√≥n a evaluar, lo que sucede cuando se cumple y lo que no, que aplicar√° a cada elemento del vector de entrada.


```{r}
numeros <- 1:10
ifelse((numeros %% 2) == 0, "par", "impar") # Los pares al dividir entre 2 tienen resto 0
```

Esta funci√≥n `ifelse()` es muy util para codificar variables o averiguar cuales cumplen una condici√≥n, sin necesidad de hacer un bucle que recorra todos los valores. 

::: {.rmdimportant}

**`r colorize("CONSEJO", "#20935E")`**

Recuerda: di (por lo general) no a los bucles en `R`.
:::


## for/while

Aunque el 99% de las veces (porcentaje inventado) los bucles pueden ser sustituidos por c√≥digos de forma vectorial mucho m√°s eficientes, a veces no nos quedar√° m√°s remedio que usarlos por lo que nunca viene mal conocer su estructura.

Un **bucle `for{}` es una estructura que nos permite ejecutar un conjunto de √≥rdenes un n√∫mero repetido (finito y conocido)** de veces: dado un conjunto de √≠ndices, el **bucle ir√° recorriendo cada elemento** de dicho conjunto, y para cada uno de ellos ejecutar√° lo que tenga dentro de las llaves.

```{r}
variable <- NULL # vector donde guardaremos los pasos del bucle
for (i in 1:10) { 
  
  variable[i] <- i # R es silenciosos: salvo que hagamos un print dentro del bucle no nos imprimir√° nada por pantalla
}
variable
```

```{r}
for (i in 1:10) { 
  
  print(i^3) # imprimimos el √≠ndice al cubo
}
```

Aunque normalmente el conjunto que recorre el bucle suelen ser √≠ndices num√©ricos, **podemos recorrer cualquier tipo de objeto**.

```{r}
dias_semana <- c("lunes", "martes", "mi√©rcoles", "jueves",
                 "viernes", "s√°bado", "domingo")
nombre_mayuscula <- NULL
for (dias in dias_semana) { # dias recorre los d√≠as de la semana tomando sus valores
  
  print(toupper(dias))
}
```

::: {.rmdimportant}

**`r colorize("CONSEJO: evita bucles", "#20935E")`**

Evita al m√°ximo los bucles en `R`: suele existir una forma m√°s eficiente de programarlo. Veamos un ejemplo muy sencillo: dado un vector de √≠ndices `idx`, queremos calcular su cuadrado y guardarlo. Vamos a comparar como ser√≠a con un sencillo bucle y de forma vectorial, repiti√©ndolo 1000 veces para sacar tiempos medios, haciendo uso del paquete `{microbenchmark}`.

```{r}
idx <- 1:10000
x <- y <- rep(0, length(idx))
microbenchmark::microbenchmark(x <- idx^2, 
                               for (i in idx) {  y[i] <- idx[i]^2},
                               times = 1e3)
``` 

Una tarea tan sencilla, **programada en un bucle (segunda fila), tarda 40 veces m√°s que hacerlo de forma vectorial (primera fila)** (elevando cada elemento al cuadrado, iterando internamente, sin necesidad de implementar un bucle).

&nbsp;

Otra manera de dise√±ar un bucle es con la **estructura `while{}`**, que ejecutar√° el **bucle un n√∫mero de veces a priori desconocido** hasta que la condici√≥n impuesta deje de ser `TRUE`.

```{r}
max_ciclos <- 10
ciclos <- 1

# Mientras el n√∫mero de ciclos sea inferior 10, imprime
while(ciclos <= max_ciclos) {
  
  print(paste("Todav√≠a no, vamos por el ciclo ", ciclos)) # Pegamos la frase al n√∫mero de ciclo por el que vayamos con paste
  ciclos <- ciclos + 1
  
}
``` 

**¬øY qu√© sucede cuando la condici√≥n nunca llega a ser `FALSE`?** Compru√©balo t√∫ mismo/a.

```{r eval = FALSE}
while (1 > 0) { # Nunca va a dejar de ser cierto
  
  print("Presiona ESC para salir del bucle")
  
}
```

### BREAK/NEXT

En `R` tenemos dos comandos reservados para poder **abortar un bucle** o **avanzar forzosamente un bucle**: dichas palabras son `break` y `next`. La primera nos habilita para **parar un bucle** aunque no haya llegado al final de su conjunto de √≠ndices a recorrer (o se siga cumpliendo la condici√≥n del `while{}`).

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    break # si i es 7, el bucle frena aqu√≠ (nunca llegar√° a imprimir el 7 ni los sucesivos)
    
  }
  print(i)
}
```

Mientras que la segunda **obliga al bucle a avanzar a la siguiente interacci√≥n**, abortando la iteraci√≥n actual en la que se encuentra. 

```{r}
for(i in 1:10) {
  if (i == 7) {
    
    next # si i es 7, la iteraci√≥n frenar√° aqu√≠ y pasar√° a la siguiente por lo que imprimir√° todos menos el 7
    
  }
  print(i)
}
```

### REPEAT

Aunque es una opci√≥n muy poco usada, existe una estructura de control llamada `repeat{}` que nos **ejecuta un bucle de forma infinita** hasta que le ordenemos parar con un `break`.

```{r}
conteo <- 0
repeat { 
  
  conteo <- conteo + 1
  if (conteo >= 100) { break }
  
}
conteo
``` 



::: {.rmdwarning}

**`r colorize("Cuidado con los bucles infinitos", "#ffc107")`**


Las estucturas `while{}` y `repeat{}` son de las menos usadas por su peligrosidad, ya que si no incluimos un `break` o la condici√≥n nunca llega a ser `TRUE`, el bucle seguir√° ejecut√°ndose de forma infinita y solo podr√° ser detenido abortando la ejecuci√≥n con la tecla `ESC`.

:::

::: {.rmdimportant}

**`r colorize("CONSEJO: minimiza estructuras de control en el c√≥digo", "#20935E")`**

Puedes minimizar las estructuras de control pulsando en la flecha que aparece a la izquierda de ellas. 

:::



## üìù Ejercicios

(haz click en las flechas para ver soluciones)

<details>
  <summary>üìù<strong>Ejercicio 1</strong>: del paquete `{lubridate}`, la funci√≥n `hour()` nos devuelve la hora de una fecha dada, y la funci√≥n `now()` nos devuelve fecha y hora del momento actual. Con ambas funciones, y usando estructuras `if...else`, imprime por pantalla `"buenos d√≠as"`, `"buenas tardes"` (de 14 a 22) o `"buenas noches"` (a partir de las 22). </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Cargamos librer√≠a
library(lubridate)

# Fecha actual
fecha_actual <- now()

# Estructura if-else
if (hour(fecha_actual) < 14) {
  
  cat("Buenos d√≠as")
} else if (hour(fecha_actual) < 22) {
  
  cat("Buenas tardes")
  
} else {
  
  cat("Buenas noches")
}
```

<!-- tocstop -->
</details>

&nbsp;


<details>
  <summary>üìù<strong>Ejercicio 2</strong>: realiza el ejercicio anterior pero sin estructura de llaves, de forma concisa con `ifelse()`. Mira la ayuda si la necesitases poniendo `? ifelse`. </summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# Cargamos librer√≠a
library(lubridate)

# Fecha actual
fecha_actual <- now()

# Estructura if-else
cat(ifelse(hour(fecha_actual) < 14, "Buenos d√≠as",
       ifelse(hour(fecha_actual) < 22, "Buenas tardes",
              "Buenas noches")))
  
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 3</strong>: dise√±a un bucle `for` de 200 iteraciones que, empezando en un valor inicial de 100 (euros), te sume 3‚Ç¨ si el n√∫mero actual es par y te restr 5‚Ç¨ si es impar.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# dinero inicial
dinero <- 100

# Bucle for
for (i in 1:200) {
  
  # si dinero es par, dinero %% 2 == 0 (el resto de dividir entre 2 es 0)
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 4</strong>: dise√±a el anterior bucle pero guardando el dinero de cada iteraci√≥n.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
# vector de importes
dinero <- rep(0, 201)
dinero[1] <- 100 # dinero inicial

# Bucle for
for (i in 2:201) {
  
  # si dinero[i - 1] es par o  impar
  dinero[i] <- ifelse(dinero[i - 1] %% 2 == 0, dinero[i - 1] + 3,
                      dinero[i - 1]  - 5)
  
}
dinero
```

<!-- tocstop -->
</details>

&nbsp;

<details>
  <summary>üìù<strong>Ejercicio 5</strong>: dise√±a el bucle del ejercicio 3  parando cuando no nos quede dinero.</summary>
  
<!-- toc -->
- Soluci√≥n:

```{r}
dinero <- 100 # dinero inicial

# Bucle while
while (dinero > 0) {
  
  dinero <- ifelse(dinero %% 2 == 0, dinero + 3, dinero - 5)
  
}
dinero
```

<!-- tocstop -->
</details>



